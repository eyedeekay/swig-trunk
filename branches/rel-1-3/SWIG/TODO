SWIG TO-DO    

Release: SWIG-1.3.14    (Late July, 2002)
-----------------------------------------------------------------------------

****    = High Priority
***     = Implement if possible.
**      = Will implement if time. 
*       = Implement if bored (or deemed necessary).

defer   = Implement in 1.3.15

CORE:

****   Add support for nested classes.   The type system should be
defer  ready to go.  The primary obstacle lies in the target language
       modules (which were never programmed with nested classes in
       mind).  There are also issues with nested C structures.  For
       example:

             struct Foo {
                 struct {
                     int x,y;
                 } z;
             };

       This is one of the last remaining "hard" problems in the SWIG
       core, but it is important that we solve it.  

[DONE] Better modularization of language modules and a minor redesign
       of the very high-level API.   Issues:

       -  Language modules should be created by a factory function
           with C linkage.  For example:

              Language *PYTHON_init() {
                  return new PYTHON();
              }

           swigmain.cxx should then be modified to only use the factory
           functions when bringing a module into existence.  This
           decouples main() from the implementation of each language
           module---and eliminates the need to have header files
           for each module. 

           Placing C linkage on the initialization function provides
           support for eventual dynamic loading of SWIG modules--it 
           establishes a well-known symbol name that can be used in
           conjunction with the dynamic loader.

        -  Perhaps the module system would be simplified by having
           all code located in a single file instead of a separate
           header file and a separate implementation file.

        -  Does anyone inherit from existing modules?

[DONE] We should either add "memberin" typemaps for all arrays or
       eliminate this typemap altogether.  There is really only 
       one way to handle this case.  

            %typemap(memberin) int [ANY] {
	          int i;
                  for (i = 0; i < $1_dim0; i++) {
                      $1[i] = $input[i];
                  }
            }

       Note: Needs more extensive testing.

[DONE] Support for overloaded functions.   It is probably possible to
       add some kind of support for this.  Overloading has been supported
       internally for quite some time---the warning messages are there
       simply as a stop-gap measure (since no language modules support
       overloading).    We would keep the the existing %rename support.

       Finished in Python, Tcl, Perl, and Ruby modules.

       Needs testing.

[DONE] Support for smart-pointers and proxies.  This is primarily to
       support classes that implement the -> operator and which are used
       to dispatch on another class.   I think it would be cool if
       SWIG could automatically detect and handle this case.   For example, 
       if you had this:

            class FooProxy {
               ...
               Foo *operator->();
               ...
            };

       Perhaps SWIG could automagically locate Foo and arrange for its
       methods to be associated with FooProxy.  This is really not too
       bad.   The proxy methods could be wrapped normally with only
       one minor modification in the wrapper code.   If the class Foo had
       a method "bar" it would be invoked as this, through the proxy:

            FooProxy *arg1;     // Object pointer (to proxy)
            (*arg1)->bar();  
             ^
            extra "*" added here.

       I think automatic wrapping of methods would be much nicer than
       requiring the use of a special directive.

       Note: needs testing

[DONE] Add warning message if %apply directive is used, but no typemaps
       match the requested type.

****   If a wrapper can't be generated to a function/method for some
       reason, provide a flag that prevents that function/method from
       appearing the dispatch function.

***    Rewrite declaration annotation to better unify %rename and related
       directives.  Add a selector mechanism that allows specific parse tree
       nodes to be identified.  For example:

             %feature("foo", nodetype="class") Foo { ... some code ... };

       Consider use of wildcards.   Namespace/nested scope support in
       %feature is currently weak.  It works, but is fragile.  Consider
       an implementation that is better integrated with symbol table
       management.  Continue to consolidate SWIG directives to %feature.

***    Bring Aquinas' contract/assertion checking code online.

***    Add more intelligent information related to object ownership.
       SWIG should be able to automatically strip ownership from 
       objects when they are assigned to pointer variables and structure
       members as well as stored in a container (i.e., an array of pointers).

       [ Partially finished for Tcl/Python. ]

**     Restoration of the documentation system.

**     Restoration of Objective-C support.

**     Unification of symbol tables and type system scopes.  In a sense
       they capture the same information so it is not necessary to have
       both.  The existence of two symbol management systems is mostly
       historical. 

**     Add a warning for uninstantiated templates.  For example, if a function
       using a template type, but that type hasn't been instantiated using
       %template.

*      Fix template partial specialization matching rules.   SWIG does not
       implement the proper C++ type deduction rules, but it does handle
       the most common cases.   This is likely to be hard and implementing
       it would really only be for completeness.

Build
-----
****   Upgrade libtool to a more recent version.  Might fix linking on OS-X
       but should definitely help on Cygwin.

****   Make sure there are tests for *ALL* library files in the test-suite.
       A number of files appear to be broken in SWIG-1.3.13.

***    Move the Source/Modules1.1 directory into the Modules directory and
       deprecate Modules1.1.

*      Upgrade autoconf? This will definitely help for Windows. The later the
       version the better.
 
Library
-------

****   Add more support for the C++ standard library.  std::complex and other
       core datatypes.   Refine support for STL vector.   Add more STL objects.

****   Continue to expand the set of recognized typemaps.

All language modules
--------------------
****   Convert use of char * to String *.   Suggest using Replaceall()
       instead of Replace(..., DOH_REPLACE_ANY);

Python
------

[DONE] Support for Python-2.2 style classes.

****   Ability to wrap certain classes as Python built-in types.

Perl
----

****   Rewrite runtime pointer type checking to better integrate
       shadow classes.   Creation of shadow classes should be done
       in C instead of Perl.   This will fix a number of problems
       related to typemaps and reduce the amount of Perl wrapper code.

****   Create tests for existing support for operator overloading

Tcl
---

Ruby
----

****   Investigate the new object allocation framework that has been
       implemented for Ruby 1.8 and determine what (if anything) needs
       to be changed for the wrapper code generated by SWIG. For background
       see ruby-talk messages 23358 and 38856 (and related threads).


**     In a post to the SWIG users' mailing list (June 5: "Multiple Inheritance
       and Ruby"), Brett Williams suggested a workaround for supporting
       multiple inheritance in the Ruby module. I'm quoting it here since
       the idea may be best implemented at the core level for reuse by other
       language modules that have limited support for MI:

       """
       While it makes for longer generated wrapper code, you can easily
       generate wrappers as Ruby methods on the derived class in these cases,
       i.e.:

	   class Base1;
	   class Base2;
	   class Derived : public Base1, public Base2;
	   class OtherDerived : public Base2;

       This would mean that for class Derived, the methods for Base2 would be
       generated as methods on class Derived as opposed to a superclass. For
       class OtherDerived, things work as normal, and any other derived class
       from Base2 would still work as they currently are, unless other derived
       classes also use MI. The exception and extra wrapper generation would
       only kick in with the use of multiple inheritance where the base class
       information is available to SWIG. 

       The feature could be turned on and off, and doesn't have to be default
       if necessary. 

       I was under the impression that the Tcl module, until a few releases ago,
       did all inheritance this way (generating wrappers for superclass methods
       in all derived classes). It does bloat the wrapper code, but in this case
       it would only be causing more bloat in cases where the alternative is
       no support.

       What is missing with this? Hmmmm... if Base2 implements a method that is
       overridden by Derived, then you could not get at Base2::Method() via the
       super keyword... what else am I missing? Again, the alternative is no
       support for MI at all unless you want to get fancy with mixins. I'm not
       sure how good of an idea that is or even if it is workable.
       """
       
       Another problem (which we can't really get around anyways) is that
       basic inheritance relationships wouldn't be true at the Ruby level,
       e.g. Derived#is_a?(Base1) would return true but Derived#is_a?(Base2)
       would return false.
       
**     A related suggestion from Brett Williams (and perhaps an alternative
       to the previously described workaround for MI) is to provide a
       variant of the %extend directive that allows you to pretend that these
       functions should be treated as if they were in the class definition,
       i.e.:

	   %define ADD_ART_PROP_METHODS(classname)
	   %extend classname {
	     void AddArtProperty(const String &key, const String &val);
	     String GetArtProperty(const String &key) const;
	     const PropertyVector *GetArtProperties() const;
	   };
	   %enddef

       As written, SWIG would expect you to have provided functions with
       names classname_AddArtProperty(), etc. somewhere else in the wrapper
       code. We'd prefer that it somehow knew to call the function directly.
       
*      Consider adding a switch to define everything in the global (Kernel)
       module instead of nested in a user-defined module, but only if
       it comes up.

Java
----
[done] Improved pointer handling to take advantage of Java's static type
       checking. Currently all pointers are a Java long and these could
       be changed to use a Java class wrapper.

[done] Better support for global variables and functions when using proxy 
       classes. They could be put into a global proxy class to improve on 
       current syntax:
       A a = new A(module.global_function(b.getCPtrB()), true);
       to use something like:
       A a = Globals.global_function(b);

[done] Implement function overloading.

[done] Implement replacements for the deprecation of the %pragma directive.

*      Consider using typemaps for proxy class code generation. [partially
       implemented]

PHP
---

[done] Much better class implementation in php.  Wrapped classes are 
       implemented in c++ but accessable natively as php4 classes, all
       fully subclassable in php! - including class property accessors.

[done] Much improved pointer handling and destructing by means of php 
       resources

**     When returning wrapped objects via alternate constructors if that
       pointer value already exists "out there" as a resource we should
       use the same resource, we can't have multiple ref-counted resources
       mapping to the same object in case it gets twice destroyed.  And check
       if ref count destroying is even working, see smart_pointer_rename

*      Work out how classes without even inherited constructors should
       interact with the php "new <class>" notation.
       See: abstract_inherit_wrap.cpptest

*      Work out when we can but shouldn't dispose of objects because the
       creator will

*      Get class properties to work

*      Overloading, callbacks, really review to see what else is missed

Guile
-----

**     Rename slot setters from CLASS-SLOT-set to CLASS-SLOT-set!
       to match Scheme convention for naming of mutators.

**     Support keyword args.

**     Support GOOPS shadow classes.

**     Support garbage collection.  Here is a possible design:

       -- %new annotation decides whether a pointer smob can be gc'ed.

       -- New smob type `swig-gc'; instances created with
          SWIG_Guile_MakeCollectablePtr.  %new versions of the pointer
          typemaps use this function rather than SWIG_Guile_MakePtr.

       -- New typemaps "destructor", "gcmarker".  Their values are taken
          as identifiers for functions taking one argument: a pointer to
          the object to be destroyed, or whose SCM-valued subobjects are
          to be marked.  After creating the pointer equivalence table,
          we iterate again over the remembered pointer types, emitting
          code that puts the functions into our type table.  No
          additional functions are generated.

       -- The default for all pointer types would be: 
          %typemap(destructor) SWIGPOINTER * "free";
	  (or "delete" for C++)

       -- A special annotation, e.g. FREED, can be attached to the
          arguments of destructor functions, so that explicitly freed
          structs won't be collected by the GC again. Like this:

	   %typemap(argout) SWIGPOINTER *FREED {
	     smob-tag($source) = swig; /* non-gc */
	     smob-data($source) = NULL;
	   }
	   void free_foo(struct foo *FREED);

**     Make SWIG's types first-class by using a separate smob type for
       SWIG type descriptors; enable reflection on types.

**     Maybe communicate the type system between object modules via Scheme
       variables, rather than a shared object.

Mzscheme
--------

Pike
----

*      Decide how to handle global variables (probably using something
       like the Python module's cvar). Affects Examples/pike/simple.

*      Decide how to handle static class member functions and member
       variables.

*      Should investigate the possibility of generating .cmod files
       in addition to straight C/C++ code for extensions.

Documentation
-------------

****   Extending SWIG (and internals).

***    Perl, Python, Tcl modules.

***    add section for Perl module support for operator overloading

**     Add section on WAD.

Other
-----

****   Bring Tiger's .NET/CLR module online.


