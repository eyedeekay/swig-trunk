<html>
<head>
<title>SWIG and Perl5</title>
</head>

<body bgcolor="#ffffff">
<h1>8 SWIG and Perl5</h1>

<b>Caution: This chapter is under repair!</b>

In this chapter, we discuss SWIG's support of Perl5. While the Perl5
module is one of the earliest SWIG modules, it has continued to evolve
and has been improved greatly with the help of SWIG users. For the
best results, it is recommended that SWIG be used with Perl5.003 or
later. Earlier versions are problematic and SWIG generated extensions
may not compile or run correctly.<p>

<h2> Preliminaries</h2>

In order for this section to make much sense, you will need to have
Perl5.002 (or later) installed on your system. You should also
determine if your version of Perl has been configured to use dynamic
loading or not. SWIG will work with or without it, but the compilation
process will be different.<p>

<h3> Running SWIG</h3>

To build a Perl5 module, run swig using the <tt>-perl5</tt> option as
follows :<p>

<blockquote><pre>
swig -perl5 example.i

</pre></blockquote>

This will produce 3 files. The first file, <tt>example_wrap.c</tt>
contains all of the C code needed to build a Perl5 module. The second
file, <tt>example.pm</tt> contains supporting Perl code needed to
properly load the module into Perl. The third file will be a
documentation file (the exact filename depends on the documentation
style). To finish building a module, you will need to compile the file
<tt>example_wrap.c</tt> and link it with the rest of your program (and
possibly Perl itself). There are several methods for doing this.<p>

<h3> Getting the right header files</h3>

In order to compile, you will need to use the following Perl5 header
files :<p>

<blockquote><pre>
#include "Extern.h"
#include "perl.h"
#include "XSUB.h"
</pre></blockquote>

<p>
These are usually located in a directory like this<p>

<p>
<blockquote><pre>/usr/local/lib/perl5/arch-osname/5.003/CORE
</pre></blockquote>
<p>
The SWIG configuration script will try to find this directory, but
it's not entirely foolproof. You may have to dig around yourself.<p>

<h3> Compiling a dynamic module</h3>

To compile a dynamically loadable module, you will need to do
something like the following, <p>

<blockquote><pre>
% gcc example.c
% gcc example_wrap.c -I/usr/local/lib/perl5/arch-osname/5.003/CORE 
	-Dbool=char -c
% ld -shared example.o example_wrap.o -o example.so    # Irix
</pre></blockquote>

<p>
The name of the shared object file must match the module name used in
the SWIG interface file. If you used `<tt>%module example</tt>', then
the target should be named `<tt>example.so</tt>',
`<tt>example.sl</tt>', or the appropriate name on your system (check
the man pages for the linker).<p>
<p>
Unfortunately, the process of building dynamic modules varies on every
single machine. Both the C compiler and linker may need special
command line options. SWIG tries to guess how to build dynamic modules
on your machine in order to run its example programs. Again, the
configure script isn't foolproof .<p>

<h3> Building a dynamic module with MakeMaker</h3>

It is also possible to use Perl to build dynamically loadable modules
for you using the MakeMaker utility.  To do this, write a simple Perl
script such as the following :<p>

<p>
<blockquote><pre># File : Makefile.PL
use ExtUtils::MakeMaker;
WriteMakefile(
	`NAME'    =&gt; `example',                  # Name of package
	`LIBS'    =&gt; [`-lm'],                    # Name of custom libraries
	`OBJECT'  =&gt; `example.o example_wrap.o'  # Object files
);

</pre></blockquote>

Now, to build a module, simply follow these steps :<p>

<p>
<blockquote><pre>% perl Makefile.PL
% make
% make install
</pre></blockquote>

<p>
This is the preferred approach if you building general purpose Perl5
modules for distribution.  More information about MakeMaker can be
found in "Programming Perl, 2nd ed." by Larry Wall, Tom Christiansen,
and Randal Schwartz.<p>

<h3> Building a static version of Perl</h3>

If you machine does not support dynamic loading, or if you've tried to
use it without success, you can build a new version of the Perl
interpreter with your SWIG extensions added to it. To build a static
extension, you first need to invoke SWIG as follows :<p>

<p>
<blockquote><pre>% swig -perl5 -static example.i
</pre></blockquote>
<p>
By default SWIG includes code for dynamic loading, but the
<tt>-static</tt> option takes it out.<p>

<p>
Next, you will need to supply a <tt>main()</tt> function that
initializes your extension and starts the Perl interpreter. While,
this may sound daunting, SWIG can do this for you automatically as
follows :<p>

<blockquote><pre>
%module example

extern double My_variable;
extern int fact(int);

// Include code for rebuilding Perl
%include perlmain.i
</pre></blockquote>

<p>
The same thing can be accomplished by running SWIG as follows :<p>

<p>
<blockquote><pre>% swig -perl5 -static -lperlmain.i example.i

</pre></blockquote>

The <tt>permain.i</tt> file inserts Perl's <tt>main()</tt> function
into the wrapper code and automatically initializes the SWIG generated
module. If you just want to make a quick a dirty module, this may be
the easiest way. By default, the <tt>perlmain.i</tt> code does not
initialize any other Perl extensions. If you need to use other
packages, you will need to modify it appropriately. You can do this by
just copying <tt>perlmain.i</tt> out of the SWIG library, placing it
in your own directory, and modifying it to suit your purposes.<p>

<p>
To build your new Perl executable, follow the exact same procedure as
for a dynamic module, but change the link line as follows :<p>

<blockquote><pre>
% ld example.o example_wrap.o -L/usr/local/lib/perl5/arch/5.003/CORE \
	-lperl -lsocket -lnsl -lm -o myperl
</pre></blockquote>

<p>
This will produce a new version of Perl called <tt>myperl</tt>. It
should be functionality identical to Perl with your C/C++ extension
added to it.  Depending on your machine, you may need to link with
additional libraries such as <tt>-lsocket, -lnsl, -ldl</tt>, etc...<p>

<h3> Compilation problems and compiling with C++</h3>

In some cases, you may get alot of error messages about the
`<tt>bool</tt>' datatype when compiling a SWIG module. If you
experience this problem, you can try the following :<p>

<p>
<ul>
<li>Use <tt>-DHAS_BOOL</tt> when compiling the SWIG wrapper code
<li>Or use <tt>-Dbool=char</tt> when compiling.
</ul>

<p>
Compiling dynamic modules for C++ is also a tricky business.  When
compiling C++ modules, you may need to link using the C++ compiler
such as :<p>

<blockquote><pre>
unix &gt; c++ -shared example_wrap.o example.o -o example.so
</pre></blockquote>
<p>
It may also be necessary to link against the <tt>libgcc.a</tt>,
<tt>libg++.a</tt>, and <tt>libstdc++.a</tt> libraries (assuming
g++). C++ may also complain about one line in the Perl header file
"<tt>perl.h</tt>" and the invalid use of the "explicit" keyword. To
work around this problem, put the option <tt>-Dexplicit=</tt> in your
compiler flags.<p>

<p>
If all else fails, put on your wizard cap and start looking around in
the header files.  Once you've figured out how to get one module to
compile, you can compile just about all other modules.<p>

<h2> Building Perl Extensions under Windows 95/NT</h2>

Building a SWIG extension to Perl under Windows 95/NT is roughly
similar to the process used with Unix.  Normally, you will want to
produce a DLL that can be loaded into the Perl interpreter.  This
section assumes you are using SWIG with Microsoft Visual C++ 4.x
although the procedure may be similar with other compilers.  SWIG
currently supports the ActiveWare Perl for Win32 port and Perl 5.004.
If using the ActiveWare version, all Perl extensions must be compiled
using C++!<p>

<h3> Running SWIG from Developer Studio</h3>

If you are developing your application within Microsoft developer
studio, SWIG can be invoked as a custom build option.  The process
roughly requires these steps :<p>

<p>
<ul>
<li>Open up a new workspace and use the AppWizard to select a DLL
project.

<li>Add both the SWIG interface file (the .i file), any supporting C
files, and the name of the wrapper file that will be created by SWIG
(ie. <tt>example_wrap.c</tt>).  Note : If using C++, choose a
different suffix for the wrapper file such as
<tt>example_wrap.cxx</tt>. Don't worry if the wrapper file doesn't
exist yet--Developer studio will keep a reference to it around.

<li>Select the SWIG interface file and go to the settings menu.  Under
settings, select the "Custom Build" option.

<li>Enter "SWIG" in the description field.

<li>Enter "<tt>swig -perl5 -o $(ProjDir)\$(InputName)_wrap.cxx
$(InputPath)</tt>" in the "Build command(s) field"

<li>Enter "<tt>$(ProjDir)\$(InputName)_wrap.c</tt>xx" in the "Output
files(s) field".

<li>Next, select the settings for the entire project and go to
"C++:Preprocessor". Add the include directories for your Perl 5
installation under "Additional include directories".

<li>Define the symbols WIN32 and MSWIN32 under preprocessor options.
If using the ActiveWare port, also define the symbol PERL_OBJECT.
Note that all extensions to the ActiveWare port must be compiled with
the C++ compiler since Perl has been encapsulated in a C++ class.

<li>Finally, select the settings for the entire project and go to
"Link Options".  Add the Perl library file to your link libraries.
For example "perl.lib".  Also, set the name of the output file to
match the name of your Perl module (ie. example.dll).

<li>Build your project.
</ul>
<p>
Now, assuming all went well, SWIG will be automatically invoked when
you build your project.  Any changes made to the interface file will
result in SWIG being automatically invoked to produce a new version of
the wrapper file.  To run your new Perl extension, simply run Perl and
use the use command as normal. For example :<p>
<p>
<blockquote><pre>
DOS &gt; perl
use example;
$a = example::fact(4);
print "$a\n";

</pre></blockquote>
It appears that DLL's will work if they are placed in the current
working directory.  To make a generally DLL available, it should be
place (along with its support files) in the <tt>Lib\Auto\[module]
</tt>sub-directory of the Perl directory where [module] is the name of
your module.<p>

<h3> Using NMAKE</h3>

Alternatively, SWIG extensions can be built by writing a Makefile for
NMAKE.  To do this, make sure the environment variables for MSVC++ are
available and the MSVC++ tools are in your path.  Now, just write a
short Makefile like this :<p>
<p>
<blockquote><pre># Makefile for building an ActiveWare Perl for Win32 extension
# Note : Extensions must be compiled with the C++ compiler!

SRCS          = example.cxx
IFILE         = example
INTERFACE     = $(IFILE).i
WRAPFILE      = $(IFILE)_wrap.cxx

# Location of the Visual C++ tools (32 bit assumed)

TOOLS         = c:\msdev
TARGET        = example.dll
CC            = $(TOOLS)\bin\cl.exe
LINK          = $(TOOLS)\bin\link.exe
INCLUDE32     = -I$(TOOLS)\include
MACHINE       = IX86

# C Library needed to build a DLL

DLLIBC        = msvcrt.lib oldnames.lib  

# Windows libraries that are apparently needed
WINLIB        = kernel32.lib advapi32.lib user32.lib gdi32.lib comdlg32.lib 
winspool.lib

# Libraries common to all DLLs
LIBS          = $(DLLIBC) $(WINLIB) 

# Linker options
LOPT      = -debug:full -debugtype:cv /NODEFAULTLIB /RELEASE /NOLOGO /
MACHINE:$(MACHINE) -entry:_DllMainCRTStartup@12 -dll

# C compiler flags

CFLAGS        = /Z7 /Od /c /W3 /nologo

# Perl 5.004
PERL_INCLUDE = -Id:\perl5\lib\CORE
PERLLIB      = d:\perl5\lib\CORE\perl.lib
PERLFLAGS    = /DWIN32 /DMSWIN32 /DWIN32IO_IS_STDIO

# ActiveWare
PERL_INCLUDE  = -Id:\perl -Id:\perl\inc 
PERL_LIB        = d:\perl\Release\perl300.lib
PERLFLAGS = /DWIN32 /DMSWIN32 /DPERL_OBJECT

perl::
	..\..\swig -perl5 -o $(WRAPFILE) $(INTERFACE)
	$(CC) $(CFLAGS) $(PERLFLAGS) $(PERL_INCLUDE) $(SRCS) $(WRAPFILE)
	set LIB=$(TOOLS)\lib
	$(LINK) $(LOPT) -out:example.dll $(LIBS) $(PERLLIB) example.obj 
example_wrap.obj
</pre></blockquote>

<p>
To build the extension, run NMAKE (note that you may be to run
<tt>vcvars32</tt> before doing this to set the correct environment
variables). This is a simplistic Makefile, but hopefully its enough to
get you started.  <p>

<h2> Modules, packages, and classes</h2>

When you create a SWIG extension, everything gets thrown together into
a single Perl5 module. The name of the module is determined by the
<tt>%module</tt> directive. To use the module, do the following :<p>

<p>
<blockquote><pre>% perl5
use example;                      # load the example module
print example::fact(4),"\n"       # Call a function in it
24
</pre></blockquote>

<p>
Usually, a module consists of a collection of code that is contained
within a single file. A package, on the other hand, is the Perl
equivalent of a namespace. A package is alot like a module, except
that it is independent of files. Any number of files may be part of
the same package--or a package may be broken up into a collection of
modules if you prefer to think about it in this way.<p>

<p>
By default, SWIG installs its functions into a package with the same
name as the module. This can be changed by giving SWIG the -package
option :<p>

<p>
<blockquote><pre>% swig -perl5 -package FooBar example.i
</pre></blockquote>

<p>
In this case, we still create a module called `<tt>example</tt>', but
all of the functions in that module will be installed into the package
`<tt>FooBar</tt>.' For example :<p>
<p>
<blockquote><pre>use example;                       # Load the module like before
print FooBar::fact(4),"\n";        # Call a function in package FooBar
</pre></blockquote>
<p>
Perl supports object oriented programming using packages. A package
can be thought of as a namespace for a class containing methods and
data. The reader is well advised to consult "Programming Perl, 2nd
Ed." by Wall, Christiansen, and Schwartz for most of the gory
details. <p>

<h2> Basic Perl interface</h2>

<h3> Functions</h3>
C functions are converted into new Perl commands (or
subroutines). Default/optional arguments are also allowed.  An
interface file like this :<p>

<p>
<blockquote><pre>%module example
int foo(int a);
double bar (double, double b = 3.0);
...

</pre></blockquote>
Will be used in Perl like this :<p>
<p>
<blockquote><pre>use example;
$a = &amp;example::foo(2);
$b = &amp;example::bar(3.5,-1.5);
$c = &amp;example::bar(3.5);            # Use default argument for 2nd parameter

</pre></blockquote>

Okay, this is pretty straightforward...enough said.<p>

<h3> Global variables</h3>

Global variables are handled using pure magic--well, Perl's magic
variable mechanism that is.  In a nutshell, it is possible to make
certain Perl variables "magical" by attaching methods for getting and
setting values among other things.  SWIG generates a pair of functions
for accessing C global variables and attaches them to a Perl variable
of the same name.  Thus, an interface like this <p>

<p>
<blockquote><pre>%module example;
...
double Spam;
...

</pre></blockquote>
is accessed as follows :<p>

<p>
<blockquote><pre>use example;
print $example::Spam,"\n";
$example::Spam = $example::Spam + 4
# ... etc ...

</pre></blockquote>
SWIG supports global variables of all C datatypes including pointers
and complex objects.<p>

<h3> Constants</h3>

Constants are created as read-only magical variables and operate in
exactly the same manner.<p>

<h3> Pointers</h3>

SWIG represents pointers as blessed references.  A blessed reference
is the same as a Perl reference except that it has additional
information attached to it indicating what kind of reference it
is. That is, if you have a C declaration like this :<p>

<p>
<blockquote><pre>Matrix *new_Matrix(int n, int m);
</pre></blockquote>

<p>
SWIG will return a value as if you had done this :<p>

<blockquote><pre>
$ptr = new_Matrix(int n, int m);     # Save pointer return result
bless $ptr, "MatrixPtr";             # Bless it as a MatrixPtr
</pre></blockquote>

<p>
SWIG uses the "blessing" to check the datatype of various pointers.
In the event of a mismatch, an error or warning message will be
generated.<p>

<p>
To check to see if a value is the NULL pointer, use the
<tt>defined()</tt> command :<p>

<blockquote><pre>
if (defined($ptr)) {
	print "Not a NULL pointer.";
} else {
	print "Is a NULL pointer.";
}

</pre></blockquote>

To create a NULL pointer, you should pass the <tt>undef </tt>value to
a function.  <p>

<p>
The "value" of a Perl reference is not the same as the underlying C
pointer that SWIG wrapper functions return.  Suppose that <tt>$a</tt>
and <tt>$b</tt> are two references that point to the same C object.
In general, <tt>$a</tt> and <tt>$b</tt> will be different--since they
are different references.  Thus, it is a mistake to check the equality
of <tt>$a </tt>and <tt>$b</tt> to check the equality of two C
pointers.  The correct method to check equality of C pointers is to
dereference them as follows :<p>

<p>
<blockquote><pre>if ($$a == $$b) {
	print "a and b point to the same thing in C";
} else {
	print "a and b point to different objects.";
}

</pre></blockquote>

It is easy to get burned by references in more subtle ways.  For
example, if you are storing a hash table of objects, it may be best to
use the actual C pointer value rather than the Perl reference as a
key.  Since each Perl reference to the same C object may be different,
it would be impossible to find anything in the hash without this. As a
general rule, the best way to avoid problems with references is to
make sure hash tables, comparisons, and other pointer operations use
the value of the reference (ie. <tt>$$a</tt>), not the reference
itself.<p>

<h3> Structures and C++ classes</h3>

For structures and classes, SWIG produces a set of accessor functions
for member functions and member data.  For example :<p>

<p>
<blockquote><pre>%module vector

class Vector {
public:
	double x,y,z;
	Vector();
	~Vector();
	double magnitude();
};

</pre></blockquote>

This gets turned into the following collection of Perl functions :<p>

<blockquote><pre>vector::Vector_x_get($obj);
vector::Vector_x_set($obj,$x);
vector::Vector_y_get($obj);
vector::Vector_y_set($obj,$y);
vector::Vector_z_get($obj);
vector::Vector_z_set($obj,$z);
vector::new_Vector();
vector::delete_Vector($obj);
vector::Vector_magnitude($obj);

</pre></blockquote>
To use the class, simply use these functions.  As it turns out, SWIG
has a mechanism for creating shadow classes that hides these functions
and uses an object oriented interface instead--keep reading.<p>

<h2>Examples</h2>

Write me.

<h2> Exception handling </h2>

The SWIG <tt>%except</tt> directive can be used to create a
user-definable exception handler for converting exceptions in your
C/C++ program into Perl exceptions.  The chapter on exception handling
contains more details, but suppose you have a C++ class like the
following :<p>

<blockquote><pre>
class RangeError {};   // Used for an exception

class DoubleArray {
  private:
    int n;
    double *ptr;
  public:
    // Create a new array of fixed size
    DoubleArray(int size) {
      ptr = new double[size];
      n = size;
    }
    // Destroy an array
    ~DoubleArray() {
       delete ptr;
    }
    // Return the length of the array
    int   length() {
      return n;
    }

    // Get an item from the array and perform bounds checking.
    double getitem(int i) {
      if ((i &gt;= 0) &amp;&amp; (i &lt; n))
        return ptr[i];
      else
        throw RangeError();
    }

    // Set an item in the array and perform bounds checking.
    void setitem(int i, double val) {
      if ((i &gt;= 0) &amp;&amp; (i &lt; n))
        ptr[i] = val;
      else {
        throw RangeError();
      }
    }
  };
</pre></blockquote>

<p>
The functions associated with this class can throw a range exception
for an out-of-bounds array access.  We can catch this in our Perl
extension by specifying the following in an interface file :<p>

<p>
<blockquote><pre>%except(perl5) {
  try {
    $function                // Gets substituted by actual function call
  }
  catch (RangeError) {
    croak("Array index out-of-bounds");
  }
}

</pre></blockquote>

Now, when the C++ class throws a RangeError exception, our wrapper
functions will catch it, turn it into a Perl exception, and allow a
graceful death as opposed to just having some sort of mysterious
program crash.  Since SWIG's exception handling is user-definable, we
are not limited to C++ exception handling.  It is also possible to
write a language-independent exception handler that works with other
scripting languages. Please see the chapter on exception handling for
more details.<p>

<h2> Remapping datatypes with typemaps</h2>

While SWIG does a reasonable job with most C/C++ datatypes, it doesn't
always do what you want.  However, you can remap SWIG's treatment of
just about any datatype using a typemap.  A typemap simply specifies a
conversion between Perl and C datatypes and can be used to process
function arguments, function return values, and more.  A similiar
mechanism is used by the xsubpp compiler provided with Perl although
the SWIG version provides many more options.<p>

<h3> A simple typemap example</h3>

The following example shows how a simple typemap can be written :<p>
<p>
<blockquote><pre>%module example

%typemap(perl5,in) int {
	$target = (int) SvIV($source);
	printf("Received an integer : %d\n", $target);
}
...
extern int fact(int n);

</pre></blockquote>

Typemap specifications require a language name, method name, datatype,
and conversion code. For Perl5, "perl5" should be used as the language
name.  The "in" method refers to the input arguments of a function.
The `int' datatype tells SWIG that we are remapping integers.  The
conversion code is used to convert from a Perl scalar value to the
corresponding datatype.  Within the support code, the variable<tt>
$source</tt> contains the source data (a Perl object) and
<tt>$target</tt> contains the destination of the conversion (a C local
variable). <p>

<p>
When this example is used in Perl5, it will operate as follows :<p>

<p>
<blockquote><pre>use example;
$n = example::fact(6);
print "$n\n";
...

Output :
Received an integer : 6
720
</pre></blockquote>

<p>
General discussion of typemaps can be found in the main SWIG users
reference.  <p>

<h3> Perl5 typemaps</h3>

The following typemap methods are available to Perl5 modules<p>
<p>
<tt>%typemap(perl5,in)</tt>                        Converts Perl5 object to input function arguments.<p>
<tt>%typemap(perl5,out)</tt>                     Converts function return value to a Perl5 value.<p>
<tt>%typemap(perl5,varin)</tt>                Converts a Perl5 object to a global variable.<p>
<tt>%typemap(perl5,varout)</tt>             Converts a global variable to a Perl5 object.<p>
<tt>%typemap(perl5,freearg)</tt>          Cleans up a function argument after a function call<p>
<tt>%typemap(perl5,argout)</tt>             Output argument handling<p>
<tt>%typemap(perl5,ret)        </tt>Clean up return value from a function.<p>
<tt>%typemap(memberin)</tt>                        Setting of C++ member data (all languages).<p>
<tt>%typemap(memberout)</tt>                     Return of C++ member data (all languages).<p>
<tt>%typemap(perl5,check)</tt>               Check value of input parameter.<p>

<h3> Typemap variables</h3>

The following variables may be used within the C code used in a typemap :<p>
<p>
<tt>$source</tt>                                                     Source value of a conversion<p>
<tt>$target</tt>                                                     Target of conversion (where result should be stored)<p>
<tt>$type</tt>                                                           C datatype being remapped<p>
<tt>$mangle</tt>                                                     Mangled version of datatype (for blessing objects)<p>
<tt>$arg</tt>                                                             Function argument (when applicable).<p>

<h3> Name based type conversion</h3>

Typemaps are based both on the datatype and an optional name attached
to a datatype.  For example :<p>

<p>
<blockquote><pre>%module foo

// This typemap will be applied to all char ** function arguments
%typemap(perl5,in) char ** { ... }

// This typemap is applied only to char ** arguments named `argv'
%typemap(perl5,in) char **argv { ... }

</pre></blockquote>

In this example, two typemaps are applied to the char ** datatype.
However, the second typemap will only be applied to arguments named
`argv'.  A named typemap will always override an unnamed typemap.<p>

<p>
Due to the name matching scheme, typemaps do not follow typedef
declarations.  For example :<p>

<p>
<blockquote><pre>%typemap(perl5,in) double {
	... get a double ...
}

double foo(double);              // Uses the double typemap above
typedef double Real;
Real bar(Real);                  // Does not use the typemap above (double != Real)

</pre></blockquote>

Is is odd behavior to be sure, but you can work around the problem
using the <tt>%apply</tt> directive as follows :<p>

<p>
<blockquote><pre>%typemap(perl5,in) double {
	... get a double ...
}
double foo(double);              // Uses the double typemap above

typedef double Real;
%apply double { Real };          // Apply the double typemap to Reals.
Real bar(Real);                  // Uses the double typemap already defined.
</pre></blockquote>
<p>
Named typemaps are extremely useful for managing special cases.  It is
also possible to use named typemaps to process output arguments
(ie. function arguments that have values returned in them).<p>

<h3> Converting a Perl5 array to a char ** </h3>

A common problem in many C programs is the processing of command line
arguments, which are usually passed in an array of NULL terminated
strings.  The following SWIG interface file allows a Perl5 array
reference to be used as a char ** datatype.<p>

<p>
<blockquote><pre>%module argv

// This tells SWIG to treat char ** as a special case
%typemap(perl5,in) char ** {
	AV *tempav;
	I32 len;
	int i;
	SV  **tv;
	if (!SvROK($source))
	    croak("$source is not a reference.");
        if (SvTYPE(SvRV($source)) != SVt_PVAV)
	    croak("$source is not an array.");
       tempav = (AV*)SvRV($source);
	len = av_len(tempav);
	$target = (char **) malloc((len+2)*sizeof(char *));
	for (i = 0; i &lt;= len; i++) {
	    tv = av_fetch(tempav, i, 0);	
	    $target[i] = (char *) SvPV(*tv,na);
        }
	$target[i] = 0;
};

// This cleans up our char ** array after the function call
%typemap(perl5,freearg) char ** {
	free($source);
}

// Creates a new Perl array and places a char ** into it
%typemap(perl5,out) char ** {
	AV *myav;
	SV **svs;
	int i = 0,len = 0;
	/* Figure out how many elements we have */
	while ($source[len])
	   len++;
	svs = (SV **) malloc(len*sizeof(SV *));
	for (i = 0; i &lt; len ; i++) {
	    svs[i] = sv_newmortal();
	    sv_setpv((SV*)svs[i],$source[i]);
	};
	myav =	av_make(len,svs);
	free(svs);
       $target = newRV((SV*)myav);
       sv_2mortal($target);
}

// Now a few test functions
%inline %{
int print_args(char **argv) {
    int i = 0;
    while (argv[i]) {
         printf("argv[%d] = %s\n", i,argv[i]);
         i++;
    }
    return i;
}

// Returns a char ** list 
char **get_args() {
    static char *values[] = { "Dave", "Mike", "Susan", "John", "Michelle", 0};
    return &amp;values[0];
}
%}

</pre></blockquote>

When this module is compiled, our wrapped C functions can be used in a
Perl script as follows :<p>

<blockquote><pre>
use argv;
@a = ("Dave", "Mike", "John", "Mary");           # Create an array of strings
argv::print_args(\@a);                           # Pass it to our C function
$b = argv::get_args();                           # Get array of strings from C
print @$b,"\n";                                  # Print it out
</pre></blockquote>

<p>
Of course, there are many other possibilities.  As an alternative to
array references, we could pass in strings separated by some delimeter
and perform a splitting operation in C. <p>

<h3> Using typemaps to return values</h3>

Sometimes it is desirable for a function to return a value in one of
its arguments. A named typemap can be used to handle this case.  For
example :<p>

<p>
<blockquote><pre>%module return

// This tells SWIG to treat an double * argument with name 'OutDouble' as
// an output value.  

%typemap(perl5,argout) double *OutDouble {
	$target = sv_newmortal();
	sv_setnv($target, *$source);
	argvi++;                     /* Increment return count -- important! */
}

// If we don't care what the input value is, we can make the typemap ignore it.

%typemap(perl5,ignore) double *OutDouble(double junk) {
	$target = &amp;junk;       /* junk is a local variable that has been declared */
}

// Now a function to test it
%{
/* Returns the first two input arguments */
int multout(double a, double b, double *out1, double *out2) {
	*out1 = a;
	*out2 = b;
	return 0;
};
%}

// If we name both parameters OutDouble both will be output

int multout(double a, double b, double *OutDouble, double *OutDouble);
...
</pre></blockquote>

<p>
When output arguments are encountered, they are simply appended to the
stack used to return results.  This will show up as an array when used
in Perl.  For example :<p>

<p>
<blockquote><pre>@r = multout(7,13);
print "multout(7,13) = @r\n";

</pre></blockquote>

<h3> Accessing array structure members</h3>

Consider the following data structure :<p>
<p>
<blockquote><pre>#define NAMELEN   32
typedef struct {
	char   name[NAMELEN];
	...
} Person;

</pre></blockquote>

By default, SWIG doesn't know how to the handle the name structure
since it's an array, not a pointer.  In this case, SWIG will make the
array member readonly.  However, member typemaps can be used to make
this member writable from Perl as follows :<p>

<p>
<blockquote><pre>%typemap(memberin) char[NAMELEN] {
	/* Copy at most NAMELEN characters into $target */
	strncpy($target,$source,NAMELEN);
}

</pre></blockquote>

Whenever a <tt>char[NAMELEN]</tt> type is encountered in a structure
or class, this typemap provides a safe mechanism for setting its
value.  An alternative implementation might choose to print an error
message if the name was too long to fit into the field.<p>

<p>
It should be noted that the <tt>[NAMELEN]</tt> array size is attached
to the typemap. A datatype involving some other kind of array would be
affected.  However, we can write a typemap that will work for any
array dimension as follows :<p>

<blockquote><pre>
%typemap(memberin) char [ANY] {
	strncpy($target,$source,$1_dim0);
}

</pre></blockquote>

When code is generated, <tt>$1_dim0</tt> gets filled in with the real
array dimension.<p>

<h3> Turning Perl references into C pointers</h3>

A frequent confusion on the SWIG mailing list is errors caused by the
mixing of Perl references and C pointers.  For example, suppose you
have a C function that modifies its arguments like this :<p>

<p>
<blockquote><pre>void add(double a, double b, double *c) {
	*c = a + b;
}

</pre></blockquote>

A common misinterpretation of this function is the following Perl script :<p>

<p>
<blockquote><pre># Perl script
$a = 3.5;
$b = 7.5;
$c = 0.0;          # Output value
add($a,$b,\$c);    # Place result in c (Except that it doesn't work)
</pre></blockquote>

<p>
Unfortunately, this does NOT work.  There are many reasons for this,
but the main one is that SWIG has no idea what a <tt>double *</tt>
really is.  It could be an input value, an output value, or an array
of 2 million elements.  As a result, SWIG leaves it alone and looks
exclusively for a C pointer value (which is not the same as a Perl
reference--well, at least note of the type used in the above
script).<p>

<p>
However, you can use a typemap to get the desired effect. For example
:<p>

<p>
<blockquote><pre>%typemap(perl5,in) double * (double dvalue) {
  SV* tempsv;
  if (!SvROK($source)) {
    croak("expected a reference\n");
  }
  tempsv = SvRV($source);
  if ((!SvNOK(tempsv)) &amp;&amp; (!SvIOK(tempsv))) {
    croak("expected a double reference\n");
  }
  dvalue = SvNV(tempsv);
  $target = &amp;dvalue;
}

%typemap(perl5,argout) double * {
  SV *tempsv;
  tempsv = SvRV($arg);
  sv_setnv(tempsv, *$source);
}
</pre></blockquote>
<p>
Now, if you place this before our add function, we can do this :<p>
<p>
<blockquote><pre>$a = 3.5;
$b = 7.5;
$c = 0.0;
add($a,$b,\$c);            # Now it works!
print "$c\n";

</pre></blockquote>

You'll get the output value of "11.0" which is exactly what we wanted.
While this is pretty cool, it should be stressed that you can easily
shoot yourself in the foot with typemaps--of course SWIG is has never
been too concerned about legislating morality....<p>

<h3> Useful functions</h3>

When writing typemaps, it is necessary to work directly with Perl5
objects.  This, unfortunately, can be a daunting task.  Consult the
"perlguts" man-page for all of the really ugly details.  A short
summary of commonly used functions is provided here for reference.  It
should be stressed that SWIG can be usef quite effectively without
knowing any of these details--especially now that there are typemap
libraries that can already been written.<p>

<p>
<b>Perl Integer Functions</b>

<blockquote>
<pre>
int   SvIV(SV *);
void  sv_setiv(SV *sv, IV value);
SV   *newSViv(IV value);
int   SvIOK(SV *);
</pre>
</blockquote>

<b>Perl Floating Point Functions</b>

<blockquote>
<pre>
double SvNV(SV *);
void   sv_setnv(SV *, double value);
SV    *newSVnv(double value);
int    SvNOK(SV *);
</pre>
</blockquote>

<b>Perl String Functions</b>

<blockquote>
<pre>
char     *SvPV(SV *, int len);
void      sv_setpv(SV *, char *val);
void      sv_setpvn(SV *, char *val, int len);
SV       *newSVpv(char *value, int len);
int       SvPOK(SV *);
void      sv_catpv(SV *, char *);
void      sv_catpvn(SV *, char *, int);
</pre>
</blockquote>

<b>Perl References</b>

<blockquote>
<pre>
void      sv_setref_pv(SV *, char *, void *ptr);
int       sv_isobject(SV *);
SV       *SvRV(SV *);
int       sv_isa(SV *, char *0;
</pre>
</blockquote>

<h3> Standard typemaps</h3>

The following typemaps show how to convert a few common types of
objects between Perl and C (and to give a better idea of how
everything works). <p>

<p>
(rewrite)

<h3> Pointer handling</h3>

SWIG pointers are represented as blessed references.  The following
functions can be used to create and read pointer values.<p>

<p>
(rewrite)

<h3> Return values </h3>

Return values are placed on the argument stack of each wrapper
function.  The current value of the argument stack pointer is
contained in a variable <tt>argvi</tt>.  Whenever a new output value
is added, it is critical that this value be incremented.  For multiple
output values, the final value of <tt>argvi</tt> should be the total
number of output values. <p>

<p>
The total number of return values should not exceed the number of
input values unless you explicitly extend the argument stack.  This
can be done using the <tt>EXTEND()</tt> macro as in :<p>

<p>
<blockquote><pre>%typemap(perl5,argout) int *OUTPUT {
	if (argvi &gt;= items) {            
		EXTEND(sp,1);              /* Extend the stack by 1 object */
	}
	$target = sv_newmortal();
	sv_setiv($target,(IV) *($source));
	argvi++;
}
</pre></blockquote>

<h2> The gory details on shadow classes</h2>

Perl5 shadow classes are constructed on top of the low-level C
interface provided by SWIG.  By implementing the classes in Perl
instead of C, we get a number of advantages :<p>
<p>
<ul>
<li>The classes are easier to implement (after all Perl makes lots of
things easier).

<li>By writing in Perl, the classes tend to interact better with other
Perl objects and programs.

<li>You can modify the resulting Perl code without recompiling the C
module.

</ul>

<p>
Shadow classes are new in SWIG 1.1 and still somewhat experimental.
The current implementation is a combination of contributions provided
by Gary Holt and David Fletcher--many thanks!<p>

<h3>  Module and package names</h3>

When shadow classing is enabled, SWIG generates a low-level package
named `modulec' where `module' is the name of the module you provided
with the <tt>%module</tt> directive (SWIG appends a `c' to the name to
indicate that it is the low-level C bindings).  This low-level package
is exactly the same module that SWIG would have created without the
<tt>`-shadow</tt>' option, only renamed.<p>
<p>
Using the low-level interface, SWIG creates Perl wrappers around
classes, structs, and functions.  This collection of wrappers becomes
the Perl module that you will use in your Perl code, not the low-level
package (the original package is hidden, but working behind the
scenes).<p>

<h3> What gets created?</h3>

Suppose you have the following SWIG interface file :<p>

<p>
<blockquote><pre>%module vector
struct Vector {
	Vector(double x, double y, double z);
	~Vector();
	double x,y,z;
};

</pre></blockquote>

When wrapped, SWIG creates the following set of low-level accessor
functions.<p>

<p>
<blockquote><pre>Vector *new_Vector(double x, double y, double z);
void    delete_Vector(Vector *v);
double  Vector_x_get(Vector *v);
double  Vector_x_set(Vector *v, double value);
double  Vector_y_get(Vector *v);
double  Vector_y_set(Vector *v, double value);
double  Vector_z_get(Vector *v);
double  Vector_z_set(Vector *v, double value);

</pre></blockquote>

These functions can now be used to create a Perl shadow class that
looks like this :<p>

<p>
<blockquote><pre>package Vector;
@ISA = qw( vector );
%OWNER = ();
%BLESSEDMEMBERS = ();

sub new () {
    my $self = shift;
    my @args = @_;
    $self = vectorc::new_Vector(@args);
    return undef if (!defined($self));
    bless $self, "Vector";
    $OWNER{$self} = 1;
    my %retval;
    tie %retval, "Vector", $self;
    return bless \%retval,"Vector";
}

sub DESTROY {
    my $self = shift; 
    if (exists $OWNER{$self}) {
	 delete_Vector($self));
	 delete $OWNER{$self};
}

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "vectorc::Vector_${field}_get";
    my $val = &amp;$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "vectorc::Vector_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &amp;$member_func($self,tied(%{$newval}));
    } else {
        &amp;$member_func($self,$newval);
    }
}
</pre></blockquote>

<p>
Each structure or class is mapped into a Perl package of the same
name. The C++ constructors and destructors are mapped into
constructors and destructors for the package and are always named
"new" and "DESTROY".  The constructor always returns a tied hash
table.  This hash table is used to access the member variables of a
structure in addition to being able to invoke member functions.  The
<tt>%OWNER</tt> and <tt>%BLESSEDMEMBERS</tt> hash tables are used
internally and described shortly. <p>

<p>
To use our new shadow class we can simply do the following:<p>
<p>
<blockquote><pre># Perl code using Vector class
$v = new Vector(2,3,4);
$w = Vector-&gt;new(-1,-2,-3);

# Assignment of a single member
$v-&gt;{x} = 7.5;

# Assignment of all members
%$v = ( x=&gt;3,
	 y=&gt;9,
	 z=&gt;-2);

# Reading members
$x = $v-&gt;{x};

# Destruction
$v-&gt;DESTROY();

</pre></blockquote>

<h3> Object Ownership</h3>

In order for shadow classes to work properly, it is necessary for Perl
to manage some mechanism of object ownership.  Here's the crux of the
problem---suppose you had a function like this :<p>
<p>
<blockquote><pre>Vector *Vector_get(Vector *v, int index) {
	return &amp;v[i];
}

</pre></blockquote>
This function takes a Vector pointer and returns a pointer to another
Vector.  Such a function might be used to manage arrays or lists of
vectors (in C).  Now contrast this function with the constructor for a
Vector object :<p>

<p>
<blockquote><pre>Vector *new_Vector(double x, double y, double z) {
	Vector *v;
	v = new Vector(x,y,z);        // Call C++ constructor
	return v;
}

</pre></blockquote>
Both functions return a Vector, but the constructor is returning a
brand-new Vector while the other function is returning a Vector that
was already created (hopefully).  In Perl, both vectors will be
indistinguishable---clearly a problem considering that we would
probably like the newly created Vector to be destroyed when we are
done with it.<p>

<p>
To manage these problems, each class contains two methods that access
an internal hash table called <tt>%OWNER</tt>.  This hash keeps a list
of all of the objects that Perl knows that it has created.  This
happens in two cases: (1) when the constructor has been called, and
(2) when a function implicitly creates a new object (as is done when
SWIG needs to return a complex datatype by value).  When the
destructor is invoked, the Perl shadow class module checks the
<tt>%OWNER</tt> hash to see if Perl created the object.  If so, the
C/C++ destructor is invoked.  If not, we simply destroy the Perl
object and leave the underlying C object alone (under the assumption
that someone else must have created it).<p>

<p>
This scheme works remarkably well in practice but it isn't foolproof.
In fact, it will fail if you create a new C object in Perl, pass it on
to a C function that remembers the object, and then destroy the
corresponding Perl object (this situation turns out to come up
frequently when constructing objects like linked lists and trees).
When C takes possession of an object, you can change Perl's owership
by simply deleting the object from the <tt>%OWNER</tt> hash.  This is
done using the <tt>DISOWN </tt>method.<p>

<p>
<blockquote><pre># Perl code to change ownership of an object
$v = new Vector(x,y,z);
$v-&gt;DISOWN();     
</pre></blockquote>
<p>
To acquire ownership of an object, the <tt>ACQUIRE</tt> method can be used.<p>
<p>
<blockquote><pre># Given Perl ownership of a file
$u = Vector_get($v);
$u-&gt;ACQUIRE();

</pre></blockquote>

As always, a little care is in order.  SWIG does not provide reference
counting, garbage collection, or advanced features one might find in
sophisticated languages.<p>

<h3> Nested Objects</h3>

Suppose that we have a new object that looks like this :<p>
<p>
<blockquote><pre>struct Particle {
	Vector r;
	Vector v;
	Vector f;
	int	type;
}

</pre></blockquote>
In this case, the members of the structure are complex objects that
have already been encapsulated in a Perl shadow class.  To handle
these correctly, we use the <tt>%BLESSEDMEMBERS</tt> hash which would
look like this (along with some supporting code) :<p>

<p>
<blockquote><pre>package Particle;
...
%BLESSEDMEMBERS = (
	r =&gt; `Vector',
	v =&gt; `Vector',
	f =&gt; `Vector',
);

</pre></blockquote>

When fetching members from the structure, <tt>%BLESSEDMEMBERS</tt> is
checked.  If the requested field is present, we create a tied-hash
table and return it.  If not, we just return the corresponding member
unmodified.<p>

<p>
This implementation allows us to operate on nested structures as follows :<p>
<blockquote><pre>
# Perl access of nested structure
$p = new Particle();
$p-&gt;{f}-&gt;{x} = 0.0;
%${$p-&gt;{v}} = ( x=&gt;0, y=&gt;0, z=&gt;0);         
</pre></blockquote>
<p>
<h3> Shadow Functions</h3>

When functions take arguments involving a complex object, it is
sometimes necessary to write a shadow function.  For example :<p>

<p>
<blockquote><pre>double dot_product(Vector *v1, Vector *v2);

</pre></blockquote>

Since Vector is an object already wrapped into a shadow class, we need
to modify this function to accept arguments that are given in the form
of tied hash tables.  This is done by creating a Perl function like
this :<p>

<p>
<blockquote><pre>sub dot_product {
    my @args = @_;
    $args[0] = tied(%{$args[0]});         # Get the real pointer values
    $args[1] = tied(%{$args[1]});
    my $result = vectorc::dot_product(@args);
    return $result;
}
</pre></blockquote>

<p>
This function replaces the original function, but operates in an
identical manner.<p>

<h3>  Inheritance</h3>

Simple C++ inheritance is handled using the Perl <tt>@ISA</tt> array
in each class package. For example, if you have the following
interface file :<p>

<p>
<blockquote><pre>// shapes.i
// SWIG interface file for shapes class
%module shapes
%{
#include "shapes.h"
%}

class Shape {
public:
	virtual double area() = 0;
	virtual double perimeter() = 0;
	void    set_location(double x, double y);
};
class Circle : public Shape {
public:
	Circle(double radius);
	~Circle();
	double area();
	double perimeter();
};
class Square : public Shape {
public:
	Square(double size);
	~Square();
	double area();
	double perimeter();
}

</pre></blockquote>

The resulting, Perl wrapper class will create the following code :<p>

<blockquote><pre>Package Shape;
@ISA = (shapes);
...
Package Circle;
@ISA = (shapes Shape);
...
Package Square;
@ISA = (shapes Shape);

</pre></blockquote>
The <tt>@ISA</tt> array determines where to look for methods of a
particular class.  In this case, both the <tt>Circle</tt> and
<tt>Square</tt> classes inherit functions from <tt>Shape</tt> so we'll
want to look in the <tt>Shape</tt> base class for them.  All classes
also inherit from the top-level module <tt>shapes</tt>.  This is
because certain common operations needed to implement shadow classes
are implemented only once and reused in the wrapper code for various
classes and structures.<p>

<p>
Since SWIG shadow classes are implemented in Perl, it is easy to
subclass from any SWIG generated class.  To do this, simply put the
name of a SWIG class in the <tt>@ISA</tt> array for your new
class. However, be forewarned that this is not a trivial problem.  In
particular, inheritance of data members is extremely tricky (and I'm
not even sure if it really works). <p>

<h3> Iterators</h3>

With each class or structure, SWIG also generates a pair of functions
to support Perl iterators.  This makes it possible to use the
<tt>keys</tt> and <tt>each</tt> functions on a C/C++ object.
Iterators are implemented using code like this :<p>

<p>
<blockquote><pre>sub FIRSTKEY {
    my $self = shift;
    @ITERATORS{$self} = [`x','y','z', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem &gt; 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        @ITERATORS{$self} = [`x','y','z', ];
        return ();
    }
}
</pre></blockquote>
The <tt>%ITERATORS</tt> hash table maintains the state of each object
for which the <tt>keys</tt> or <tt>each</tt> function has been applied
to.  The state is maintained by keeping a list of the member names.<p>

<p>
While iterators may be of limited use when working with C/C++ code, it
turns out they can be used to perform an element by element copy of an
object.<p>

<p>
<blockquote><pre>$v = new Vector(1,2,3);
$w = new Vector(0,0,0);
%$w = %$v;                # Copy contents of v into w

</pre></blockquote>

However, this is not a deep copy so they probably works better with C
than with C++.<p>

<h2> Where to go from here?</h2>

The SWIG Perl5 module is constantly improving to provide better
integration with Perl and to be easier to use.  The introduction of
shadow classes and typemaps in this release are one more step in that
direction.  The SWIG <tt>Examples</tt> directory contains more simple
examples of building Perl5 modules. As always, suggestions for
improving the Perl5 implementation are welcome.<p>
<p>

<p><hr>

<address>SWIG 1.1 - Last Modified : Mon Aug  4 10:47:01 1997</address>
</body>
</html>
