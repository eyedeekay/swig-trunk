<html>
<head>
<title>SWIG and Tcl</title>
</head>

<body bgcolor="#ffffff">
<a name="n1"></a><H1>19 SWIG and Tcl</H1>
<!-- INDEX -->
<ul>
<li><a href="#n2">Preliminaries</a>
<ul>
<li><a href="#n3">Getting the right header files</a>
<li><a href="#n4">Compiling a dynamic module</a>
<li><a href="#n5">Static linking</a>
<li><a href="#n6">Using your module</a>
<li><a href="#n7">Compilation of C++ extensions</a>
<li><a href="#n8">Compiling for 64-bit platforms</a>
<li><a href="#n9">Setting a package prefix</a>
<li><a href="#n10">Using namespaces</a>
</ul>
<li><a href="#n11">Building Tcl/Tk Extensions under Windows 95/NT</a>
<ul>
<li><a href="#n12">Running SWIG from Developer Studio</a>
<li><a href="#n13">Using NMAKE</a>
</ul>
<li><a href="#n14">Primitive Tcl Interface</a>
<ul>
<li><a href="#n15">Functions</a>
<li><a href="#n16">Global variables</a>
<li><a href="#n17">Constants</a>
<li><a href="#n18">Pointers</a>
<li><a href="#n19">Structures </a>
<li><a href="#n20">C++ Classes</a>
</ul>
<li><a href="#n21">The object-based interface</a>
<ul>
<li><a href="#n22">Creating new objects</a>
<li><a href="#n23">Invoking member functions</a>
<li><a href="#n24">Deleting objects</a>
<li><a href="#n25">Accessing member data</a>
<li><a href="#n26">Changing member data</a>
<li><a href="#n27">Managing Object Ownership</a>
<li><a href="#n28">Relationship with pointers</a>
</ul>
<li><a href="#n29">Input and output parameters</a>
<li><a href="#n30">Exception handling </a>
<li><a href="#n31">Typemaps</a>
<ul>
<li><a href="#n32">What is a typemap?</a>
<li><a href="#n33">Tcl typemaps</a>
<li><a href="#n34">Typemap variables</a>
<li><a href="#n35">Converting  a Tcl list to a char ** </a>
<li><a href="#n36">Returning values in arguments</a>
<li><a href="#n37">Useful functions</a>
<li><a href="#n38">Standard  typemaps</a>
<li><a href="#n39">Pointer handling</a>
</ul>
<li><a href="#n40">Turning a SWIG module into a Tcl Package.</a>
<li><a href="#n41">Building new kinds of Tcl interfaces (in Tcl)</a>
<ul>
<li><a href="#n42">Shadow classes</a>
</ul>
</ul>
<!-- INDEX -->



<b>Caution: This chapter is under repair!</b>

<p>
This chapter discusses SWIG's support of Tcl. SWIG currently requires
Tcl 8.0 or a later release.   Earlier releases of SWIG supported Tcl 7.x, but
this is no longer supported.

<a name="n2"></a><H2>19.1 Preliminaries</H2>


To build a Tcl module, run SWIG using the <tt>-tcl</tt> option :<p>

<p>
<blockquote><pre>$ swig -tcl example.i
</pre></blockquote>

If building a C++ extension, add the <tt>-c++</tt> option:

<p>
<blockquote><pre>$ swig -c++ -tcl example.i
</pre></blockquote>

<p>
This creates a file <tt>example_wrap.c</tt> or
<tt>example_wrap.cxx</tt> that contains all of the code needed to
build a Tcl extension module.  To finish building the module, you 
need to compile this file and link it with the rest of your program.

<a name="n3"></a><H3>19.1.1 Getting the right header files</H3>


In order to compile the wrapper code, the compiler needs the <tt>tcl.h</tt> header file.
This file is usually contained in the directory

<p>
<blockquote><pre>/usr/local/include
</pre></blockquote>

Be aware that some Tcl versions install this header file with a version number attached to it.  If
this is the case, you should probably make a symbolic link so that <tt>tcl.h</tt> points to the correct
header file.

<a name="n4"></a><H3>19.1.2 Compiling a dynamic module</H3>


The preferred approach to building an extension module is to compile it into
a shared object file or DLL.   To do this, you will need to compile your program
using comands like this (shown for Linux):

<p>
<blockquote><pre>$ swig -tcl example.i
$ gcc -c example.c
$ gcc -c example_wrap.c -I/usr/local/include
$ gcc -shared example.o example_wrap.o -o example.so
</pre></blockquote>

The exact commands for doing this vary from platform to platform. 
SWIG tries to guess the right options when it is installed.  Therefore, 
you may want to start with one of the examples in the <tt>SWIG/Examples/tcl</tt> 
directory.   If that doesn't work, you will need to read the man-pages for
your compiler and linker to get the right set of options.  You might also
check the <a href="http://swig.cs.uchicago.edu/cgi-bin/wiki.pl">SWIG Wiki</a> for
additional information.
<p>
When linking the module, the name of the output file has to match the name
of the module.  If the name of your SWIG module is "<tt>example</tt>", the
name of the corresponding object file should be
"<tt>example.so</tt>".
The name of the module is specified using the <tt>%module</tt> directive or the 
<tt> -module</tt> command line option.<p>

<a name="n5"></a><H3>19.1.3 Static linking</H3>


An alternative approach to dynamic linking is to rebuild the Tcl
interpreter with your extension module added to it.  In the past,
this approach was sometimes necesssary due to limitations in dynamic loading
support on certain machines.  However, the situation has improved greatly
over the last few years and you should not consider this approach 
unless there is really no other option.

<p>
The usual procedure for adding a new module to Tcl involves writing a
special function <tt>Tcl_AppInit()</tt> and using it to initialize the interpreter and
your module.  With SWIG, the <tt>tclsh.i</tt> and <tt>wish.i</tt> library files
can be used to rebuild the <tt>tclsh</tt> and <tt>wish</tt> interpreters respectively.
For example:

<p>
<blockquote><pre>%module example

extern int fact(int);
extern int mod(int, int);
extern double My_variable;

%include tclsh.i       // Include code for rebuilding tclsh

</pre></blockquote>

The <tt>tclsh.i</tt> library file includes supporting code that
contains everything needed to rebuild tclsh. To rebuild the interpreter,
you simply do something like this:

<p>
<blockquote><pre>$ swig -tcl example.i
$ gcc example.c example_wrap.c \
        -Xlinker -export-dynamic \
        -DHAVE_CONFIG_H -I/usr/local/include/ \
	-L/usr/local/lib -ltcl -lm -ldl \
	-o mytclsh

</pre></blockquote>
You will need to supply the same libraries that were used to build Tcl the first
time.  This may include system libraries such as <tt>-lsocket</tt>, <tt>-lnsl</tt>,
and <tt>-lpthread</tt>.  If this actually works, the new version of Tcl
should be identical to the default version except that your extension module will be
a built-in part of the interpreter.

<p>

<b>Comment:</b> In practice, you should probably try to avoid static
linking if possible. Some programmers may be inclined
to use static linking in the interest of getting better performance.
However, the performance gained by static linking tends to be rather
minimal in most situations (and quite frankly not worth the extra
hassle in the opinion of this author). 

<a name="n6"></a><H3>19.1.4 Using your module</H3>


To use your module, simply use the Tcl <tt>load</tt> command.  If
all goes well, you will be able to this:

<p>
<blockquote><pre>$ tclsh
% load ./example.so
% fact 4
24
%
</pre></blockquote>

A common error received by first-time users is the following:

<blockquote>
<pre>
% load ./example.so
couldn't find procedure Example_Init
% 
</pre>
</blockquote>

This error is almost always caused when the name of the shared object file doesn't
match the name of the module supplied using the SWIG <tt>%module</tt> directive.
Double-check the interface to make sure the module name and the shared object
file match.  Another possible cause of this error is forgetting to link the SWIG-generated
wrapper code with the rest of your application when creating the extension module.

<p>
Another common error is something similar to the following:

<blockquote>
<pre>
% load ./example.so
couldn't load file "./example.so": ./example.so: undefined symbol: fact
% 
</pre>
</blockquote>

This error usually indicates that you forgot to include some object
files or libraries in the linking of the shared library file.  Make
sure you compile both the SWIG wrapper file and your original program
into a shared library file.  Make sure you pass all of the required libraries
to the linker.  

<p>
Sometimes unresolved symbols occur because a wrapper has been created
for a function that doesn't actually exist in a library.  This usually
occurs when a header file includes a declaration for a function that
was never actually implemented or it was removed from a library
without updating the header file.  To fix this, you can either edit
the SWIG input file to remove the offending declaration or you can use
the <tt>%ignore</tt> directive to ignore the declaration.

<p>
Finally, suppose that your extension module is linked with another library like this:

<blockquote>
<pre>
$ gcc -shared example.o example_wrap.o -L/home/beazley/projects/lib -lfoo \
      -o example.so
</pre>
</blockquote>

If the <tt>foo</tt> library is compiled as a shared library, you might get the following
problem when you try to use your module:

<blockquote>
<pre>
% load ./example.so
couldn't load file "./example.so": libfoo.so: cannot open shared object file:
No such file or directory
%        
</pre>
</blockquote>

This error is generated because the dynamic linker can't locate the
<tt>libfoo.so</tt> library.  When shared libraries are loaded, the
system normally only checks a few standard locations such as
<tt>/usr/lib</tt> and <tt>/usr/local/lib</tt>.   To fix this problem,
there are several things you can do.  First, you can recompile your extension
module with extra path information. For example, on Linux you can do this:

<blockquote>
<pre>
$ gcc -shared example.o example_wrap.o -L/home/beazley/projects/lib -lfoo \
      -Xlinker -rpath /home/beazley/projects/lib \
      -o example.so
</pre>
</blockquote>

Alternatively, you can set the <tt>LD_LIBRARY_PATH</tt> environment variable to
include the directory with your shared libraries. 
If setting <tt>LD_LIBRARY_PATH</tt>, be aware that setting this variable can introduce
a noticeable performance impact on all other applications that you run.
To set it only for Tcl, you might want to do this instead:

<blockquote>
<pre>
$ env LD_LIBRARY_PATH=/home/beazley/projects/lib tclsh
</pre>
</blockquote>

Finally, you can use a command such as <tt>ldconfig</tt> to add additional search paths
to the default system configuration (this requires root access and you will need to read
the man pages). 

<a name="n7"></a><H3>19.1.5 Compilation of C++ extensions</H3>


Compilation of C++ extensions has traditionally been a tricky problem.
Since the Tcl interpreter is written in C, you need to take steps to
make sure C++ is properly initialized and that modules are compiled
correctly.

<p>
On most machines, C++ extension modules should be linked using the C++
compiler.  For example:

<p>
<blockquote><pre>% swig -c++ -tcl example.i
% g++ -c example.cxx
% g++ -c example_wrap.cxx -I/usr/local/include
% g++ -shared example.o example_wrap.o -o example.so
</pre></blockquote>

In addition to this, you may need to include additional library
files to make it work.  For example, if you are using the Sun C++ compiler on
Solaris, you often need to add an extra library <tt>-lCrun</tt> like this:

<p>
<blockquote><pre>% swig -c++ -tcl example.i
% CC -c example.cxx
% CC -c example_wrap.cxx -I/usr/local/include
% CC -G example.o example_wrap.o -L/opt/SUNWspro/lib -o example.so -lCrun
</pre></blockquote>

Of course, the extra libraries to use are completely non-portable---you will 
probably need to do some experimentation.

<p>
Sometimes people have suggested that it is necessary to relink the
Tcl interpreter using the C++ compiler to make C++ extension modules work.
In the experience of this author, this has never actually appeared to be
necessary.   Relinking the interpreter with C++ really only includes the 
special run-time libraries described above---as long as you link your extension 
modules with these libraries, it should not be necessary to rebuild Tcl.

<p>
If you aren't entirely sure about the linking of a C++ extension, you
might look at an existing C++ program.  On many Unix machines, the
<tt>ldd</tt> command will list library dependencies.  This should give
you some clues about what you might have to include when you link your
extension module. For example:

<blockquote>
<pre>
$ ldd swig
        libstdc++-libc6.1-1.so.2 => /usr/lib/libstdc++-libc6.1-1.so.2 (0x40019000)
        libm.so.6 => /lib/libm.so.6 (0x4005b000)
        libc.so.6 => /lib/libc.so.6 (0x40077000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
$
</pre>
</blockquote>

<p>
As a final complication, a major weakness of C++ is that it does not
define any sort of standard for binary linking of libraries.  This
means that C++ code compiled by different compilers will not link
together properly as libraries nor is the memory layout of classes and
data structures implemented in any kind of portable manner.  In a
monolithic C++ program, this problem may be unnoticed.  However, in Tcl, it
is possible for different extension modules to be compiled with
different C++ compilers.  As long as these modules are self-contained,
this probably won't matter.  However, if these modules start sharing data,
you will need to take steps to avoid segmentation faults and other
erratic program behavior.   If working with lots of software components, you
might want to investigate using a more formal standard such as COM.

<a name="n8"></a><H3>19.1.6 Compiling for 64-bit platforms</H3>


On platforms that support 64-bit applications (Solaris, Irix, etc.),
special care is required when building extension modules.  On these
machines, 64-bit applications are compiled and linked using a different
set of compiler/linker options.  In addition, it is not generally possible to mix 
32-bit and 64-bit code together in the same application.

<p>
To utilize 64-bits, the Tcl executable will need to be recompiled
as a 64-bit application.  In addition, all libraries, wrapper code,
and every other part of your application will need to be compiled for
64-bits.  If you plan to use other third-party extension modules, they
will also have to be recompiled as 64-bit extensions.

<p>
If you are wrapping commercial software for which you have no source
code, you will be forced to use the same linking standard as used by
that software.  This may prevent the use of 64-bit extensions.  It may
also introduce problems on platforms that support more than one
linking standard (e.g., -o32 and -n32 on Irix).

<a name="n9"></a><H3>19.1.7 Setting a package prefix</H3>


To avoid namespace problems, you can instruct SWIG to append a package
prefix to all of your functions and variables. This is done using the
-prefix option as follows :<p>
<p>
<blockquote><pre>swig -tcl -prefix Foo example.i

</pre></blockquote>
If you have a function "<tt>bar</tt>" in the SWIG file, the prefix
option will append the prefix to the name when creating a command and
call it "<tt>Foo_bar</tt>". <p>

<a name="n10"></a><H3>19.1.8 Using namespaces</H3>


Alternatively, you can have SWIG install your module into a Tcl
namespace by specifying the <tt>-namespace</tt> option :<p>
<p>
<blockquote><pre>swig -tcl -namespace example.i

</pre></blockquote>
By default, the name of the namespace will be the same as the module
name, but you can override it using the <tt>-prefix</tt> option.<p>
<p>
When the<tt> -namespace</tt> option is used, objects in the module
are always accessed with the namespace name such as <tt>Foo::bar</tt>.

<a name="n11"></a><H2>19.2 Building Tcl/Tk Extensions under Windows 95/NT</H2>


Building a SWIG extension to Tcl/Tk under Windows 95/NT is roughly
similar to the process used with Unix.  Normally, you will want to
produce a DLL that can be loaded into tclsh or wish.  This section
covers the process of using SWIG with Microsoft Visual C++.
although the procedure may be similar with other compilers.<p>

<a name="n12"></a><H3>19.2.1 Running SWIG from Developer Studio</H3>


If you are developing your application within Microsoft developer
studio, SWIG can be invoked as a custom build option.  The process
roughly follows these steps :<p>

<p>
<ul>
<li>Open up a new workspace and use the AppWizard to select a DLL project.

<li>Add both the SWIG interface file (the .i file), any supporting C
files, and the name of the wrapper file that will be created by SWIG
(ie. <tt>example_wrap.c</tt>).  Note : If using C++, choose a
different suffix for the wrapper file such as
<tt>example_wrap.cxx</tt>. Don't worry if the wrapper file doesn't
exist yet--Developer studio will keep a reference to it around.

<li>Select the SWIG interface file and go to the settings menu.  Under
settings, select the "Custom Build" option.

<li>Enter "SWIG" in the description field.

<li>Enter "<tt>swig -tcl -o $(ProjDir)\$(InputName)_wrap.c
$(InputPath)</tt>" in the "Build command(s) field"

<li>Enter "<tt>$(ProjDir)\$(InputName)_wrap.c</tt>" in the "Output files(s) field".

<li>Next, select the settings for the entire project and go to
"C++:Preprocessor". Add the include directories for your Tcl
installation under "Additional include directories".

<li>Finally, select the settings for the entire project and go to
"Link Options".  Add the Tcl library file to your link libraries.  For
example "<tt>tcl80.lib</tt>".  Also, set the name of the output file
to match the name of your Tcl module (ie. example.dll).

<li>Build your project.
</ul>
<p>
Now, assuming all went well, SWIG will be automatically invoked when
you build your project.  Any changes made to the interface file will
result in SWIG being automatically invoked to produce a new version of
the wrapper file.  To run your new Tcl extension, simply run
<tt>tclsh</tt> or <tt>wish</tt> and use the <tt>load</tt> command.
For example :<p>

<p>
<blockquote><pre>

MSDOS &gt; tclsh80
% load example.dll
% fact 4
24
%
</pre></blockquote>

<a name="n13"></a><H3>19.2.2 Using NMAKE</H3>


Alternatively, SWIG extensions can be built by writing a Makefile for
NMAKE.  To do this, make sure the environment variables for MSVC++ are
available and the MSVC++ tools are in your path.  Now, just write a
short Makefile like this :<p>
<p>
<blockquote><pre># Makefile for building various SWIG generated extensions

SRCS          = example.c
IFILE         = example
INTERFACE     = $(IFILE).i
WRAPFILE      = $(IFILE)_wrap.c

# Location of the Visual C++ tools (32 bit assumed)

TOOLS         = c:\msdev
TARGET        = example.dll
CC            = $(TOOLS)\bin\cl.exe
LINK          = $(TOOLS)\bin\link.exe
INCLUDE32     = -I$(TOOLS)\include
MACHINE       = IX86

# C Library needed to build a DLL

DLLIBC        = msvcrt.lib oldnames.lib  

# Windows libraries that are apparently needed
WINLIB        = kernel32.lib advapi32.lib user32.lib gdi32.lib comdlg32.lib 
winspool.lib

# Libraries common to all DLLs
LIBS          = $(DLLIBC) $(WINLIB) 

# Linker options
LOPT      = -debug:full -debugtype:cv /NODEFAULTLIB /RELEASE /NOLOGO /
MACHINE:$(MACHINE) -entry:_DllMainCRTStartup@12 -dll

# C compiler flags

CFLAGS    = /Z7 /Od /c /nologo
TCL_INCLUDES  = -Id:\tcl8.0a2\generic -Id:\tcl8.0a2\win
TCLLIB        = d:\tcl8.0a2\win\tcl80.lib

tcl::
	..\..\swig -tcl -o $(WRAPFILE) $(INTERFACE)
	$(CC) $(CFLAGS) $(TCL_INCLUDES) $(SRCS) $(WRAPFILE)
	set LIB=$(TOOLS)\lib
	$(LINK) $(LOPT) -out:example.dll $(LIBS) $(TCLLIB) example.obj example_wrap.obj

</pre></blockquote>
To build the extension, run NMAKE (you may need to run vcvars32
first).  This is a pretty minimal Makefile, but hopefully its enough
to get you started.  With a little practice, you'll be making lots of
Tcl extensions.<p>

<a name="n14"></a><H2>19.3 Primitive Tcl Interface</H2>


This section describes the basic Tcl interface.   The object-based interface is described shortly.

<a name="n15"></a><H3>19.3.1 Functions</H3>


C functions are turned into new Tcl commands with the same usage as
the C function. Default/optional arguments are also allowed. An
interface file like this :<p>

<p>
<blockquote><pre>%module example
int foo(int a);
double bar (double, double b = 3.0);
...

</pre></blockquote>
Will be used in Tcl like this :<p>
<p>
<blockquote><pre>set a [foo 2]
set b [bar 3.5 -1.5]
set b [bar 3.5]              # Note : default argument is used 

</pre></blockquote>

There isn't much more to say...this is pretty straightforward.<p>

<a name="n16"></a><H3>19.3.2 Global variables</H3>


For global variables, SWIG uses Tcl's variable tracing mechanism to
provide direct access.  For example:

<p>
<blockquote><pre>// example.i
%module example
...
double My_variable;
...

# Tcl script
puts $My_variable            # Output value of C global variable
set My_variable 5.5          # Change the value

</pre></blockquote>

<b>Compatibility Note:</b> 
Variable tracing is currently supported for all C/C++ datatypes.  In older versions
of SWIG, only variables of type <tt>int</tt>, <tt>double</tt>, and <tt>char *</tt> could
be linked.  All other types were accessed using special function calls.   

<a name="n17"></a><H3>19.3.3 Constants</H3>


Constants are installed as new Tcl variables. For example:

<blockquote>
<pre>
%module example
#define FOO 42
</pre>
</blockquote>

is accessed as follows:

<blockquote>
<pre>
% puts $FOO
42
%
</pre>
</blockquote>

No attempt is made to enforce the read-only nature of a constant.  Therefore, a user could reassign the value if they wanted.
You will just have to be careful.
<p>
A peculiarity of installing constants as variables is that it is necessary to use the Tcl <tt>global</tt> statement to
access constants in procedure bodies.  For example:

<blockquote>
<pre>
proc blah {} {
   global FOO
   bar $FOO
}
</pre>
</blockquote>

If a program relies on a lot of constants, this can be extremely annoying.  To fix the problem, consider using the
following typemap rule:

<blockquote>
<pre>
%apply int CONSTANT { int x };
#define FOO 42
...
void bar(int x);
</pre>
</blockquote>

When applied to an input argument, the <tt>CONSTANT</tt> rule allows a constant to be passed to a function using
its actual value or a symbolic identifier name.  For example:

<blockquote>
<pre>
proc blah {} {
   bar FOO
}
</pre>
</blockquote>

When an identifier name is given, it is used to perform an implicit hash-table lookup of the value during argument 
conversion.  This allows the <tt>global</tt> statement to be ommitted.

<a name="n18"></a><H3>19.3.4 Pointers</H3>


Pointers to C/C++ objects are represented as character strings such as
the following :<p>
<p>
<blockquote><pre>_100f8e2_p_Vector

</pre></blockquote>
A NULL pointer is represented by the string "NULL". NULL pointers can also be explicitly created as follows :<p>
<p>
<blockquote><pre>_0_p_Vector

</pre></blockquote>


As much as you might be inclined to modify a pointer value directly
from Tcl, don't.  The hexadecimal encoding is not necessarily the same
as the logical memory address of the underlying object.  Instead it is
the raw byte encoding of the pointer value.  The encoding will vary
depending on the native byte-ordering of the platform (i.e.,
big-endian vs. little-endian).  Similarly, don't try to manually cast
a pointer to a new type by simply replacing the type-string.  This is
may not work like you expect and it is particularly dangerous when
casting C++ objects.  If you need to cast a pointer or change its
value, consider writing some helper functions instead.  For example:

<blockquote>
<pre>
%inline %{
/* C-style cast */
Bar *FooToBar(Foo *f) {
   return (Bar *) f;
}

/* C++-style cast */
Foo *BarToFoo(Bar *b) {
   return dynamic_cast&lt;Foo*&gt;(b);
}

Foo *IncrFoo(Foo *f, int i) {
    return f+i;
}
%}
</pre>
</blockquote>

If you need to type-cast a lot of objects, it may indicate a serious 
weakness in your design.  Also, if working with C++, you should always try
to use the new C++ style casts.  For example, in the above code, the
C-style cast may return a bogus result whereas as the C++-style cast will return
<tt>NULL</tt> if the conversion can't be performed.

<a name="n19"></a><H3>19.3.5 Structures </H3>


SWIG generates a basic low-level interface to C structures. For
example :<p>

<p>
<blockquote><pre>struct Vector {
	double x,y,z;
};

</pre></blockquote>
gets mapped into the following collection of C functions :<p>
<p>
<blockquote><pre>double Vector_x_get(Vector *obj)
double Vector_x_set(Vector *obj, double x)
double Vector_y_get(Vector *obj)
double Vector_y_set(Vector *obj, double y)
double Vector_z_get(Vector *obj)
double Vector_z_set(Vector *obj, double z)

</pre></blockquote>

These functions are then used in the resulting Tcl interface. For
example :<p>

<p>
<blockquote><pre># v is a Vector that got created somehow
% Vector_x_get $v
3.5
% Vector_x_set $v 7.8            # Change x component
</pre></blockquote>

<p>
Similar access is provided for unions and the data members of C++ classes.<p>

<a name="n20"></a><H3>19.3.6 C++ Classes</H3>


C++ classes are handled by building a set of low level accessor
functions. Consider the following class :<p>
<p>
<blockquote><pre>
class List {
public:
  List();
  ~List();
  int  search(char *item);
  void insert(char *item);
  void remove(char *item);
  char *get(int n);
  int  length;
static void print(List *l);
};
</pre></blockquote>

<p>
When wrapped by SWIG, the following functions are created :<p>

<p>
<blockquote><pre>List    *new_List();
void     delete_List(List *l);
int      List_search(List *l, char *item);
void     List_insert(List *l, char *item);
void     List_remove(List *l, char *item);
char    *List_get(List *l, int n);
int      List_length_get(List *l);
int      List_length_set(List *l, int n);
void     List_print(List *l);

</pre></blockquote>

Within Tcl, we can use the functions as follows :<p>

<blockquote><pre>
% set l [new_List]
% List_insert $l Ale
% List_insert $l Stout
% List_insert $l Lager
% List_print $l
Lager
Stout
Ale
% puts [List_length_get $l]
3
% puts $l
_1008560_p_List
% 

</pre></blockquote>
C++ objects are really just pointers (which are represented as
strings). Member functions and data are accessed by simply passing a
pointer into a collection of accessor functions that take the pointer
as the first argument.<p>

<p>
While somewhat primitive, the low-level SWIG interface provides direct
and flexible access to almost any C++ object. As it turns out, it is
possible to do some rather amazing things with this interface as will
be shown in some of the later examples. SWIG also generates an
object-based interface that can be used in addition to the basic
interface just described here.<p>

<a name="n21"></a><H2>19.4 The object-based interface</H2>


In addition to the low-level accessors, SWIG also generates an object-based interface to C 
structures and C++
classes. This interface supplements the low-level SWIG
interface already defined--in fact, both can be used
simultaneously. To illustrate this interface, consider the previous
<tt>List</tt> class :<p>

<p>
<blockquote><pre>class List {
public:
  List();
  ~List();
  int  search(char *item);
  void insert(char *item);
  void remove(char *item);
  char *get(int n);
  int  length;
static void print(List *l);
};

</pre></blockquote>
Using the object oriented interface requires no additional
modifications or recompilation of the SWIG module (the functions are
just used differently).<p>

<a name="n22"></a><H3>19.4.1 Creating new objects</H3>


The name of the class becomes a new command for creating an
object. There are 5 methods for creating an object (<tt>MyObject
</tt>is the name of the corresponding C++ class) <p>

<p>
<blockquote><pre>MyObject o                   # Creates a new object named `o' 

MyObject o -this $objptr     # Turn a pointer to an existing C++ object into a 
                             # Tcl object named `o'

MyObject -this $objptr       # Turn the pointer $objptr into a Tcl "object"

MyObject -args args          # Create a new object and pick a name for it. A handle
                             # will be returned and is the same as the pointer value.

MyObject                     # The same as MyObject -args, but for constructors that
                             # take no arguments.
</pre></blockquote>

<p>
Thus, for our List class, you can create new List objects as follows :<p>

<p>
<blockquote><pre>List l                       # Create a new list l

set listptr [new_List]       # Create a new List using low level interface
List l2 -this $listptr       # Turn it into a List object named `l2'

set l3 [List]                # Create a new list. The name of the list is in $l3

List -this $listptr          # Turn $listptr into a Tcl object of the same name
</pre></blockquote>

<p>
Assuming you're not completely confused at this point, the best
way to think of this is that there are really two different ways of
representing an object.  One approach is to simply use the pointer
value as the name of an object. For example :<p>
<p>
<blockquote><pre>_100e8f8_p_List

</pre></blockquote>

The second approach is to allow you to pick a name for an object such
as "foo".  The different types of constructors are really just
a mechanism for using either approach.<p>

<a name="n23"></a><H3>19.4.2 Invoking member functions</H3>


Member functions are invoked using the name of the object followed by
the method name and any arguments. For example :<p>

<p>
<blockquote><pre>% List l
% l insert "Bob"
% l insert "Mary"
% l search "Dave"
0
% ...

</pre></blockquote>

Or if you let SWIG generate the name of the object, it works like this:

<p>
<blockquote><pre>% set l [List]
% $l insert "Bob"            # Note $l contains the name of the object
% $l insert "Mary"
% $l search "Dave"
0
%
</pre></blockquote>

<a name="n24"></a><H3>19.4.3 Deleting objects</H3>


Since objects are created by adding new Tcl commands, they can be
deleted by simply renaming them. For example :<p>

<p>
<blockquote><pre>% rename l ""                # Destroy list object `l'
</pre></blockquote>

It is also possible to explicitly delete the object using the delete method.
For example:

<blockquote>
<pre>
% l -delete
</pre>
</blockquote>

If applicable, SWIG will automatically call the corresponding C/C++ destructor
when the object is destroyed.

<a name="n25"></a><H3>19.4.4 Accessing member data</H3>


Member data of an object can be accessed using the <tt>cget</tt>
method. The approach is quite similar to that used in [incr Tcl] and
other Tcl extensions. For example :<p>

<p>
<blockquote><pre>% l cget -length             # Get the length of the list
13

</pre></blockquote>

The <tt>cget</tt> method currently only allows retrieval of one member
at a time. Extracting multiple members will require repeated calls.<p>
<p>
The member <tt>-this</tt> contains the pointer to the object that is
compatible with other SWIG functions. Thus, the following call would
be legal<p>
<p>
<blockquote><pre>
% List l                            # Create a new list object
% l insert Mike
% List_print [l cget -this]         # Print it out using low-level function
</pre></blockquote>

<a name="n26"></a><H3>19.4.5 Changing member data</H3>


To change the value of member data, the <tt>configure</tt> method can be used. For example :<p>
<p>
<blockquote><pre>% l configure -length 10     # Change length to 10 (probably not a good idea, but
                             # possible).

</pre></blockquote>
In a structure such as the following :<p>
<blockquote><pre>
struct Vector {
	double x, y, z;
};

</pre></blockquote>
you can change the value of all or some of the members as follows :<p>
<p>
<blockquote><pre>% v configure -x 3.5 -y 2 -z -1.0
</pre></blockquote>
<p>
The order of attributes does not matter.  <p>

<a name="n27"></a><H3>19.4.6 Managing Object Ownership</H3>


By default, objects created from Tcl are owned by the Tcl interpreter and
are automatically destroyed when the correponding Tcl variable goes out of scope.
However, sometimes it is necessary to change the owneship of an object
managed by the interpreter.  For instance, if you stored an object in another data structure, you
might want Tcl to disown the object.  Similarly, it may make sense for Tcl to acquire ownership of
an object returned by C.

<p>
To handle object ownership, two object methods are available:

<blockquote>
<pre>
% obj -disown            # Release ownership
% obj -acquire           # Acquire ownership
</pre>
</blockquote>

When Tcl owns an object, it is released when the Tcl variable is destroyed.  Otherwise,
the Tcl variable is destroyed without calling the corresponding C/C++ destructor.

<a name="n28"></a><H3>19.4.7 Relationship with pointers</H3>


The object oriented interface is mostly compatible with all of the
functions that accept pointer values as arguments. Here are a couple
of things to keep in mind :<p>

<p>
<ul>
<li>If you explicitly gave a name to an object, the pointer value can
be retrieved using the `<tt>cget -this</tt>' method. The pointer value
is what you should give to other SWIG generated functions if
necessary.

<li>If you let SWIG generate the name of an object for you, then the
name of the object is the same as the pointer value. This is the
preferred approach.

<li>If you have a pointer value but it's not a Tcl object, you can
turn it into one by calling the constructor with the `<tt>-this</tt>'
option.

</ul>
<p>
Here is a script that illustrates how these things work :<p>
<p>
<blockquote><pre># Example 1 : Using a named object

List l                       # Create a new list
l insert Dave                # Call some methods
l insert Jane	
l insert Pat
List_print [l cget -this]    # Call a static method (which requires the pointer value)

# Example 2: Let SWIG pick a name

set l [List]                 # Create a new list
$l insert Dave               # Call some methods
$l insert Jane
$l insert Pat
List_print $l                # Call static method (name of object is same as pointer)

# Example 3: Already existing object
set l [new_List]             # Create a raw object using low-level interface
List_insert $l Dave          # Call some methods (using low-level functions)
List -this $l                # Turn it into a Tcl object instead
$l insert Jane
$l insert Part
List_print $l                # Call static method (uses pointer value as before).
</pre></blockquote>
<p>

<a name="n29"></a><H2>19.5 Input and output parameters</H2>


A common problem in some C programs is handling parameters passed as simple pointers.  For
example:

<blockquote>
<pre>
void add(int x, int y, int *result) {
   *result = x + y;
}
</pre>
</blockquote>

or perhaps

<blockquote>
<pre>
int sub(int *x, int *y) {
   return *x+*y;
}
</pre>
</blockquote>

The easiest way to handle these situations is to use the <tt>typemaps.i</tt> file.  For example:

<blockquote>
<pre>
%module example
%include "typemaps.i"

void add(int, int, int *OUTPUT);
int  sub(int *INPUT, int *INPUT);
</pre>
</blockquote>

In Tcl, this allows you to pass simple values instead of pointer.  For example:

<blockquote>
<pre>
set a [add 3 4]
puts $a
7
</pre>
</blockquote>

Notice how the <tt>INPUT</tt> parameters allow integer values to be passed instead of pointers
and how the <tt>OUTPUT</tt> parameter creates a return result.

<p>
If you don't want to use the names <tt>INPUT</tt> or <tt>OUTPUT</tt>, use the <tt>%apply</tt>
directive.  For example:

<blockquote>
<pre>
%module example
%include "typemaps.i"

%apply int *OUTPUT { int *result };
%apply int *INPUT  { int *x, int *y};

void add(int x, int y, int *result);
int  sub(int *x, int *y);
</pre>
</blockquote>

<p>
If a function mutates one of its parameters like this,

<blockquote>
<pre>
void negate(int *x) {
   *x = -(*x);
}
</pre>
</blockquote>

you can use <tt>INOUT</tt> like this:

<blockquote>
<pre>
%include "typemaps.i"
...
void negate(int *INOUT);
</pre>
</blockquote>

In Tcl, a mutated parameter shows up as a return value.  For example:

<blockquote>
<pre>
set a [negate 3]
puts $a
-3
</pre>
</blockquote>

<p>
The most common use of these special typemap rules is to handle functions that
return more than one value.   For example, sometimes a function returns a result
as well as a special error code:

<blockquote>
<pre>
/* send message, return number of bytes sent, along with success code */
int send_message(char *text, int len, int *success);
</pre>
</blockquote>

To wrap such a function, simply use the <tt>OUTPUT</tt> rule above. For example:

<blockquote>
<pre>
%module example
%include "typemaps.i"
%apply int *OUTPUT { int *success };
...
int send_message(char *text, int *success);
</pre>
</blockquote>

When used in Tcl, the function will return multiple values as a list.  

<blockquote>
<pre>
set r [send_message "Hello World"]
set bytes [lindex $r 0]
set success [lindex $r 1]
</pre>
</blockquote>

Another common use of multiple return values are in query functions.  For example:

<blockquote>
<pre>
void get_dimensions(Matrix *m, int *rows, int *columns);
</pre>
</blockquote>

To wrap this, you might use the following:

<blockquote>
<pre>
%module example
%include "typemaps.i"
%apply int *OUTPUT { int *rows, int *columns };
...
void get_dimensions(Matrix *m, int *rows, *columns);
</pre>
</blockquote>

Now, in Perl:

<blockquote>
<pre>
set dim [get_dimensions $m]
set r  [lindex $dim 0]
set c  [lindex $dim 1]
</pre>
</blockquote>

<a name="n30"></a><H2>19.6 Exception handling </H2>


The <tt>%exception</tt> directive can be used to create a user-definable
exception handler in charge of converting exceptions in your C/C++
program into Tcl exceptions.  The chapter on customization features
contains more details, but suppose you extended the array example into
a C++ class like the following :<p>

<blockquote><pre>
class RangeError {};   // Used for an exception

class DoubleArray {
  private:
    int n;
    double *ptr;
  public:
    // Create a new array of fixed size
    DoubleArray(int size) {
      ptr = new double[size];
      n = size;
    }
    // Destroy an array
    ~DoubleArray() {
       delete ptr;
    }
    // Return the length of the array
    int   length() {
      return n;
    }

    // Get an item from the array and perform bounds checking.
    double getitem(int i) {
      if ((i &gt;= 0) &amp;&amp; (i &lt; n))
        return ptr[i];
      else
        throw RangeError();
    }

    // Set an item in the array and perform bounds checking.
    void setitem(int i, double val) {
      if ((i &gt;= 0) &amp;&amp; (i &lt; n))
        ptr[i] = val;
      else {
        throw RangeError();
      }
    }
  };
</pre></blockquote>

<p>
The functions associated with this class can throw a C++ range
exception for an out-of-bounds array access.  We can catch this in our
Tcl extension by specifying the following in an interface file :<p>

<p>
<blockquote><pre>%exception {
  try {
    $action                // Gets substituted by actual function call
  }
  catch (RangeError) {
    Tcl_SetStringObj(tcl_result,"Array index out-of-bounds");
    return TCL_ERROR;
  }
}

</pre></blockquote>

<p>
As shown, the exception handling code will be added to every wrapper function.
Since this is somewhat inefficient.  You might consider refining the 
exception handler to only apply to specific methods like this:

<blockquote>
<pre>
%exception getitem {
  try {
    $action
  }
  catch (RangeError) {
    Tcl_SetStringObj(tcl_result,"Array index out-of-bounds");
    return TCL_ERROR;
  }
}

%exception setitem {
  try {
    $action
  }
  catch (RangeError) {
    Tcl_SetStringObj(tcl_result,"Array index out-of-bounds");
    return TCL_ERROR;
  }
}
</pre>
</blockquote>

In this case, the exception handler is only attached to methods and functions
named <tt>getitem</tt> and <tt>setitem</tt>.

<p>
If you had a lot of different methods, you can avoid extra typing by using a macro.
For example:

<blockquote>
<pre>
%define RANGE_ERROR
{
  try {
    $action
  }
  catch (RangeError) {
    Tcl_SetStringObj(tcl_result,"Array index out-of-bounds");
    return TCL_ERROR;
  }
}
%enddef

%exception getitem RANGE_ERROR;
%exception setitem RANGE_ERROR;
</pre>
</blockquote>

Since SWIG's exception handling is user-definable, you are not limited to C++ exception handling.
See the chapter on "<a href="Customization.html">Customization Features</a>" for more examples.

<a name="n31"></a><H2>19.7 Typemaps</H2>


This section describes how you can modify SWIG's default wrapping behavior
for various C/C++ datatypes using the <tt>%typemap</tt> directive.   This
is an advanced topic that assumes familiarity with the Tcl C API as well
as the material in the "<a href="Typemaps.html">Typemaps</a>" chapter.

<p>
Before proceeding, it should be stressed that typemaps are not a required 
part of using SWIG---the default wrapping behavior is enough in most cases.
Typemaps are only used if you want to change some aspect of the primitive
C-Tcl interface.

<a name="n32"></a><H3>19.7.1 What is a typemap?</H3>


A typemap is nothing more than a code generation rule that is attached to 
a specific C datatype.   For example, to convert integers from Tcl to C,
you might define a typemap like this:

<p>
<blockquote><pre>%module example

%typemap(in) int {
        if (Tcl_GetIntFromObj(interp,$input,&$1) == TCL_ERROR) return TCL_ERROR;
	printf("Received an integer : %d\n",$1);
}
extern int fact(int n);
</pre></blockquote>

<p>
Typemaps are always associated with some specific aspect of code generation.
In this case, the "in" method refers to the conversion of input arguments
to C/C++.  The datatype <tt>int</tt> is the datatype to which the typemap
will be applied.  The supplied C code is used to convert values.  In this
code a number of special variable prefaced by a <tt>$</tt> are used.  The
<tt>$1</tt> variable is placeholder for a local variable of type <tt>int</tt>.
The <tt>$input</tt> variable is the input object of type <tt>Tcl_Obj *</tt>.

<p>
When this example is compiled into a Tcl module, it operates as follows:

<p>
<blockquote><pre>% load ./example.so
% fact 6
Received an integer : 6
720
</pre></blockquote>
<p>

In this example, the typemap is applied to all occurrences of the <tt>int</tt> datatype.
You can refine this by supplying an optional parameter name.  For example:

<blockquote><pre>%module example

%typemap(in) int n {
        if (Tcl_GetIntFromObj(interp,$input,&$1) == TCL_ERROR) return TCL_ERROR;
	printf("n = %d\n",$1);
}
extern int fact(int n);
</pre></blockquote>

In this case, the typemap code is only attached to arguments that exactly match <tt>int n</tt>.

<p>
The application of a typemap to specific datatypes and argument names involves
more than simple text-matching--typemaps are fully integrated into the
SWIG type-system.   When you define a typemap for <tt>int</tt>, that typemap
applies to <tt>int</tt> and qualified variations such as <tt>const int</tt>.  In addition,
the typemap system follows <tt>typedef</tt> declarations.  For example:

<blockquote>
<pre>
%typemap(in) int n {
        if (Tcl_GetIntFromObj(interp,$input,&$1) == TCL_ERROR) return TCL_ERROR;
	printf("n = %d\n",$1);
}
typedef int Integer;
extern int fact(Integer n);    // Above typemap is applied
</pre>
</blockquote>

However, the matching of <tt>typedef</tt> only occurs in one direction.  If you
defined a typemap for <tt>Integer</tt>, it is not applied to arguments of
type <tt>int</tt>.

<p>
Typemaps can also be defined for groups of consecutive arguments.  For example:

<blockquote>
<pre>
%typemap(in) (char *str, int len) {
    $1 = Tcl_GetStringFromObj($input,&$2);
};

int count(char c, char *str, int len);
</pre>
</blockquote>

When a multi-argument typemap is defined, the arguments are always handled as a single
Tcl object.  This allows the function to be used like this (notice how the length
parameter is ommitted):

<blockquote>
<pre>
% count e "Hello World"
1
</pre>
</blockquote>

<a name="n33"></a><H3>19.7.2 Tcl typemaps</H3>


The previous section illustrated an "in" typemap for converting Tcl objects to C.
A variety of different typemap methods are defined by the Tcl module.  For example,
to convert a C integer back into a Tcl object, you might define an "out" typemap
like this:

<blockquote>
<pre>
%typemap(out) int {
    Tcl_SetObjResult(interp,Tcl_NewIntObj($1));
}
</pre>
</blockquote>

The following list details all of the typemap methods that can be used by the Tcl module:
<p>
<tt>%typemap(in)	</tt>
<blockquote>
Converts Tcl objects to input function arguments<p>
</blockquote>

<tt>%typemap(out)</tt>
<blockquote>
Converts return value of a C function to a Tcl object<p>
</blockquote>

<tt>%typemap(varin)</tt>
<blockquote>
Assigns a C global variable from a Tcl object<p>
</blockquote>

<tt>%typemap(varout)</tt>
<blockquote>
Returns a C global variable as a Tcl object<p>
</blockquote>

<tt>%typemap(freearg)</tt>
<blockquote>
Cleans up a function argument (if necessary)<p>
</blockquote>

<tt>%typemap(argout)</tt>
<blockquote>
Output argument processing<p>
</blockquote>

<tt>%typemap(ret)</tt>
<blockquote>
Cleanup of function return values<p>
</blockquote>

<tt>%typemap(consttab)</tt>
<blockquote>
Creation of Tcl constants (constant table)<p>
</blockquote>

<tt>%typemap(constcode)</tt> 
<blockquote>
Creation of Tcl constants (init function)
</blockquote>

<tt>%typemap(memberin)</tt>
<blockquote>
Setting of structure/class member data<p>
</blockquote>

<tt>%typemap(globalin)</tt>
<blockquote>
Setting of C global variables<p>
</blockquote>

<tt>%typemap(check)</tt>
<blockquote>
Checks function input values.<p>
</blockquote>

<tt>%typemap(default)</tt>
<blockquote>
Set a default value for an argument (making it optional).
</blockquote>

<tt>%typemap(ignore)</tt>
<blockquote>
Ignore an argument, but initialize its value.
</blockquote>

<tt>%typemap(arginit)</tt>
<blockquote>
Initialize an argument to a value before any conversions occur.
</blockquote>

Examples of these methods will appear shortly.

<a name="n34"></a><H3>19.7.3 Typemap variables</H3>


Within typemap code, a number of special variables prefaced with a <tt>$</tt> may appear.
A full list of variables can be found in the "<a href="Typemaps.html">Typemaps</a>" chapter.
This is a list of the most common variables:

<p>
<tt>$1</tt>
<blockquote>
A C local variable corresponding to the actual type specified in the
<tt>%typemap</tt> directive.  For input values, this is a C local variable
that's supposed to hold an argument value.  For output values, this is
the raw result that's supposed to be returned to Tcl.
</blockquote>

<p>
<tt>$input</tt>
<blockquote>
 A <tt>Tcl_Obj *</tt> holding a raw Tcl object with an argument or variable value.
</blockquote>

<p>
<tt>$result</tt>
<blockquote>
A <tt>Tcl_Obj *</tt> that holds the result to be returned to Tcl.
</blockquote>
<p>

<tt>$1_name</tt>
<blockquote>
The parameter name that was matched. 
</blockquote>
<p>

<tt>$1_type</tt>
<blockquote>
The actual C datatype matched by the typemap.
</blockquote>
<p>

<tt>$1_ltype</tt>
<blockquote>
An assignable version of the datatype matched by the typemap (a type that can appear on the left-hand-side of
a C assignment operation).  This type is stripped of qualifiers and may be an altered version of <tt>$1_type</tt>.
All arguments and local variables in wrapper functions are declared using this type so that their values can be
properly assigned.
</blockquote>

<tt>$symname</tt>
<blockquote>
The Tcl name of the wrapper function being created.
</blockquote>

<a name="n35"></a><H3>19.7.4 Converting  a Tcl list to a char ** </H3>


A common problem in many C programs is the processing of command line
arguments, which are usually passed in an array of NULL terminated
strings.  The following SWIG interface file allows a Tcl list to be
used as a <tt>char **</tt> object.<p>

<p>
<blockquote><pre>%module argv

// This tells SWIG to treat char ** as a special case
%typemap(in) char ** {
     Tcl_Obj **listobjv;
     int       nitems;
     int       i;
     if (Tcl_ListObjGetElements(interp, $input, &nitems, &listobjv) == TCL_ERROR) {
        return TCL_ERROR;
     }
     $1 = (char **) malloc((nitems+1)*sizeof(char *));
     for (i = 0; i < nitems; i++) {
        $1[i] = Tcl_GetStringFromObj(listobjv[i],0);
     }
     $1[i] = 0;
}

// This gives SWIG some cleanup code that will get called after the function call
%typemap(freearg) char ** {
     if ($1) {
        free($1);
     }
}

// Now a test functions
%inline %{
int print_args(char **argv) {
    int i = 0;
    while (argv[i]) {
         printf("argv[%d] = %s\n", i,argv[i]);
         i++;
    }
    return i;
}
%}
%include tclsh.i

</pre></blockquote>

In Tcl:
<p>
<blockquote><pre>% print_args {John Guido Larry}
argv[0] = John
argv[1] = Guido
argv[2] = Larry
3
</pre></blockquote>

<a name="n36"></a><H3>19.7.5 Returning values in arguments</H3>


The "argout" typemap can be used to return a value originating from a
function argument. For example :<p>

<p>
<blockquote><pre>// A typemap defining how to return an argument by appending it to the result
%typemap(argout) double *outvalue {
     Tcl_Obj *o = Tcl_NewDoubleObj($1);
     Tcl_ListObjAppendElement(interp,$result,o);
}

// A typemap telling SWIG to ignore an argument for input
// However, we still need to pass a pointer to the C function
%typemap(ignore) double *outvalue (double temp) {
     $1 = &temp;
}

// Now a function returning two values
int mypow(double a, double b, double *outvalue) {
        if ((a &lt; 0) || (b &lt; 0)) return -1;
        *outvalue = pow(a,b);
        return 0;
};

</pre></blockquote>
When wrapped, SWIG matches the <tt>argout</tt> typemap to the
"<tt>double *outvalue</tt>" argument. The "ignore" typemap tells SWIG
to simply ignore this argument when generating wrapper code.  As a
result, a Tcl function using these typemaps will work like this :<p>
<p>

<blockquote><pre>% mypow 2 3     # Returns two values, a status value and the result
0 8
%
</pre></blockquote>

<a name="n37"></a><H3>19.7.6 Useful functions</H3>


The following tables provide some functions that may be useful in
writing Tcl typemaps. 

<p>
<b>Integers</b>

<blockquote>
<pre>
Tcl_Obj   *Tcl_NewIntObj(int Value);
void       Tcl_SetIntObj(Tcl_Obj *obj, int Value);
int        Tcl_GetIntFromObj(Tcl_Interp *, Tcl_Obj *obj, int *ip);
</pre>
</blockquote>

<b>Floating Point</b>

<blockquote>
<pre>
Tcl_Obj  *Tcl_NewDoubleObj(double Value);
void      Tcl_SetDoubleObj(Tcl_Obj *obj, double value);
int       Tcl_GetDoubleFromObj(Tcl_Interp *, Tcl_Obj *o, double *dp);
</pre>
</blockquote>

<b>Strings</b>

<blockquote>
<pre>
Tcl_Obj  *Tcl_NewStringObj(char *str, int len);
void      Tcl_SetStringObj(Tcl_Obj *obj, char *str, int len);
char     *Tcl_GetStringFromObj(Tcl_Obj *obj, int *len);
void      Tcl_AppendToObj(Tcl_Obj *obj, char *str, int len);
</pre>
</blockquote>

<b>Lists</b>

<blockquote>
<pre>
Tcl_Obj  *Tcl_NewListObj(int objc, Tcl_Obj *objv);
int       Tcl_ListObjAppendList(Tcl_Interp *, Tcl_Obj *listPtr, Tcl_Obj *elemListPtr);
int       Tcl_ListObjAppendElement(Tcl_Interp *, Tcl_Obj *listPtr, Tcl_Obj *element);
int       Tcl_ListObjGetElements(Tcl_Interp *, Tcl_Obj *listPtr, int *objcPtr, Tcl_Obj ***objvPtr);
int       Tcl_ListObjLength(Tcl_Interp *, Tcl_Obj *listPtr, int *intPtr);
int       Tcl_ListObjIndex(Tcl_Interp *, Tcl_Obj *listPtr, int index, Tcl_Obj_Obj **objptr);
int       Tcl_ListObjReplace(Tcl_Interp *, Tcl_Obj *listPtr, int first, int count, int objc, Tcl_Obj *objv);
</pre>
</blockquote>

<b>Objects</b>

<blockquote>
<pre>
Tcl_Obj *Tcl_DuplicateObj(Tcl_Obj *obj);
void     Tcl_IncrRefCount(Tcl_Obj *obj);
void     Tcl_DecrRefCount(Tcl_Obj *obj);
int      Tcl_IsShared(Tcl_Obj *obj);
</pre>
</blockquote>

<a name="n38"></a><H3>19.7.7 Standard  typemaps</H3>


The following typemaps show how to convert a few common kinds of
objects between Tcl and C (and to give a better idea of how typemaps
work)<p>


<b>Integer conversion</b>

<blockquote>
<pre>
%typemap(in) int, short, long {
   int temp;
   if (Tcl_GetIntFromObj(interp, $input, &temp) == TCL_ERROR)
      return TCL_ERROR;
   $1 = ($1_ltype) temp;
}
</pre>
</blockquote>

<p>
<blockquote>
<pre>
%typemap(out) int, short, long {
   Tcl_SetIntObj($result,(int) $1);
}
</pre>
</blockquote>

<b>Floating point conversion</b>

<blockquote>
<pre>
%typemap(in) float, double {
   double temp;
   if (Tcl_GetDoubleFromObj(interp, $input, &temp) == TCL_ERROR)
       return TCL_ERROR;
   $1 = ($1_ltype) temp;
}
</pre>
</blockquote>

<p>
<blockquote>
<pre>
%typemap(out) float, double {
   Tcl_SetDoubleObj($result, $1);
}
</pre>
</blockquote>

<b>String Conversion</b>

<blockquote>
<pre>
%typemap(in) char * {
   int len;
   $1 = Tcl_GetStringFromObj(interp, &len);
   }
}
</pre>
</blockquote>

<p>
<blockquote>
<pre>
%typemap(out) char * {
   Tcl_SetStringObj($result,$1);
}
</pre>
</blockquote>

<a name="n39"></a><H3>19.7.8 Pointer handling</H3>


SWIG pointers are mapped into Tcl strings containing the
hexadecimal value and type.  The following functions can be used to
create and read pointer values.<p>

<p>
<tt>
int SWIG_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *obj, void **ptr, swig_type_info *ty, int flags)</tt>

<p>
<blockquote>
Converts a Tcl object <tt>obj</tt> to a C pointer.  The result of the conversion is placed
into the pointer located at <tt>ptr</tt>.  <tt>ty</tt> is a SWIG type descriptor structure.
<tt>flags</tt> is used to handle error checking and other aspects of conversion.  It is currently
reserved for future expansion. Returns 0 on success and -1 on error.
</blockquote>

<p>
<tt>
Tcl_Obj *SWIG_NewPointerObj(void *ptr, swig_type_info *ty, int flags)</tt>
<p>

<blockquote>
Creates a new Tcl pointer object.  <tt>ptr</tt> is the pointer to convert, <tt>ty</tt> is the SWIG type descriptor structure that
describes the type, and <tt>own</tt> is a flag reserved for future expansion.
</blockquote>

Both of these functions require the use of a special SWIG
type-descriptor structure.  This structure contains information about
the mangled name of the datatype, type-equivalence information, as
well as information about converting pointer values under C++
inheritance.   For a type of <tt>Foo *</tt>, the type descriptor structure
is usually accessed as follows:

<blockquote>
<pre>
Foo *f;
if (SWIG_ConvertPtr(interp,$input, (void **) &f, SWIGTYPE_p_Foo, 0) == -1) return NULL;

Tcl_Obj *;
obj = SWIG_NewPointerObj(f, SWIGTYPE_p_Foo, 0);
</pre>
</blockquote>

In a typemap, the type descriptor should always be accessed using the special typemap
variable <tt>$1_descriptor</tt>.  For example:

<blockquote>
<pre>
%typemap(in) Foo * {
   if ((SWIG_ConvertPtr(interp, $input,(void **) &$1, $1_descriptor,0)) == -1) return NULL;
}
</pre>
</blockquote>

<p>
If necessary, the descriptor for any type can be obtained using the <tt>$descriptor()</tt> macro in a typemap.
For example:

<blockquote>
<pre>
%typemap(in) Foo * {
   if ((SWIG_ConvertPtr(interp,$input,(void **) &$1, $descriptor(Foo *), 0)) == -1) return NULL;
}
</pre>
</blockquote>

<a name="n40"></a><H2>19.8 Turning a SWIG module into a Tcl Package.</H2>


Tcl 7.4 introduced the idea of an extension package.  By default, SWIG
generates all of the code necessary to create a package. To set the package version,
simply use the <tt>-pkgversion</tt> option. For example:

<blockquote>
<pre>
% swig -tcl -pkgversion 2.3 example.i
</pre>
</blockquote>

After building the SWIG generated module, you need to execute
the "<tt>pkg_mkIndex</tt>" command inside tclsh.  For example :<p>

<blockquote><pre>
unix &gt; tclsh
% pkg_mkIndex . example.so
% exit

</pre></blockquote>
This creates a file "<tt>pkgIndex.tcl</tt>" with information about the
package.  To use your<p> package, you now need to move it to its own
subdirectory which has the same name as the package. For example :<p>
<p>
<blockquote><pre>./example/
	   pkgIndex.tcl           # The file created by pkg_mkIndex
	   example.so             # The SWIG generated module

</pre></blockquote>
<p>
Finally, assuming that you're not entirely confused at this point,
make sure that the example subdirectory is visible from the
directories contained in either the <tt>tcl_library</tt> or
<tt>auto_path</tt> variables.  At this point you're ready to use the
package as follows :<p>

<blockquote><pre>
unix &gt; tclsh
% package require example
% fact 4
24
%
</pre></blockquote>
<p>
If  you're working with an example in the current directory and this doesn't work, do this instead :<p>
<p>
<blockquote><pre>unix &gt; tclsh
% lappend auto_path .
% package require example
% fact 4
24

</pre></blockquote>
<p>

As a final note, most SWIG examples do not yet use the
<tt>package</tt> commands. For simple extensions it may be easier just
to use the <tt>load</tt> command instead.<p>

<a name="n41"></a><H2>19.9 Building new kinds of Tcl interfaces (in Tcl)</H2>


One of the most interesting aspects of Tcl and SWIG is that you can
create entirely new kinds of Tcl interfaces in Tcl using the low-level
SWIG accessor functions.  For example, suppose you had a library of
helper functions to access arrays :<p>

<p>
<blockquote><pre>/* File : array.i */
%module array

%inline %{
double *new_double(int size) {
        return (double *) malloc(size*sizeof(double));
}
void delete_double(double *a) {
        free(a);
}
double get_double(double *a, int index) {
        return a[index];
}
void set_double(double *a, int index, double val) {
        a[index] = val;
}
int *new_int(int size) {
        return (int *) malloc(size*sizeof(int));
}
void delete_int(int *a) {
        free(a);
}
int get_int(int *a, int index) {
        return a[index];
}
int set_int(int *a, int index, int val) {
        a[index] = val;
}
%}

</pre></blockquote>
While these could be called directly, we could also write a Tcl script
like this :<p>

<p>
<blockquote><pre>proc Array {type size} {
    set ptr [new_$type $size]
    set code {
        set method [lindex $args 0]
        set parms [concat $ptr [lrange $args 1 end]]
        switch $method {
            get {return [eval "get_$type $parms"]}
            set {return [eval "set_$type $parms"]}
            delete {eval "delete_$type $ptr; rename $ptr {}"}
        }
    }
    # Create a procedure
    uplevel "proc $ptr args {set ptr $ptr; set type $type;$code}"
    return $ptr
}
</pre></blockquote>

<p>
Our script allows easy array access as follows :<p>

<p>
<blockquote><pre>set a [Array double 100]                   ;# Create a double [100]
for {set i 0} {$i &lt; 100} {incr i 1} {      ;# Clear the array
	$a set $i 0.0
}
$a set 3 3.1455                            ;# Set an individual element
set b [$a get 10]                          ;# Retrieve an element

set ia [Array int 50]                      ;# Create an int[50]
for {set i 0} {$i &lt; 50} {incr i 1} {       ;# Clear it
	$ia set $i 0
}
$ia set 3 7                                ;# Set an individual element
set ib [$ia get 10]                        ;# Get an individual element

$a delete                                  ;# Destroy a
$ia delete                                 ;# Destroy ia
</pre></blockquote>

<p>
The cool thing about this approach is that it makes a common interface
for two different types of arrays.  In fact, if we were to add more C
datatypes to our wrapper file, the Tcl code would work with those as
well--without modification.  If an unsupported datatype was requested,
the Tcl code would simply return with an error so there is very little
danger of blowing something up (although it is easily accomplished
with an out of bounds array access).<p>

<a name="n42"></a><H3>19.9.1 Shadow classes</H3>


A similar approach can be applied to shadow classes.  The following
example is provided by Erik Bierwagen and Paul Saxe.  To use it, run
SWIG with the <tt>-noobject</tt> option (which disables the builtin
object oriented interface).  When running Tcl, simply source this
file.  Now, objects can be used in a more or less natural fashion.<p>

<p>
<blockquote><pre># swig_c++.tcl
# Provides a simple object oriented interface using
# SWIG's low level interface.
#

proc new {objectType handle_r args} {
    # Creates a new SWIG object of the given type,
    # returning a handle in the variable "handle_r".
    #
    # Also creates a procedure for the object and a trace on
    # the handle variable that deletes the object when the
    # handle varibale is overwritten or unset
    upvar $handle_r handle
    #
    # Create the new object
    #
    eval set handle \[new_$objectType $args\]
    #
    # Set up the object procedure
    #
    proc $handle {cmd args} "eval ${objectType}_\$cmd $handle \$args"
    #
    # And the trace ...
    #
    uplevel trace variable $handle_r uw "{deleteObject $objectType $handle}"
    #
    # Return the handle so that 'new' can be used as an argument to a procedure
    #
    return $handle
}

proc deleteObject {objectType handle name element op} {
    #
    # Check that the object handle has a reasonable form
    #
    if {![regexp {_[0-9a-f]*_(.+)_p} $handle]} {
        error "deleteObject: not a valid object handle: $handle"
    }
    #
    # Remove the object procedure
    #
    catch {rename $handle {}}
    #
    # Delete the object
    #
    delete_$objectType $handle
}

proc delete {handle_r} {
    #
    # A synonym for unset that is more familiar to C++ programmers
    #
    uplevel unset $handle_r
}
</pre></blockquote>

<p>
To use this file, we simply source it and execute commands such as
"new" and "delete" to manipulate objects.  For example :<p>

<p>
<blockquote><pre>// list.i
%module List
%{
#include "list.h"
%}

// Very simple C++ example

class List {
public:
  List();  // Create a new list
  ~List(); // Destroy a list
  int  search(char *value);
  void insert(char *);  // Insert a new item into the list
  void remove(char *);  // Remove item from list
  char *get(int n);     // Get the nth item in the list
  int  length;          // The current length of the list
static void print(List *l);  // Print out the contents of the list
};
</pre></blockquote>

<p>
Now a Tcl script using the interface...<p>

<p>
<blockquote><pre>load ./list.so list       ; # Load the module
source swig_c++.tcl       ; # Source the object file

new List l
$l insert Dave
$l insert John
$l insert Guido
$l remove Dave
puts $l length_get

delete l

</pre></blockquote>
The cool thing about this example is that it works with any C++ object
wrapped by SWIG and requires no special compilation.  Proof that a
short, but clever Tcl script can be combined with SWIG to do many
interesting things.<p>

<p><hr>

<address>SWIG 1.3 - Last Modified : May 28, 2002</address>
</body>
</html>