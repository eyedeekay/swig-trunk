<html>
<head>
<title>SWIG and Tcl</title>
</head>

<body bgcolor="#ffffff">
<h1>10 SWIG and Tcl</h1>

<b>Caution: This chapter is under repair!</b>

<p>
This chapter discusses SWIG's support of Tcl. SWIG currently requires
Tcl 8.0 or a later release.   Earlier releases of SWIG supported Tcl 7.x, but
this is no longer supported.

<h2>Preliminaries</h2>

To build a Tcl module, run SWIG using the <tt>-tcl</tt> option :<p>

<p>
<blockquote><pre>$ swig -tcl example.i
</pre></blockquote>

If building a C++ extension, add the <tt>-c++</tt> option:

<p>
<blockquote><pre>$ swig -c++ -tcl example.i
</pre></blockquote>

<p>
This creates a file <tt>example_wrap.c</tt> or
<tt>example_wrap.cxx</tt> that contains all of the code needed to
build a Tcl extension module.  To finish building the module, you 
need to compile this file and link it with the rest of your program.

<h3>Getting the right header files</h3>

In order to compile the wrapper code, the compiler needs the <tt>tcl.h</tt> header file.
This file is usually contained in the directory

<p>
<blockquote><pre>/usr/local/include
</pre></blockquote>

Be aware that some Tcl versions install this header file with a version number attached to it.  If
this is the case, you should probably make a symbolic link so that <tt>tcl.h</tt> points to the correct
header file.

<h3>Compiling a dynamic module</h3>

The preferred approach to building an extension module is to compile it into
a shared object file or DLL.   To do this, you will need to compile your program
using comands like this (shown for Linux):

<p>
<blockquote><pre>$ swig -tcl example.i
$ gcc -c example.c
$ gcc -c example_wrap.c -I/usr/local/include
$ gcc -shared example.o example_wrap.o -o example.so
</pre></blockquote>

The exact commands for doing this vary from platform to platform. 
SWIG tries to guess the right options when it is installed.  Therefore, 
you may want to start with one of the examples in the <tt>SWIG/Examples/tcl</tt> 
directory.   If that doesn't work, you will need to read the man-pages for
your compiler and linker to get the right set of options.  You might also
check the <a href="http://swig.cs.uchicago.edu/cgi-bin/wiki.pl">SWIG Wiki</a> for
additional information.
<p>
When linking the module, the name of the output file has to match the name
of the module.  If the name of your SWIG module is "<tt>example</tt>", the
name of the corresponding object file should be
"<tt>example.so</tt>".
The name of the module is specified using the <tt>%module</tt> directive or the 
<tt> -module</tt> command line option.<p>

<h3>Static linking</h3>

An alternative approach to dynamic linking is to rebuild the Tcl
interpreter with your extension module added to it.  In the past,
this approach was sometimes necesssary due to limitations in dynamic loading
support on certain machines.  However, the situation has improved greatly
over the last few years and you should not consider this approach 
unless there is really no other option.

<p>
The usual procedure for adding a new module to Tcl involves writing a
special function <tt>Tcl_AppInit()</tt> and using it to initialize the interpreter and
your module.  With SWIG, the <tt>tclsh.i</tt> and <tt>wish.i</tt> library files
can be used to rebuild the <tt>tclsh</tt> and <tt>wish</tt> interpreters respectively.
For example:

<p>
<blockquote><pre>%module example

extern int fact(int);
extern int mod(int, int);
extern double My_variable;

%include tclsh.i       // Include code for rebuilding tclsh

</pre></blockquote>

The <tt>tclsh.i</tt> library file includes supporting code that
contains everything needed to rebuild tclsh. To rebuild the interpreter,
you simply do something like this:

<p>
<blockquote><pre>$ swig -tcl example.i
$ gcc example.c example_wrap.c \
        -Xlinker -export-dynamic \
        -DHAVE_CONFIG_H -I/usr/local/include/ \
	-L/usr/local/lib -ltcl -lm -ldl \
	-o mytclsh

</pre></blockquote>
You will need to supply the same libraries that were used to build Tcl the first
time.  This may include system libraries such as <tt>-lsocket</tt>, <tt>-lnsl</tt>,
and <tt>-lpthread</tt>.  If this actually works, the new version of Tcl
should be identical to the default version except that your extension module will be
a built-in part of the interpreter.

<p>

<b>Comment:</b> In practice, you should probably try to avoid static
linking if possible. Some programmers may be inclined
to use static linking in the interest of getting better performance.
However, the performance gained by static linking tends to be rather
minimal in most situations (and quite frankly not worth the extra
hassle in the opinion of this author). 

<h3> Using your module</h3>

To use your module, simply use the Tcl <tt>load</tt> command.  If
all goes well, you will be able to this:

<p>
<blockquote><pre>$ tclsh
% load ./example.so
% fact 4
24
%
</pre></blockquote>

A common error received by first-time users is the following:

<blockquote>
<pre>
% load ./example.so
couldn't find procedure Example_Init
% 
</pre>
</blockquote>

This error is almost always caused when the name of the shared object file doesn't
match the name of the module supplied using the SWIG <tt>%module</tt> directive.
Double-check the interface to make sure the module name and the shared object
file match.  Another possible cause of this error is forgetting to link the SWIG-generated
wrapper code with the rest of your application when creating the extension module.

<p>
Another common error is something similar to the following:

<blockquote>
<pre>
% load ./example.so
couldn't load file "./example.so": ./example.so: undefined symbol: fact
% 
</pre>
</blockquote>

This error usually indicates that you forgot to include some object
files or libraries in the linking of the shared library file.  Make
sure you compile both the SWIG wrapper file and your original program
into a shared library file.  Make sure you pass all of the required libraries
to the linker.  

<p>
Sometimes unresolved symbols occur because a wrapper has been created
for a function that doesn't actually exist in a library.  This usually
occurs when a header file includes a declaration for a function that
was never actually implemented or it was removed from a library
without updating the header file.  To fix this, you can either edit
the SWIG input file to remove the offending declaration or you can use
the <tt>%ignore</tt> directive to ignore the declaration.

<p>
Finally, suppose that your extension module is linked with another library like this:

<blockquote>
<pre>
$ gcc -shared example.o example_wrap.o -L/home/beazley/projects/lib -lfoo \
      -o example.so
</pre>
</blockquote>

If the <tt>foo</tt> library is compiled as a shared library, you might get the following
problem when you try to use your module:

<blockquote>
<pre>
% load ./example.so
couldn't load file "./example.so": libfoo.so: cannot open shared object file:
No such file or directory
%        
</pre>
</blockquote>

This error is generated because the dynamic linker can't locate the
<tt>libfoo.so</tt> library.  When shared libraries are loaded, the
system normally only checks a few standard locations such as
<tt>/usr/lib</tt> and <tt>/usr/local/lib</tt>.   To fix this problem,
there are several things you can do.  First, you can recompile your extension
module with extra path information. For example, on Linux you can do this:

<blockquote>
<pre>
$ gcc -shared example.o example_wrap.o -L/home/beazley/projects/lib -lfoo \
      -Xlinker -rpath /home/beazley/projects/lib \
      -o example.so
</pre>
</blockquote>

Alternatively, you can set the <tt>LD_LIBRARY_PATH</tt> environment variable to
include the directory with your shared libraries. 
If setting <tt>LD_LIBRARY_PATH</tt>, be aware that setting this variable can introduce
a noticeable performance impact on all other applications that you run.
To set it only for Tcl, you might want to do this instead:

<blockquote>
<pre>
$ env LD_LIBRARY_PATH=/home/beazley/projects/lib tclsh
</pre>
</blockquote>

Finally, you can use a command such as <tt>ldconfig</tt> to add additional search paths
to the default system configuration (this requires root access and you will need to read
the man pages). 

<h3>Compilation of C++ extensions</h3>

Compilation of C++ extensions has traditionally been a tricky problem.
Since the Tcl interpreter is written in C, you need to take steps to
make sure C++ is properly initialized and that modules are compiled
correctly.

<p>
On most machines, C++ extension modules should be linked using the C++
compiler.  For example:

<p>
<blockquote><pre>% swig -c++ -tcl example.i
% g++ -c example.cxx
% g++ -c example_wrap.cxx -I/usr/local/include
% g++ -shared example.o example_wrap.o -o example.so
</pre></blockquote>

In addition to this, you may need to include additional library
files to make it work.  For example, if you are using the Sun C++ compiler on
Solaris, you often need to add an extra library <tt>-lCrun</tt> like this:

<p>
<blockquote><pre>% swig -c++ -tcl example.i
% CC -c example.cxx
% CC -c example_wrap.cxx -I/usr/local/include
% CC -G example.o example_wrap.o -L/opt/SUNWspro/lib -o example.so -lCrun
</pre></blockquote>

Of course, the extra libraries to use are completely non-portable---you will 
probably need to do some experimentation.

<p>
Sometimes people have suggested that it is necessary to relink the
Tcl interpreter using the C++ compiler to make C++ extension modules work.
In the experience of this author, this has never actually appeared to be
necessary.   Relinking the interpreter with C++ really only includes the 
special run-time libraries described above---as long as you link your extension 
modules with these libraries, it should not be necessary to rebuild Tcl.

<p>
If you aren't entirely sure about the linking of a C++ extension, you
might look at an existing C++ program.  On many Unix machines, the
<tt>ldd</tt> command will list library dependencies.  This should give
you some clues about what you might have to include when you link your
extension module. For example:

<blockquote>
<pre>
$ ldd swig
        libstdc++-libc6.1-1.so.2 => /usr/lib/libstdc++-libc6.1-1.so.2 (0x40019000)
        libm.so.6 => /lib/libm.so.6 (0x4005b000)
        libc.so.6 => /lib/libc.so.6 (0x40077000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
$
</pre>
</blockquote>

<p>
As a final complication, a major weakness of C++ is that it does not
define any sort of standard for binary linking of libraries.  This
means that C++ code compiled by different compilers will not link
together properly as libraries nor is the memory layout of classes and
data structures implemented in any kind of portable manner.  In a
monolithic C++ program, this problem may be unnoticed.  However, in Tcl, it
is possible for different extension modules to be compiled with
different C++ compilers.  As long as these modules are self-contained,
this probably won't matter.  However, if these modules start sharing data,
you will need to take steps to avoid segmentation faults and other
erratic program behavior.   If working with lots of software components, you
might want to investigate using a more formal standard such as COM.

<h3>Compiling for 64-bit platforms</h3>

On platforms that support 64-bit applications (Solaris, Irix, etc.),
special care is required when building extension modules.  On these
machines, 64-bit applications are compiled and linked using a different
set of compiler/linker options.  In addition, it is not generally possible to mix 
32-bit and 64-bit code together in the same application.

<p>
To utilize 64-bits, the Tcl executable will need to be recompiled
as a 64-bit application.  In addition, all libraries, wrapper code,
and every other part of your application will need to be compiled for
64-bits.  If you plan to use other third-party extension modules, they
will also have to be recompiled as 64-bit extensions.

<p>
If you are wrapping commercial software for which you have no source
code, you will be forced to use the same linking standard as used by
that software.  This may prevent the use of 64-bit extensions.  It may
also introduce problems on platforms that support more than one
linking standard (e.g., -o32 and -n32 on Irix).

<h3>Setting a package prefix</h3>

To avoid namespace problems, you can instruct SWIG to append a package
prefix to all of your functions and variables. This is done using the
-prefix option as follows :<p>
<p>
<blockquote><pre>swig -tcl -prefix Foo example.i

</pre></blockquote>
If you have a function "<tt>bar</tt>" in the SWIG file, the prefix
option will append the prefix to the name when creating a command and
call it "<tt>Foo_bar</tt>". <p>

<h3>Using namespaces</h3>

Alternatively, you can have SWIG install your module into a Tcl
namespace by specifying the <tt>-namespace</tt> option :<p>
<p>
<blockquote><pre>swig -tcl -namespace example.i

</pre></blockquote>
By default, the name of the namespace will be the same as the module
name, but you can override it using the <tt>-prefix</tt> option.<p>
<p>
When the<tt> -namespace</tt> option is used, objects in the module
are always accessed with the namespace name such as <tt>Foo::bar</tt>.

<h2> Building Tcl/Tk Extensions under Windows 95/NT</h2>

Building a SWIG extension to Tcl/Tk under Windows 95/NT is roughly
similar to the process used with Unix.  Normally, you will want to
produce a DLL that can be loaded into tclsh or wish.  This section
covers the process of using SWIG with Microsoft Visual C++.
although the procedure may be similar with other compilers.<p>

<h3> Running SWIG from Developer Studio</h3>

If you are developing your application within Microsoft developer
studio, SWIG can be invoked as a custom build option.  The process
roughly follows these steps :<p>

<p>
<ul>
<li>Open up a new workspace and use the AppWizard to select a DLL project.

<li>Add both the SWIG interface file (the .i file), any supporting C
files, and the name of the wrapper file that will be created by SWIG
(ie. <tt>example_wrap.c</tt>).  Note : If using C++, choose a
different suffix for the wrapper file such as
<tt>example_wrap.cxx</tt>. Don't worry if the wrapper file doesn't
exist yet--Developer studio will keep a reference to it around.

<li>Select the SWIG interface file and go to the settings menu.  Under
settings, select the "Custom Build" option.

<li>Enter "SWIG" in the description field.

<li>Enter "<tt>swig -tcl -o $(ProjDir)\$(InputName)_wrap.c
$(InputPath)</tt>" in the "Build command(s) field"

<li>Enter "<tt>$(ProjDir)\$(InputName)_wrap.c</tt>" in the "Output files(s) field".

<li>Next, select the settings for the entire project and go to
"C++:Preprocessor". Add the include directories for your Tcl
installation under "Additional include directories".

<li>Finally, select the settings for the entire project and go to
"Link Options".  Add the Tcl library file to your link libraries.  For
example "<tt>tcl80.lib</tt>".  Also, set the name of the output file
to match the name of your Tcl module (ie. example.dll).

<li>Build your project.
</ul>
<p>
Now, assuming all went well, SWIG will be automatically invoked when
you build your project.  Any changes made to the interface file will
result in SWIG being automatically invoked to produce a new version of
the wrapper file.  To run your new Tcl extension, simply run
<tt>tclsh</tt> or <tt>wish</tt> and use the <tt>load</tt> command.
For example :<p>

<p>
<blockquote><pre>

MSDOS &gt; tclsh80
% load example.dll
% fact 4
24
%
</pre></blockquote>

<h3> Using NMAKE</h3>
Alternatively, SWIG extensions can be built by writing a Makefile for
NMAKE.  To do this, make sure the environment variables for MSVC++ are
available and the MSVC++ tools are in your path.  Now, just write a
short Makefile like this :<p>
<p>
<blockquote><pre># Makefile for building various SWIG generated extensions

SRCS          = example.c
IFILE         = example
INTERFACE     = $(IFILE).i
WRAPFILE      = $(IFILE)_wrap.c

# Location of the Visual C++ tools (32 bit assumed)

TOOLS         = c:\msdev
TARGET        = example.dll
CC            = $(TOOLS)\bin\cl.exe
LINK          = $(TOOLS)\bin\link.exe
INCLUDE32     = -I$(TOOLS)\include
MACHINE       = IX86

# C Library needed to build a DLL

DLLIBC        = msvcrt.lib oldnames.lib  

# Windows libraries that are apparently needed
WINLIB        = kernel32.lib advapi32.lib user32.lib gdi32.lib comdlg32.lib 
winspool.lib

# Libraries common to all DLLs
LIBS          = $(DLLIBC) $(WINLIB) 

# Linker options
LOPT      = -debug:full -debugtype:cv /NODEFAULTLIB /RELEASE /NOLOGO /
MACHINE:$(MACHINE) -entry:_DllMainCRTStartup@12 -dll

# C compiler flags

CFLAGS    = /Z7 /Od /c /nologo
TCL_INCLUDES  = -Id:\tcl8.0a2\generic -Id:\tcl8.0a2\win
TCLLIB        = d:\tcl8.0a2\win\tcl80.lib

tcl::
	..\..\swig -tcl -o $(WRAPFILE) $(INTERFACE)
	$(CC) $(CFLAGS) $(TCL_INCLUDES) $(SRCS) $(WRAPFILE)
	set LIB=$(TOOLS)\lib
	$(LINK) $(LOPT) -out:example.dll $(LIBS) $(TCLLIB) example.obj example_wrap.obj

</pre></blockquote>
To build the extension, run NMAKE (you may need to run vcvars32
first).  This is a pretty minimal Makefile, but hopefully its enough
to get you started.  With a little practice, you'll be making lots of
Tcl extensions.<p>

<h2>Primitive Tcl Interface</h2>

This section describes the basic Tcl interface.   The object-based interface is described shortly.

<h3> Functions</h3>

C functions are turned into new Tcl commands with the same usage as
the C function. Default/optional arguments are also allowed. An
interface file like this :<p>

<p>
<blockquote><pre>%module example
int foo(int a);
double bar (double, double b = 3.0);
...

</pre></blockquote>
Will be used in Tcl like this :<p>
<p>
<blockquote><pre>set a [foo 2]
set b [bar 3.5 -1.5]
set b [bar 3.5]              # Note : default argument is used 

</pre></blockquote>

There isn't much more to say...this is pretty straightforward.<p>

<h3> Global variables</h3>

For global variables, SWIG uses Tcl's variable tracing mechanism to
provide direct access.  For example:

<p>
<blockquote><pre>// example.i
%module example
...
double My_variable;
...

# Tcl script
puts $My_variable            # Output value of C global variable
set My_variable 5.5          # Change the value

</pre></blockquote>

<b>Compatibility Note:</b> 
Variable tracing is currently supported for all C/C++ datatypes.  In older versions
of SWIG, only variables of type <tt>int</tt>, <tt>double</tt>, and <tt>char *</tt> could
be linked.  All other types were accessed using special function calls.   

<h3> Constants</h3>

Constants are installed as new Tcl variables. For example:

<blockquote>
<pre>
%module example
#define FOO 42
</pre>
</blockquote>

is accessed as follows:

<blockquote>
<pre>
% puts $FOO
42
%
</pre>
</blockquote>

No attempt is made to enforce the read-only nature of a constant.  Therefore, a user could reassign the value if they wanted.
You will just have to be careful.
<p>
A peculiarity of installing constants as variables is that it is necessary to use the Tcl <tt>global</tt> statement to
access constants in procedure bodies.  For example:

<blockquote>
<pre>
proc blah {} {
   global FOO
   bar $FOO
}
</pre>
</blockquote>

If a program relies on a lot of constants, this can be extremely annoying.  To fix the problem, consider using the
following typemap rule:

<blockquote>
<pre>
%apply int CONSTANT { int x };
#define FOO 42
...
void bar(int x);
</pre>
</blockquote>

When applied to an input argument, the <tt>CONSTANT</tt> rule allows a constant to be passed to a function using
its actual value or a symbolic identifier name.  For example:

<blockquote>
<pre>
proc blah {} {
   bar FOO
}
</pre>
</blockquote>

When an identifier name is given, it is used to perform an implicit hash-table lookup of the value during argument 
conversion.  This allows the <tt>global</tt> statement to be ommitted.

<h3> Pointers</h3>

Pointers to C/C++ objects are represented as character strings such as
the following :<p>
<p>
<blockquote><pre>_100f8e2_p_Vector

</pre></blockquote>
A NULL pointer is represented by the string "NULL". NULL pointers can also be explicitly created as follows :<p>
<p>
<blockquote><pre>_0_p_Vector

</pre></blockquote>


As much as you might be inclined to modify a pointer value directly
from Tcl, don't.  The hexadecimal encoding is not necessarily the same
as the logical memory address of the underlying object.  Instead it is
the raw byte encoding of the pointer value.  The encoding will vary
depending on the native byte-ordering of the platform (i.e.,
big-endian vs. little-endian).  Similarly, don't try to manually cast
a pointer to a new type by simply replacing the type-string.  This is
may not work like you expect and it is particularly dangerous when
casting C++ objects.  If you need to cast a pointer or change its
value, consider writing some helper functions instead.  For example:

<blockquote>
<pre>
%inline %{
/* C-style cast */
Bar *FooToBar(Foo *f) {
   return (Bar *) f;
}

/* C++-style cast */
Foo *BarToFoo(Bar *b) {
   return dynamic_cast&lt;Foo*&gt;(b);
}

Foo *IncrFoo(Foo *f, int i) {
    return f+i;
}
%}
</pre>
</blockquote>

If you need to type-cast a lot of objects, it may indicate a serious 
weakness in your design.  Also, if working with C++, you should always try
to use the new C++ style casts.  For example, in the above code, the
C-style cast may return a bogus result whereas as the C++-style cast will return
<tt>NULL</tt> if the conversion can't be performed.

<h3> Structures </h3>

SWIG generates a basic low-level interface to C structures. For
example :<p>

<p>
<blockquote><pre>struct Vector {
	double x,y,z;
};

</pre></blockquote>
gets mapped into the following collection of C functions :<p>
<p>
<blockquote><pre>double Vector_x_get(Vector *obj)
double Vector_x_set(Vector *obj, double x)
double Vector_y_get(Vector *obj)
double Vector_y_set(Vector *obj, double y)
double Vector_z_get(Vector *obj)
double Vector_z_set(Vector *obj, double z)

</pre></blockquote>

These functions are then used in the resulting Tcl interface. For
example :<p>

<p>
<blockquote><pre># v is a Vector that got created somehow
% Vector_x_get $v
3.5
% Vector_x_set $v 7.8            # Change x component
</pre></blockquote>

<p>
Similar access is provided for unions and the data members of C++ classes.<p>

<h3> C++ Classes</h3>

C++ classes are handled by building a set of low level accessor
functions. Consider the following class :<p>
<p>
<blockquote><pre>
class List {
public:
  List();
  ~List();
  int  search(char *item);
  void insert(char *item);
  void remove(char *item);
  char *get(int n);
  int  length;
static void print(List *l);
};
</pre></blockquote>

<p>
When wrapped by SWIG, the following functions are created :<p>

<p>
<blockquote><pre>List    *new_List();
void     delete_List(List *l);
int      List_search(List *l, char *item);
void     List_insert(List *l, char *item);
void     List_remove(List *l, char *item);
char    *List_get(List *l, int n);
int      List_length_get(List *l);
int      List_length_set(List *l, int n);
void     List_print(List *l);

</pre></blockquote>

Within Tcl, we can use the functions as follows :<p>

<blockquote><pre>
% set l [new_List]
% List_insert $l Ale
% List_insert $l Stout
% List_insert $l Lager
% List_print $l
Lager
Stout
Ale
% puts [List_length_get $l]
3
% puts $l
_1008560_p_List
% 

</pre></blockquote>
C++ objects are really just pointers (which are represented as
strings). Member functions and data are accessed by simply passing a
pointer into a collection of accessor functions that take the pointer
as the first argument.<p>

<p>
While somewhat primitive, the low-level SWIG interface provides direct
and flexible access to almost any C++ object. As it turns out, it is
possible to do some rather amazing things with this interface as will
be shown in some of the later examples. SWIG also generates an
object-based interface that can be used in addition to the basic
interface just described here.<p>

<h2>The object-based interface</h2>

In addition to the low-level accessors, SWIG also generates an object-based interface to C 
structures and C++
classes. This interface supplements the low-level SWIG
interface already defined--in fact, both can be used
simultaneously. To illustrate this interface, consider the previous
<tt>List</tt> class :<p>

<p>
<blockquote><pre>class List {
public:
  List();
  ~List();
  int  search(char *item);
  void insert(char *item);
  void remove(char *item);
  char *get(int n);
  int  length;
static void print(List *l);
};

</pre></blockquote>
Using the object oriented interface requires no additional
modifications or recompilation of the SWIG module (the functions are
just used differently).<p>

<h3> Creating new objects</h3>

The name of the class becomes a new command for creating an
object. There are 5 methods for creating an object (<tt>MyObject
</tt>is the name of the corresponding C++ class) <p>

<p>
<blockquote><pre>MyObject o                   # Creates a new object named `o' 

MyObject o -this $objptr     # Turn a pointer to an existing C++ object into a 
                             # Tcl object named `o'

MyObject -this $objptr       # Turn the pointer $objptr into a Tcl "object"

MyObject -args args          # Create a new object and pick a name for it. A handle
                             # will be returned and is the same as the pointer value.

MyObject                     # The same as MyObject -args, but for constructors that
                             # take no arguments.
</pre></blockquote>

<p>
Thus, for our List class, you can create new List objects as follows :<p>

<p>
<blockquote><pre>List l                       # Create a new list l

set listptr [new_List]       # Create a new List using low level interface
List l2 -this $listptr       # Turn it into a List object named `l2'

set l3 [List]                # Create a new list. The name of the list is in $l3

List -this $listptr          # Turn $listptr into a Tcl object of the same name
</pre></blockquote>

<p>
Assuming you're not completely confused at this point, the best
way to think of this is that there are really two different ways of
representing an object.  One approach is to simply use the pointer
value as the name of an object. For example :<p>
<p>
<blockquote><pre>_100e8f8_p_List

</pre></blockquote>

The second approach is to allow you to pick a name for an object such
as "foo".  The different types of constructors are really just
a mechanism for using either approach.<p>

<h3> Invoking member functions</h3>

Member functions are invoked using the name of the object followed by
the method name and any arguments. For example :<p>

<p>
<blockquote><pre>% List l
% l insert "Bob"
% l insert "Mary"
% l search "Dave"
0
% ...

</pre></blockquote>

Or if you let SWIG generate the name of the object, it works like this:

<p>
<blockquote><pre>% set l [List]
% $l insert "Bob"            # Note $l contains the name of the object
% $l insert "Mary"
% $l search "Dave"
0
%
</pre></blockquote>

<h3>Deleting objects</h3>

Since objects are created by adding new Tcl commands, they can be
deleted by simply renaming them. For example :<p>

<p>
<blockquote><pre>% rename l ""                # Destroy list object `l'
</pre></blockquote>

It is also possible to explicitly delete the object using the delete method.
For example:

<blockquote>
<pre>
% l -delete
</pre>
</blockquote>

If applicable, SWIG will automatically call the corresponding C/C++ destructor
when the object is destroyed.

<h3> Accessing member data</h3>

Member data of an object can be accessed using the <tt>cget</tt>
method. The approach is quite similar to that used in [incr Tcl] and
other Tcl extensions. For example :<p>

<p>
<blockquote><pre>% l cget -length             # Get the length of the list
13

</pre></blockquote>

The <tt>cget</tt> method currently only allows retrieval of one member
at a time. Extracting multiple members will require repeated calls.<p>
<p>
The member <tt>-this</tt> contains the pointer to the object that is
compatible with other SWIG functions. Thus, the following call would
be legal<p>
<p>
<blockquote><pre>
% List l                            # Create a new list object
% l insert Mike
% List_print [l cget -this]         # Print it out using low-level function
</pre></blockquote>

<h3> Changing member data</h3>

To change the value of member data, the <tt>configure</tt> method can be used. For example :<p>
<p>
<blockquote><pre>% l configure -length 10     # Change length to 10 (probably not a good idea, but
                             # possible).

</pre></blockquote>
In a structure such as the following :<p>
<blockquote><pre>
struct Vector {
	double x, y, z;
};

</pre></blockquote>
you can change the value of all or some of the members as follows :<p>
<p>
<blockquote><pre>% v configure -x 3.5 -y 2 -z -1.0
</pre></blockquote>
<p>
The order of attributes does not matter.  <p>

<h3> Managing Object Ownership</h3>

By default, objects created from Tcl are owned by the Tcl interpreter and
are automatically destroyed when the correponding Tcl variable goes out of scope.
However, sometimes it is necessary to change the owneship of an object
managed by the interpreter.  For instance, if you stored an object in another data structure, you
might want Tcl to disown the object.  Similarly, it may make sense for Tcl to acquire ownership of
an object returned by C.

<p>
To handle object ownership, two object methods are available:

<blockquote>
<pre>
% obj -disown            # Release ownership
% obj -acquire           # Acquire ownership
</pre>
</blockquote>

When Tcl owns an object, it is released when the Tcl variable is destroyed.  Otherwise,
the Tcl variable is destroyed without calling the corresponding C/C++ destructor.

<h3> Relationship with pointers</h3>
The object oriented interface is mostly compatible with all of the
functions that accept pointer values as arguments. Here are a couple
of things to keep in mind :<p>

<p>
<ul>
<li>If you explicitly gave a name to an object, the pointer value can
be retrieved using the `<tt>cget -this</tt>' method. The pointer value
is what you should give to other SWIG generated functions if
necessary.

<li>If you let SWIG generate the name of an object for you, then the
name of the object is the same as the pointer value. This is the
preferred approach.

<li>If you have a pointer value but it's not a Tcl object, you can
turn it into one by calling the constructor with the `<tt>-this</tt>'
option.

</ul>
<p>
Here is a script that illustrates how these things work :<p>
<p>
<blockquote><pre># Example 1 : Using a named object

List l                       # Create a new list
l insert Dave                # Call some methods
l insert Jane	
l insert Pat
List_print [l cget -this]    # Call a static method (which requires the pointer value)

# Example 2: Let SWIG pick a name

set l [List]                 # Create a new list
$l insert Dave               # Call some methods
$l insert Jane
$l insert Pat
List_print $l                # Call static method (name of object is same as pointer)

# Example 3: Already existing object
set l [new_List]             # Create a raw object using low-level interface
List_insert $l Dave          # Call some methods (using low-level functions)
List -this $l                # Turn it into a Tcl object instead
$l insert Jane
$l insert Part
List_print $l                # Call static method (uses pointer value as before).
</pre></blockquote>
<p>


<hr>
<h4>Everything from this point on is out of date-- in progress</h4>

<h2>Examples</h2>

<h2> Accessing arrays</h2>

In some cases, C functions may involve arrays and other objects.  In
these instances, you may have to write helper functions to provide
access.  For example, suppose you have a C function like this :<p>
<p>
<blockquote><pre>// Add vector a+b -&gt; c
void vector_add(double *a, double *b, double *c, int size);

</pre></blockquote>

SWIG is quite literal in its interpretation of <tt>double *</tt>--it
is a pointer to a <tt>double</tt>. To provide access, a few helper
functions can be written such as the following :<p>

<p>
<blockquote><pre>// SWIG helper functions for double arrays
%inline %{
double *new_double(int size) {
	return (double *) malloc(size*sizeof(double));
}
void delete_double(double *a) {
	free a;
}
double get_double(double *a, int index) {
	return a[index];
}
void set_double(double *a, int index, double val) {
	a[index] = val;
}
%}
</pre></blockquote>
<p>
Using our C functions might work like this :<p>
<p>
<blockquote><pre># Tcl code to create some arrays and add them

set a [new_double 200]
set b [new_double 200]
set c [new_double 200]

# Fill a and b with some values
for {set i 0} {$i &lt; 200} {incr i 1} {
	set_double $a $i 0.0
	set_double $b $i $i
}

# Add them and store result in c
vector_add $a $b $c 200

</pre></blockquote>

The functions <tt>get_double</tt> and <tt>set_double</tt> can be used
to access individual elements of an array.  To convert from Tcl lists
to C arrays, one could write a few functions in Tcl such as the
following :<p>
<p>
<blockquote><pre># Tcl Procedure to turn a list into a C array
proc Tcl2Array {l} {
	set len [llength $l]
	set a [new_double $len]
	set i 0
	foreach item $l {
		set_double $a $i $item
		incr i 1
	}
	return $a
}

# Tcl Procedure to turn a C array into a Tcl List
proc Array2Tcl {a size} {
	set l {}
	for {set i 0} {$i &lt; size} {incr i 1} {
		lappend $l [get_double $a $i]
	}
	return $l
}

</pre></blockquote>

While not optimal, one could use these to turn a Tcl list into a C
representation.  The C representation could be used repeatedly in a
variety of C functions without having to repeatedly convert from
strings (Of course, if the Tcl list changed one would want to update
the C version).  Likewise, it is relatively simple to go back from C
into Tcl.  This is not the only way to manage arrays--typemaps can be
used as well.  The SWIG library file `<tt>array.i</tt>' also contains
a variety of pre-written helper functions for managing different kinds
of arrays.<p>

<h2> Exception handling </h2>

The <tt>%except</tt> directive can be used to create a user-definable
exception handler in charge of converting exceptions in your C/C++
program into Tcl exceptions.  The chapter on exception handling
contains more details, but suppose you extended the array example into
a C++ class like the following :<p>

<blockquote><pre>
class RangeError {};   // Used for an exception

class DoubleArray {
  private:
    int n;
    double *ptr;
  public:
    // Create a new array of fixed size
    DoubleArray(int size) {
      ptr = new double[size];
      n = size;
    }
    // Destroy an array
    ~DoubleArray() {
       delete ptr;
    }
    // Return the length of the array
    int   length() {
      return n;
    }

    // Get an item from the array and perform bounds checking.
    double getitem(int i) {
      if ((i &gt;= 0) &amp;&amp; (i &lt; n))
        return ptr[i];
      else
        throw RangeError();
    }

    // Set an item in the array and perform bounds checking.
    void setitem(int i, double val) {
      if ((i &gt;= 0) &amp;&amp; (i &lt; n))
        ptr[i] = val;
      else {
        throw RangeError();
      }
    }
  };
</pre></blockquote>

<p>
The functions associated with this class can throw a C++ range
exception for an out-of-bounds array access.  We can catch this in our
Tcl extension by specifying the following in an interface file :<p>

<p>
<blockquote><pre>%except(tcl) {
  try {
    $function                // Gets substituted by actual function call
  }
  catch (RangeError) {
    interp-&gt;result = "Array index out-of-bounds";
    return TCL_ERROR;
  }
}

</pre></blockquote>
or in Tcl 8.0<p>
<p>
<blockquote><pre>%except(tcl8) {
  try {
    $function                // Gets substituted by actual function call
  }
  catch (RangeError) {
    Tcl_SetStringObj(tcl_result,"Array index out-of-bounds");
    return TCL_ERROR;
  }
}

</pre></blockquote>
When the C++ class throws a <tt>RangeError</tt> exception, our wrapper
functions will catch it, turn it into a Tcl exception, and allow a
graceful death as opposed to just having some sort of mysterious
program crash.  We are not limited to C++ exception handling.  Please
see the chapter on exception handling for more details on other
possibilities, including a method for language-independent exception
handling..<p>

<h2> Typemaps</h2>

This section describes how SWIG's treatment of various C/C++ datatypes
can be remapped using the <tt>%typemap</tt> directive.  While not
required, this section assumes some familiarity with Tcl's C API.  The
reader is advised to consult a Tcl book.  A glance at the chapter on
SWIG typemaps will also be useful.  <p>

<h3> What is a typemap?</h3>

A typemap is mechanism by which SWIG's processing of a particular C
datatype can be changed.  A simple typemap might look like this :<p>
<p>
<blockquote><pre>%module example

%typemap(tcl,in) int {
	$target = (int) atoi($source);
	printf("Received an integer : %d\n",$target);
}
...
extern int fact(int n);
</pre></blockquote>
<p>
Typemaps require a language name, method name, datatype, and
conversion code.  For Tcl, "tcl" should be used as the language name.
For Tcl 8.0, "tcl8" should be used if you are using the native object
interface. The "in" method in this example refers to an input argument
of a function. The datatype `int' tells SWIG that we are remapping
integers.  The supplied code is used to convert from a Tcl string to
the corresponding C datatype.  Within the supporting C code, the
variable <tt>$source</tt> contains the source data (a string in this
case) and <tt>$target</tt> contains the destination of a conversion (a
C local variable).  <p>
<p>
When the example is compiled into a Tcl module, it will operate as
follows :<p>
<p>
<blockquote><pre>% fact 6
Received an integer : 6
720
%
</pre></blockquote>
<p>
A full discussion of typemaps can be found in the main SWIG users
reference.  We will primarily be concerned with Tcl typemaps here.<p>

<h3> Tcl typemaps</h3>

The following typemap methods are available to Tcl modules :<p>

<p>
<tt>%typemap(tcl,in)</tt>	Converts a string to input function arguments<p>
<tt>%typemap(tcl,out)</tt>	Converts return value of a C function to a string<p>
<tt>%typemap(tcl,freearg)</tt>	Cleans up a function argument (if necessary)<p>
<tt>%typemap(tcl,argout)</tt>	Output argument processing<p>
<tt>%typemap(tcl,ret)</tt>	Cleanup of function return values<p>
<tt>%typemap(tcl,const)</tt>	Creation of Tcl constants<p>
<tt>%typemap(memberin)</tt>	Setting of C++ member data<p>
<tt>%typemap(memberout)</tt>	Return of C++ member data<p>
<tt>%typemap(tcl, check)</tt>	Check value of function arguments.<p>
<a name="n55"></a><h3> Typemap variables</h3>
The following variables may be used within the C code used in a typemap:<p>
<p>
<tt>$source</tt>	Source value of a conversion<p>
<tt>$target</tt>	Target of conversion (where the result should be stored)<p>
<tt>$type</tt>	C datatype being remapped<p>
<tt>$mangle</tt>	Mangled version of data (used for pointer type-checking)<p>
<tt>$value</tt>	Value of a constant (const typemap only)<p>
<tt>$arg</tt>	Original function argument (usually a string)<p>
<a name="n56"></a><h3> Name based type conversion</h3>
Typemaps are based both on the datatype and an optional name attached to a datatype.   For example :<p>
<p>
<blockquote><pre>%module foo

// This typemap will be applied to all char ** function arguments
%typemap(tcl,in) char ** { ... }

// This typemap is applied only to char ** arguments named `argv'
%typemap(tcl,in) char **argv { ... }

</pre></blockquote>

In this example, two typemaps are applied to the <tt>char **</tt>
datatype.  However, the second typemap will only be applied to
arguments named `<tt>argv</tt>'.  A named typemap will always override
an unnamed typemap.<p>

<p>
Due to the name-based nature of typemaps, it is important to note that
typemaps are independent of typedef declarations.  For example :<p>

<p>
<blockquote><pre>%typemap(tcl, in) double {
	... get a double ...
}
void foo(double);            // Uses the above typemap
typedef double Real;
void bar(Real);              // Does not use the above typemap (double != Real)

</pre></blockquote>

To get around this problem, the <tt>%apply</tt> directive can be used
as follows :<p>

<blockquote><pre>
%typemap(tcl,in) double {
	... get a double ...
}
void foo(double);

typedef double Real;         // Uses typemap
%apply double { Real };      // Applies all "double" typemaps to Real.
void bar(Real);              // Now uses the same typemap.
</pre></blockquote>

<h3> Converting  a Tcl list to a char ** </h3>

A common problem in many C programs is the processing of command line
arguments, which are usually passed in an array of NULL terminated
strings.  The following SWIG interface file allows a Tcl list to be
used as a <tt>char **</tt> object.<p>

<p>
<blockquote><pre>%module argv

// This tells SWIG to treat char ** as a special case
%typemap(tcl,in) char ** {
        int tempc;
        if (Tcl_SplitList(interp,$source,&amp;tempc,&amp;$target) == TCL_ERROR) 
		return TCL_ERROR;
}

// This gives SWIG some cleanup code that will get called after the function call
%typemap(tcl,freearg) char ** {
        free((char *) $source);
}

// Return a char ** as a Tcl list
%typemap(tcl,out) char ** {
        int i = 0;
        while ($source[i]) {
             Tcl_AppendElement(interp,$source[i]);
             i++;
        }
}

// Now a few test functions
%inline %{
int print_args(char **argv) {
    int i = 0;
    while (argv[i]) {
         printf("argv[%d] = %s\n", i,argv[i]);
         i++;
    }
    return i;
}


// Returns a char ** list
char **get_args() {
    static char *values[] = { "Dave", "Mike", "Susan", "John", "Michelle", 0};
    return &amp;values[0];
}

// A global variable
char *args[] = { "123", "54", "-2", "0", "NULL", 0 };

%}
%include tclsh.i

</pre></blockquote>

When compiled, we can use our functions as follows :<p>
<p>
<blockquote><pre>% print_args {John Guido Larry}
argv[0] = John
argv[1] = Guido
argv[2] = Larry
3
% puts [get_args]
Dave Mike Susan John Michelle
% puts [args_get]
123 54 -2 0 NULL
%
</pre></blockquote>

<p>
Perhaps the only tricky part of this example is the implicit memory
allocation that is performed by the <tt>Tcl_SplitList</tt> function.
To prevent a memory leak, we can use the SWIG "freearg" typemap to
clean up the argument value after the function call is made. In this
case, we simply free up the memory that <tt>Tcl_SplitList</tt>
allocated for us.<p>

<h3> Remapping constants</h3>

By default, SWIG installs C constants as Tcl read-only variables.
Unfortunately, this has the undesirable side effect that constants
need to be declared as "global" when used in subroutines.  For example
:<p>

<p>
<blockquote><pre>proc clearscreen { } {
	global GL_COLOR_BUFFER_BIT
	glClear $GL_COLOR_BUFFER_BIT
}

</pre></blockquote>

If you have hundreds of functions however, this quickly gets annoying.   Here's a fix using hash tables and SWIG typemaps :<p>

<p>
<blockquote><pre>// Declare some Tcl hash table variables
%{
static Tcl_HashTable  constTable;      /* Hash table          */
static int           *swigconst;       /* Temporary variable  */
static Tcl_HashEntry *entryPtr;        /* Hash entry          */
static int            dummy;           /* dummy value         */
%}

// Initialize the hash table (This goes in the initialization function)

%init %{
  Tcl_InitHashTable(&amp;constTable,TCL_STRING_KEYS);
%}

// A Typemap for creating constant values
// $source = the value of the constant
// $target = the name of the constant

%typemap(tcl,const) int, unsigned int, long, unsigned long {
  entryPtr = Tcl_CreateHashEntry(&amp;constTable,"$target",&amp;dummy);
  swigconst = (int *) malloc(sizeof(int));
  *swigconst = $source;
  Tcl_SetHashValue(entryPtr, swigconst);
  /* Make it so constants can also be used as variables */
  Tcl_LinkVar(interp,"$target", (char *) swigconst, TCL_LINK_INT | TCL_LINK_READ_ONLY);
};

// Now change integer handling to look for names in addition to values
%typemap(tcl,in) int, unsigned int, long, unsigned long {
  Tcl_HashEntry *entryPtr;
  entryPtr = Tcl_FindHashEntry(&amp;constTable,$source);
  if (entryPtr) {
    $target = ($type) (*((int *) Tcl_GetHashValue(entryPtr)));
  } else {
    $target = ($type) atoi($source);
  }
}

</pre></blockquote>
In our Tcl code, we can now access constants by name without using the
"global" keyword as follows :<p>
<p>
<blockquote><pre>proc clearscreen { } {
	glClear GL_COLOR_BUFFER_BIT
}

</pre></blockquote>

<h3> Returning values in arguments</h3>

The "argout" typemap can be used to return a value originating from a
function argument. For example :<p>

<p>
<blockquote><pre>// A typemap defining how to return an argument by appending it to the result
%typemap(tcl,argout) double *outvalue {
        char dtemp[TCL_DOUBLE_SPACE];
        Tcl_PrintDouble(interp,*($source),dtemp);
        Tcl_AppendElement(interp, dtemp);
}

// A typemap telling SWIG to ignore an argument for input
// However, we still need to pass a pointer to the C function
%typemap(tcl,ignore) double *outvalue {
	static double temp;         /* A temporary holding place */
	$target = &amp;temp;
}

// Now a function returning two values
int mypow(double a, double b, double *outvalue) {
        if ((a &lt; 0) || (b &lt; 0)) return -1;
        *outvalue = pow(a,b);
        return 0;
};

</pre></blockquote>
When wrapped, SWIG matches the <tt>argout</tt> typemap to the
"<tt>double *outvalue</tt>" argument. The "ignore" typemap tells SWIG
to simply ignore this argument when generating wrapper code.  As a
result, a Tcl function using these typemaps will work like this :<p>
<p>

<blockquote><pre>% mypow 2 3     # Returns two values, a status value and the result
0 8
%
</pre></blockquote>
<p>
An alternative approach to this is to return values in a Tcl variable
as follows :<p>

<p>
<blockquote><pre>%typemap(tcl,argout) double *outvalue {
	char temp[TCL_DOUBLE_SPACE];
	Tcl_PrintDouble(interp,*($source),dtemp);
	Tcl_SetVar(interp,$arg,temp,0);
}
%typemap(tcl,in) double *outvalue {
	static double temp;
	$target = &amp;temp;
}

</pre></blockquote>

Our Tcl script can now do the following :<p>

<p>
<blockquote><pre>% set status [mypow 2 3 a]
% puts $status
0
% puts $a
8.0
%
</pre></blockquote>

Here, we have passed the name of a Tcl variable to our C wrapper
function which then places the return value in that variable.  This is
now very close to the way in which a C function calling this function
would work.<p>

<h3> Mapping C structures into Tcl Lists</h3>

Suppose you have a C structure like this :<p>
<p>
<blockquote><pre>typedef struct {
  char  login[16];            /* Login ID  */
  int   uid;                  /* User ID   */
  int   gid;                  /* Group ID  */
  char  name[32];             /* User name */
  char  home[256];            /* Home directory */
} User;

</pre></blockquote>

By default, SWIG will simply treat all occurrences of "<tt>User</tt>"
as a pointer.  Thus, functions like this :<p>

<p>
<blockquote><pre>extern void add_user(User u);
extern User *lookup_user(char *name);

</pre></blockquote>

will work, but they will be weird.  In fact, they may not work at all
unless you write helper functions to create users and extract data.  A
typemap can be used to fix this problem however.  For example :<p>

<p>
<blockquote><pre>// This works for both "User" and "User *"
%typemap(tcl,in) User * {
	int tempc;
	char **tempa;
	static User temp;
	if (Tcl_SplitList(interp,$source,&amp;tempc,&amp;tempa) == TCL_ERROR) return TCL_ERROR;
	if (tempc != 5) {
		free((char *) tempa);
		interp-&gt;result = "Not a valid User record";
		return TCL_ERROR;
	}
	/* Split out the different fields */
	strncpy(temp.login,tempa[0],16);
	temp.uid = atoi(tempa[1]);
	temp.gid = atoi(tempa[2]);
	strncpy(temp.name,tempa[3],32);
	strncpy(temp.home,tempa[4],256);
	$target = &amp;temp;
	free((char *) tempa);
}

// Describe how we want to return a user record
%typemap(tcl,out) User * {
	char temp[20];
	if ($source) {
	Tcl_AppendElement(interp,$source-&gt;login);
	sprintf(temp,"%d",$source-&gt;uid);
	Tcl_AppendElement(interp,temp);
	sprintf(temp,"%d",$source-&gt;gid);
	Tcl_AppendElement(interp,temp);
	Tcl_AppendElement(interp,$source-&gt;name);
	Tcl_AppendElement(interp,$source-&gt;home);
	}
}
</pre></blockquote>
<p>
These function marshall Tcl lists to and from our <tt>User</tt> data
structure. This allows a more natural implementation that we can use
as follows :<p>
<p>

<blockquote><pre>% add_user {beazley 500 500 "Dave Beazley" "/home/beazley"}
% lookup_user beazley
beazley 500 500 {Dave Beazley} /home/beazley

</pre></blockquote>
This is a much cleaner interface (although at the cost of some
performance). The only caution I offer is that the pointer view of the
world is pervasive throughout SWIG. Remapping complex datatypes like
this will usually work, but every now and then you might find that it
breaks. For example, if we needed to manipulate arrays of Users (also
mapped as a "<tt>User *</tt>"), the typemaps defined here would break
down and something else would be needed.  Changing the representation
in this manner may also break the object-oriented interface. <p>

<h3> Useful functions</h3>

The following tables provide some functions that may be useful in
writing Tcl typemaps. Both Tcl 7.x and Tcl 8.x are covered.  For Tcl
7.x, everything is a string so the interface is relatively simple. For
Tcl 8, everything is now a Tcl object so a more precise set of
functions is required. Given the alpha-release status of Tcl 8, the
functions described here may change in future releases.<p>

<p>
<b>Integers</b>

<blockquote>
<pre>
Tcl_Obj   *Tcl_NewIntObj(int Value);
void       Tcl_SetIntObj(Tcl_Obj *obj, int Value);
int        Tcl_GetIntFromObj(Tcl_Interp *, Tcl_Obj *obj, int *ip);
</pre>
</blockquote>

<b>Floating Point</b>

<blockquote>
<pre>
Tcl_Obj  *Tcl_NewDoubleObj(double Value);
void      Tcl_SetDoubleObj(Tcl_Obj *obj, double value);
int       Tcl_GetDoubleFromObj(Tcl_Interp *, Tcl_Obj *o, double *dp);
</pre>
</blockquote>

<b>Strings</b>

<blockquote>
<pre>
Tcl_Obj  *Tcl_NewStringObj(char *str, int len);
void      Tcl_SetStringObj(Tcl_Obj *obj, char *str, int len);
char     *Tcl_GetStringFromObj(Tcl_Obj *obj, int *len);
void      Tcl_AppendToObj(Tcl_Obj *obj, char *str, int len);
</pre>
</blockquote>

<b>Lists</b>

<blockquote>
<pre>
Tcl_Obj  *Tcl_NewListObj(int objc, Tcl_Obj *objv);
int       Tcl_ListObjAppendList(Tcl_Interp *, Tcl_Obj *listPtr, Tcl_Obj *elemListPtr);
int       Tcl_ListObjAppendElement(Tcl_Interp *, Tcl_Obj *listPtr, Tcl_Obj *element);
int       Tcl_ListObjGetElements(Tcl_Interp *, Tcl_Obj *listPtr, int *objcPtr, Tcl_Obj ***objvPtr);
int       Tcl_ListObjLength(Tcl_Interp *, Tcl_Obj *listPtr, int *intPtr);
int       Tcl_ListObjIndex(Tcl_Interp *, Tcl_Obj *listPtr, int index, Tcl_Obj_Obj **objptr);
int       Tcl_ListObjReplace(Tcl_Interp *, Tcl_Obj *listPtr, int first, int count, int objc, Tcl_Obj *objv);
</pre>
</blockquote>

<b>Objects</b>

<blockquote>
<pre>
Tcl_Obj *Tcl_DuplicateObj(Tcl_Obj *obj);
void     Tcl_IncrRefCount(Tcl_Obj *obj);
void     Tcl_DecrRefCount(Tcl_Obj *obj);
int      Tcl_IsShared(Tcl_Obj *obj);
</pre>
</blockquote>

<h3> Standard  typemaps</h3>

The following typemaps show how to convert a few common kinds of
objects between Tcl and C (and to give a better idea of how typemaps
work)<p>


<b>Integer conversion</b>

<blockquote>
<pre>
%typemap(in) int, short, long {
   int temp;
   if (Tcl_GetIntFromObj(interp, $input, &temp) == TCL_ERROR)
      return TCL_ERROR;
   $1 = ($1_ltype) temp;
}
</pre>
</blockquote>

<p>
<blockquote>
<pre>
%typemap(out) int, short, long {
   Tcl_SetIntObj($result,(int) $1);
}
</pre>
</blockquote>

<b>Floating point conversion</b>

<blockquote>
<pre>
%typemap(in) float, double {
   double temp;
   if (Tcl_GetDoubleFromObj(interp, $input, &temp) == TCL_ERROR)
       return TCL_ERROR;
   $1 = ($1_ltype) temp;
}
</pre>
</blockquote>

<p>
<blockquote>
<pre>
%typemap(out) float, double {
   Tcl_SetDoubleObj($result, $1);
}
</pre>
</blockquote>

<b>String Conversion</b>

<blockquote>
<pre>
%typemap(in) char * {
   int len;
   $1 = Tcl_GetStringFromObj(interp, &len);
   }
}
</pre>
</blockquote>

<p>
<blockquote>
<pre>
%typemap(out) char * {
   Tcl_SetStringObj($result,$1);
}
</pre>
</blockquote>

<h3> Pointer handling</h3>

<b>REWRITE THIS!</B>
<p>

SWIG pointers are mapped into Python strings containing the
hexadecimal value and type.  The following functions can be used to
create and read pointer values.<p>

<p>
These functions can be used in typemaps as well. For example, the
following typemap makes an argument of "<tt>char *buffer</tt>" accept
a pointer instead of a NULL-terminated ASCII string.<p>

<p>
<blockquote><pre>%typemap(tcl,in) char *buffer {
	if (SWIG_GetPtr($source, (void **) &amp;$target, "$mangle")) {
		Tcl_SetResult(interp,"Type error. Not a pointer", TCL_STATIC);
		return TCL_ERROR;
	}
}

</pre></blockquote>
Note that the <tt>$mangle</tt> variable generates the type string
associated with the datatype used in the typemap.<p>
<p>
By now you hopefully have the idea that typemaps are a powerful
mechanism for building more specialized applications.  While writing
typemaps can be technical, many have already been written for you.
See the SWIG library reference for more information.<p>

<h2> Configuration management with SWIG</h2>

After you start to work with Tcl for awhile, you suddenly realize that
there are an unimaginable number of extensions, tools, and other
packages.  To make matters worse, there are about 20 billion different
versions of Tcl, not all of which are compatible with each extension
(this is to make life interesting of course).<p>
<p>
While SWIG is certainly not a magical solution to the configuration
management problem, it can help out alot in a number of key areas :<p>
<p>

<ul>
<li>SWIG generated code can be used with all versions of Tcl/Tk newer
than 7.3/3.6. This includes the Tcl Netscape Plugin and Tcl 8.0a2.

<li>The SWIG library mechanism can be used to manage various code
fragments and initialization functions.

<li>SWIG generated code usually requires no modification so it is
relatively easy to switch between different Tcl versions as necessary
or upgrade to a newer version when the time comes (of course, the Sun
Tcl/Tk team might have changed other things to keep you occupied)
</ul>

<h3> Writing a main program and Tcl_AppInit()</h3>

The traditional method of creating a new Tcl extension required a
programmer to write a special function called <tt>Tcl_AppInit()</tt>
that would initialize your extension and start the Tcl interpreter.  A
typical <tt>Tcl_AppInit()</tt> function looks like the following :<p>
<p>
<blockquote><pre>/* main.c */
#include &lt;tcl.h&gt;

main(int argc, char *argv[]) {
	Tcl_Main(argc,argv);
	exit(0);
}

int Tcl_AppInit(Tcl_Interp *interp) {
	if (Tcl_Init(interp) == TCL_ERROR) {
		return TCL_ERROR;
	}
	
	/* Initialize your extension */
	if (Your_Init(interp) == TCL_ERROR) {
		return TCL_ERROR;
	}

	tcl_RcFileName = "~/.myapp.tcl";
	return TCL_OK;
}

</pre></blockquote>
While relatively simple to write, there are tons of problems with
doing this.  First, each extension that you use typically has their
own <tt>Tcl_AppInit()</tt> function.  This forces you to write a
special one to initialize everything by hand.  Secondly, the process
of writing a main program and initializing the interpreter varies
between different versions of Tcl and different platforms.  For
example, in Tcl 7.4, the variable "<tt>tcl_RcFileName</tt>" is a C
variable while in Tcl7.5 and newer versions its a Tcl variable
instead.  Similarly, the <tt>Tcl_AppInit</tt> function written for a
Unix machine might not compile correctly on a Mac or Windows
machine.<p>

<p>
In SWIG, it is almost never necessary to write a
<tt>Tcl_AppInit()</tt> function because this is now done by SWIG
library files such as <tt>tclsh.i</tt> or <tt>wish.i</tt>.  To give a
better idea of what these files do, here's the code from the SWIG
<tt>tclsh.i</tt> file which is roughly comparable to the above code<p>

<blockquote><pre>
// tclsh.i : SWIG library file for rebuilding tclsh
%{

/* A TCL_AppInit() function that lets you build a new copy
 * of tclsh.
 *
 * The macro SWIG_init contains the name of the initialization
 * function in the wrapper file.
 */

#ifndef SWIG_RcFileName
char *SWIG_RcFileName = "~/.myapprc";
#endif

int Tcl_AppInit(Tcl_Interp *interp){

  if (Tcl_Init(interp) == TCL_ERROR)
    return TCL_ERROR;

  /* Now initialize our functions */
  if (SWIG_init(interp) == TCL_ERROR)
    return TCL_ERROR;

#if TCL_MAJOR_VERSION &gt; 7 || TCL_MAJOR_VERSION == 7 &amp;&amp; TCL_MINOR_VERSION &gt;= 5
   Tcl_SetVar(interp,"tcl_rcFileName",SWIG_RcFileName,TCL_GLOBAL_ONLY);
#else
   tcl_RcFileName = SWIG_RcFileName;
#endif
  return TCL_OK;
}

#if TCL_MAJOR_VERSION &gt; 7 || TCL_MAJOR_VERSION == 7 &amp;&amp; TCL_MINOR_VERSION &gt;= 4
int main(int argc, char **argv) {
  Tcl_Main(argc, argv, Tcl_AppInit);
  return(0);

}
#else
extern int main();
#endif

%}
</pre></blockquote>
<p>
This file is essentially the same as a normal <tt>Tcl_AppInit()</tt>
function except that it supports a variety of Tcl versions.  When
included into an interface file, the symbol <tt>SWIG_init</tt>
contains the actual name of the initialization function (This symbol
is defined by SWIG when it creates the wrapper code).  Similarly, a
startup file can be defined by simply defining the symbol
<tt>SWIG_RcFileName</tt>.  Thus, a typical interface file might look
like this :<p>

<p>
<blockquote><pre>%module graph
%{
#include "graph.h"
#define SWIG_RcFileName "graph.tcl"
%}

%include tclsh.i

... declarations ...


</pre></blockquote>
By including the <tt>tclsh.i</tt>, you automatically get a
<tt>Tcl_AppInit()</tt> function.  A variety of library files are also
available.  <tt>wish.i</tt> can be used to build a new wish
executable, <tt>expect.i</tt> contains the main program for Expect,
and <tt>ish.i</tt>, <tt>itclsh.i</tt>, <tt>iwish.i</tt>, and
<tt>itkwish.i</tt> contain initializations for various incarnations of
[incr Tcl].<p>

<h3> Creating a new package initialization library</h3>

If a particular Tcl extension requires special initialization, you can
create a special SWIG library file to initialize it.  For example, a
library file to extend Expect looks like the following :<p>

<p>
<blockquote><pre>
// expect.i : SWIG Library file for Expect
%{

/* main.c - main() and some logging routines for expect

Written by: Don Libes, NIST, 2/6/90

Design and implementation of this program was paid for by U.S. tax
dollars.  Therefore it is public domain.  However, the author and NIST
would appreciate credit if this program or parts of it are used.
*/

#include "expect_cf.h"
#include &lt;stdio.h&gt;
#include INCLUDE_TCL
#include "expect_tcl.h"

void
main(argc, argv)
int argc;
char *argv[];
{
        int rc = 0;
        Tcl_Interp *interp = Tcl_CreateInterp();
        int SWIG_init(Tcl_Interp *);

        if (Tcl_Init(interp) == TCL_ERROR) {
                fprintf(stderr,"Tcl_Init failed: %s\n",interp-&gt;result);
                exit(1);
        }
        if (Exp_Init(interp) == TCL_ERROR) {
                fprintf(stderr,"Exp_Init failed: %s\n",interp-&gt;result);
                exit(1);
        }

        /* SWIG initialization. --- 2/11/96  */
        if (SWIG_init(interp) == TCL_ERROR) {
                fprintf(stderr,"SWIG initialization failed: %s\n", interp-&gt;result);
                exit(1);
        }

        exp_parse_argv(interp,argc,argv);
        /* become interactive if requested or "nothing to do" */
        if (exp_interactive)
                (void) exp_interpreter(interp);
        else if (exp_cmdfile)
                rc = exp_interpret_cmdfile(interp,exp_cmdfile);
        else if (exp_cmdfilename)
                rc = exp_interpret_cmdfilename(interp,exp_cmdfilename);

        /* assert(exp_cmdlinecmds != 0) */
        exp_exit(interp,rc);
        /*NOTREACHED*/
}
%}
</pre></blockquote>
<p>
In the event that you need to write a new library file such as this,
the process usually isn't too difficult.  Start by grabbing the
original <tt>Tcl_AppInit()</tt> function for the package.  Enclose it
in a <tt>%{,%}</tt> block.  Now add a line that makes a call to
<tt>SWIG_init()</tt>.  This will automatically resolve to the real
initialization function when compiled.<p>

<h3> Combining Tcl/Tk Extensions</h3>

A slightly different problem concerns the mixing of various
extensions.  Most extensions don't require any special initialization
other than calling their initialization function.  To do this, we also
use SWIG library mechanism.  For example :<p>

<p>
<blockquote><pre>// blt.i : SWIG library file for initializing the BLT extension
%{
#ifdef __cplusplus 
extern "C" {
#endif
extern int Blt_Init(Tcl_Interp *);
#ifdef __cplusplus
}
#endif
%}
%init %{
	if (Blt_Init(interp) == TCL_ERROR) {
		return TCL_ERROR;
	}
%}


// tix.i : SWIG library file for initializing the Tix extension
%{
#ifdef __cplusplus 
extern "C" {
#endif
extern int Tix_Init(Tcl_Interp *);
#ifdef __cplusplus
}
#endif
%}
%init %{
	if (Tix_Init(interp) == TCL_ERROR) {
		return TCL_ERROR;
	}
%}

</pre></blockquote>
Both files declare the proper initialization function (to be C++
friendly, this should be done using <tt>extern "C"</tt>).  A call to
the initialization function is then placed inside a <tt>%init %{
... %}</tt> block.  <p>

<p>
To use our library files and build a new version of wish, we might now
do the following :<p>

<p>
<blockquote><pre>// mywish.i : wish with a bunch of stuff added to it
%include wish.i
%include blt.i
%include tix.i

... additional declarations ...

</pre></blockquote>
Of course, the really cool part about all of this is that the file
`<tt>mywish.i</tt>' can itself, serve as a library file.  Thus, when
building various versions of Tcl, we can place everything we want to
use a special file and use it in all of our other interface files :<p>

<p>
<blockquote><pre>// interface.i
%module mymodule

%include mywish.i              // Build our version of Tcl with extensions

... C declarations ...

</pre></blockquote>
or we can grab it on the command line :<p>
<p>
<blockquote><pre>unix &gt; swig -tcl -lmywish.i interface.i

</pre></blockquote>

<h3> Limitations to this approach</h3>

This interface generation approach is limited by the compatibility of
each extension you use.  If any one extension is incompatible with the
version of Tcl you are using, you may be out of luck.  It is also
critical to pay careful attention to libraries and include files.  An
extension library compiled against an older version of Tcl may fail
when linked with a newer version.  <p>

<h3> Dynamic loading </h3>

Newer versions of Tcl support dynamic loading.  With dynamic loading,
you compile each extension into a separate module that can be loaded
at run time.  This simplifies a number of compilation and extension
building problems at the expense of creating new ones.  Most notably,
the dynamic loading process varies widely between machines and is not
even supported in some cases.  It also does not work well with C++
programs that use static constructors.  Modules linked with older
versions of Tcl may not work with newer versions as well (although
SWIG only really uses the basic Tcl C interface).  As a result, I
usually find myself using both dynamic and static linking as
appropriate. <p>

<h3> Turning a SWIG module into a Tcl Package.</h3>

Tcl 7.4 introduced the idea of an extension package.  By default, SWIG
does not create "packages", but it is relatively easy to do.  To make
a C extension into a Tcl package, you need to provide a call to
<tt>Tcl_PkgProvide() </tt>in the module initialization
function<tt>.</tt> This can be done in an interface file as follows
:<p>

<p>
<blockquote><pre>%init %{
        Tcl_PkgProvide(interp,"example","0.0");
%}
</pre></blockquote>
<p>
Where "example" is the name of the package and "0.0" is the version of
the package.  <p>
<p>
Next, after building the SWIG generated module, you need to execute
the "<tt>pkg_mkIndex</tt>" command inside tclsh.  For example :<p>

<blockquote><pre>
unix &gt; tclsh
% pkg_mkIndex . example.so
% exit

</pre></blockquote>
This creates a file "<tt>pkgIndex.tcl</tt>" with information about the
package.  To use your<p> package, you now need to move it to its own
subdirectory which has the same name as the package. For example :<p>
<p>
<blockquote><pre>./example/
	   pkgIndex.tcl           # The file created by pkg_mkIndex
	   example.so             # The SWIG generated module

</pre></blockquote>
<p>
Finally, assuming that you're not entirely confused at this point,
make sure that the example subdirectory is visible from the
directories contained in either the <tt>tcl_library</tt> or
<tt>auto_path</tt> variables.  At this point you're ready to use the
package as follows :<p>

<blockquote><pre>
unix &gt; tclsh
% package require example
% fact 4
24
%
</pre></blockquote>
<p>
If  you're working with an example in the current directory and this doesn't work, do this instead :<p>
<p>
<blockquote><pre>unix &gt; tclsh
% lappend auto_path .
% package require example
% fact 4
24

</pre></blockquote>
<p>

As a final note, most SWIG examples do not yet use the
<tt>package</tt> commands. For simple extensions it may be easier just
to use the <tt>load</tt> command instead.<p>

<h2> Building new kinds of Tcl interfaces (in Tcl)</h2>

One of the most interesting aspects of Tcl and SWIG is that you can
create entirely new kinds of Tcl interfaces in Tcl using the low-level
SWIG accessor functions.  For example, suppose you had a library of
helper functions to access arrays :<p>

<p>
<blockquote><pre>/* File : array.i */
%module array

%inline %{
double *new_double(int size) {
        return (double *) malloc(size*sizeof(double));
}
void delete_double(double *a) {
        free(a);
}
double get_double(double *a, int index) {
        return a[index];
}
void set_double(double *a, int index, double val) {
        a[index] = val;
}
int *new_int(int size) {
        return (int *) malloc(size*sizeof(int));
}
void delete_int(int *a) {
        free(a);
}
int get_int(int *a, int index) {
        return a[index];
}
int set_int(int *a, int index, int val) {
        a[index] = val;
}
%}

</pre></blockquote>
While these could be called directly, we could also write a Tcl script
like this :<p>

<p>
<blockquote><pre>proc Array {type size} {
    set ptr [new_$type $size]
    set code {
        set method [lindex $args 0]
        set parms [concat $ptr [lrange $args 1 end]]
        switch $method {
            get {return [eval "get_$type $parms"]}
            set {return [eval "set_$type $parms"]}
            delete {eval "delete_$type $ptr; rename $ptr {}"}
        }
    }
    # Create a procedure
    uplevel "proc $ptr args {set ptr $ptr; set type $type;$code}"
    return $ptr
}
</pre></blockquote>

<p>
Our script allows easy array access as follows :<p>

<p>
<blockquote><pre>set a [Array double 100]                   ;# Create a double [100]
for {set i 0} {$i &lt; 100} {incr i 1} {      ;# Clear the array
	$a set $i 0.0
}
$a set 3 3.1455                            ;# Set an individual element
set b [$a get 10]                          ;# Retrieve an element

set ia [Array int 50]                      ;# Create an int[50]
for {set i 0} {$i &lt; 50} {incr i 1} {       ;# Clear it
	$ia set $i 0
}
$ia set 3 7                                ;# Set an individual element
set ib [$ia get 10]                        ;# Get an individual element

$a delete                                  ;# Destroy a
$ia delete                                 ;# Destroy ia
</pre></blockquote>

<p>
The cool thing about this approach is that it makes a common interface
for two different types of arrays.  In fact, if we were to add more C
datatypes to our wrapper file, the Tcl code would work with those as
well--without modification.  If an unsupported datatype was requested,
the Tcl code would simply return with an error so there is very little
danger of blowing something up (although it is easily accomplished
with an out of bounds array access).<p>

<h3> Shadow classes</h3>

A similar approach can be applied to shadow classes.  The following
example is provided by Erik Bierwagen and Paul Saxe.  To use it, run
SWIG with the <tt>-noobject</tt> option (which disables the builtin
object oriented interface).  When running Tcl, simply source this
file.  Now, objects can be used in a more or less natural fashion.<p>

<p>
<blockquote><pre># swig_c++.tcl
# Provides a simple object oriented interface using
# SWIG's low level interface.
#

proc new {objectType handle_r args} {
    # Creates a new SWIG object of the given type,
    # returning a handle in the variable "handle_r".
    #
    # Also creates a procedure for the object and a trace on
    # the handle variable that deletes the object when the
    # handle varibale is overwritten or unset
    upvar $handle_r handle
    #
    # Create the new object
    #
    eval set handle \[new_$objectType $args\]
    #
    # Set up the object procedure
    #
    proc $handle {cmd args} "eval ${objectType}_\$cmd $handle \$args"
    #
    # And the trace ...
    #
    uplevel trace variable $handle_r uw "{deleteObject $objectType $handle}"
    #
    # Return the handle so that 'new' can be used as an argument to a procedure
    #
    return $handle
}

proc deleteObject {objectType handle name element op} {
    #
    # Check that the object handle has a reasonable form
    #
    if {![regexp {_[0-9a-f]*_(.+)_p} $handle]} {
        error "deleteObject: not a valid object handle: $handle"
    }
    #
    # Remove the object procedure
    #
    catch {rename $handle {}}
    #
    # Delete the object
    #
    delete_$objectType $handle
}

proc delete {handle_r} {
    #
    # A synonym for unset that is more familiar to C++ programmers
    #
    uplevel unset $handle_r
}
</pre></blockquote>

<p>
To use this file, we simply source it and execute commands such as
"new" and "delete" to manipulate objects.  For example :<p>

<p>
<blockquote><pre>// list.i
%module List
%{
#include "list.h"
%}

// Very simple C++ example

class List {
public:
  List();  // Create a new list
  ~List(); // Destroy a list
  int  search(char *value);
  void insert(char *);  // Insert a new item into the list
  void remove(char *);  // Remove item from list
  char *get(int n);     // Get the nth item in the list
  int  length;          // The current length of the list
static void print(List *l);  // Print out the contents of the list
};
</pre></blockquote>

<p>
Now a Tcl script using the interface...<p>

<p>
<blockquote><pre>load ./list.so list       ; # Load the module
source swig_c++.tcl       ; # Source the object file

new List l
$l insert Dave
$l insert John
$l insert Guido
$l remove Dave
puts $l length_get

delete l

</pre></blockquote>
The cool thing about this example is that it works with any C++ object
wrapped by SWIG and requires no special compilation.  Proof that a
short, but clever Tcl script can be combined with SWIG to do many
interesting things.<p>

<p><hr>

<address>SWIG 1.3 - Last Modified : January 31, 2002</address>
</body>
</html>
