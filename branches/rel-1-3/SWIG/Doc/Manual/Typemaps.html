<html>
<head>
<title>Types and Typemaps</title>
</head>

<body bgcolor="#ffffff">
<h1>6 Types and Typemaps</h1>

<b>Caution: This chapter is under repair!</b>

<h2>Introduction</h2>

In Chapter 3, SWIG's treatment of basic datatypes and pointers was
described.  In particular, primitive types such as <tt>int</tt> and
<tt>double</tt> are mapped to corresponding types in the target
language.  For everything else, pointers are used to refer to
structures, classes, arrays, and other user-defined datatypes.
However, in certain applications it is desirable to change SWIG's
handling of a specific datatype. For example, you may want a <tt>char
** </tt>to act like a list of strings instead of a bare pointer. In
another case, you may want to tell SWIG that a parameter of
<tt>double *result</tt> is the output value of a function. Similarly,
you might want to map a datatype of <tt>float[4]</tt> into a 4 element
tuple.  This chapter describes some of the techniques that can be used
to customize SWIG's type handling in order to handle these situations. In particular, details of the
underlying type system and typemaps, an advanced customization
feature, are presented.

<h2>The Problem</h2>

Suppose that you wanted to provide a scripting language wrapper
around a function with the following prototype:

<blockquote>
<pre>
int foo(int argc, char *argv[]);
</pre>
</blockquote>

If you do nothing, SWIG produces a wrapper that 
expects to receive a pointer of type <tt>char **</tt> as 
the second argument.  For example, if you try to use the function
you might get an error like this:

<blockquote>
<pre>
>>> foo(3,["ale","lager","stout"])
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: Type error. Expected _p_p_char
>>> 
</pre>
</blockquote>

One way to fix this problem is to write a few assist functions to
manufacture an object of the appropriate type.  For example:

<blockquote>
<pre>
%inline %{
char **new_args(int maxarg) {
   return (char **) malloc(maxarg*sizeof(char *));
}
void del_args(char **args, int narg) {
   while (--narg > 0) {
      free(args[narg]);
   }
   free(args);
}
void set_arg(char **args, int n, char *value) {
   args[n] = (char *) malloc(strlen(value)+1);
   strcpy(args[n],value);
}
%}
</pre>
</blockquote>

Now in the scripting language:

<blockquote>
<pre>
>>> args = new_args(3)
>>> args
_000f4248_p_p_char
>>> set_arg(args,0,"ale")
>>> set_arg(args,1,"lager")
>>> set_arg(args,2,"stout")
>>> foo(3,args)
>>> del_args(args,3)
</pre>
</blockquote>

Needless to say, even though this works, it isn't the most user friendly interface.
It would be much nicer if you could simply make a list
of strings work like a <tt>char **</tt>.  Similar problems arise when
creating wrappers for small arrays, output values, and certain kinds
of data structures.

<p>
One of the reasons why SWIG does not provide automatic support for
mapping scripting language objects such as lists and associative
arrays into C is that C declarations often do not provide enough semantic 
information for SWIG to know exactly how this should be done.
For example, if you have a function like this,

<blockquote>
<pre>
void foo(double *x, double *y, double *r);
</pre>
</blockquote>

it's not obvious what the arguments are supposed to represent.
Are they single values?  Are they arrays?  Is a result stored in one
of the arguments?  The only thing that SWIG really knows is that they
are pointers. Any further interpretation requires a little more information.

<h2>Typemaps</h2>

One way to provide more information about a particular C datatype is
to attach a special code generation rule to the type known as a
<em>typemap</em>.  Typemaps are the primary customization mechanism
used to modify SWIG's default type-handling behavior. For example,
suppose you had a C function like this :<p>

<p>
<blockquote><pre>void add(double a, double b, double *result) {
	*result = a + b;
}
</pre></blockquote>

<p>
From reading the source code, it is clear that the function is storing
a value in the <tt>double *result</tt> parameter.   However, since SWIG
does not examine source code, you need to give it additional information
for the wrapper code to mimic this behavior.  Using a typemap, you can transform
<tt>double *result</tt> into an output value and generate wrapper code that handles it as such.

<p>
The most gentle introduction to typemaps is to start with some
of the predefined typemaps contained in the file <tt>typemaps.i</tt>
(contained in the SWIG library).  For example:

<p>
<blockquote><pre>// Simple example using typemaps
%module example
%include "typemaps.i"

%apply double *OUTPUT { double *result; }
extern void add(double a, double b, double *result);
</pre></blockquote>

The <tt>%apply</tt> directive tells SWIG that you are going to apply
a typemap rule to a new datatype. The "<tt>double *OUTPUT</tt>" is the
name of a rule that knows how to return an output value from an argument of type
<tt>double *</tt> (this rule is defined in the file
<tt>typemaps.i</tt>). The rule gets applied to all of the datatypes
listed in curly braces-- in this case "<tt>double *result</tt>".<p>

<p>
When the resulting module is created, you can now use the function
like this (shown for Python):

<p>
<blockquote><pre>
>>> a = add(3,4)
>>> print a
7
>>>
</pre></blockquote>

In this case, you can see how the output value normally returned in
the third argument has magically been transformed into a function
return value.  Clearly this makes the function much easier to use
since it is no longer necessary to manufacture a special <tt>double
*</tt> object and pass it to the function somehow.

<p>
Such transformations can even be extended to multiple return values.
For example, consider this code:

<blockquote>
<pre>
%include "typemaps.i"
%apply int *OUTPUT { int *width, int *height };

// Returns a pair (width,height)
void getwinsize(int winid, int *width, int *height);
</pre>
</blockquote>

In this case, the function returns multiple values, allowing it to be used like this:

<blockquote><pre>
>>> w,h = genwinsize(wid)
>>> print w
400
>>> print h
300
>>>
</pre>
</blockquote>

<p>
Once defined, a typemap rule applies to all future occurrences of a
matching type and name.  For instance, in the earlier example, all
occurrences of <tt>double *result</tt> will be treated as an output
parameter.   Thus, if an interface uses a consistent
naming scheme, a typemap can be used to consistently apply special handling
rules across an entire set of declarations.

<p>
It should also be noted that although the <tt>%apply</tt> directive is
used to associate typemap rules to datatypes, you can also use the
rule names directly in arguments.  For example, you could write this:

<blockquote><pre>// Simple example using typemaps
%module example
%include "typemaps.i"

extern void add(double a, double b, double *OUTPUT);
</pre></blockquote>

Typemaps stay in effect until they are explicitly deleted or redefined to something
else.   To clear a typemap, the %clear directive should be used.  For example:

<blockquote>
<pre>
%clear double *result;      // Remove all typemaps for double *result
</pre>
</blockquote>

<h2>Managing input and output parameters</h2>

One of the most common applications of typemaps is to handle pointers
that correspond to simple input, output, or mutable function parameters. 
Typically this problem arises when working with functions that return more
than one value such as a function that returns both a result and a status
code to indicate success. The <tt>typemaps.i</tt> file contains a variety of rules for 
managing such pointers to the primitive C datatypes.

<h3>Input Methods</h3>
<p>
The following methods instruct SWIG that a pointer really only holds a single
input value:

<blockquote><pre>
int *INPUT		
short *INPUT
long *INPUT
unsigned int *INPUT
unsigned short *INPUT
unsigned long *INPUT
double *INPUT
float *INPUT
</pre></blockquote>

When used, it allows values to be passed instead of pointers.  For example, consider this
function:

<blockquote><pre>
double add(double *a, double *b) {
	return *a+*b;
}
</pre></blockquote>

Now, consider this SWIG interface:

<p>
<blockquote><pre>%module example
%include "typemaps.i"
...
extern double add(double *INPUT, double *INPUT);

</pre></blockquote>

When the function is used in the scripting language interpreter, it will work like this:
<p>
<blockquote><pre>
result = add(3,4)
</pre></blockquote>

<h3>Output Methods</h3>

The following typemap rules tell SWIG that pointer is the output value of a
function. When used, you do not need to supply the argument when
calling the function. Instead, one or more output values are returned. 

<p>
<blockquote><pre>int *OUTPUT
short *OUTPUT
long *OUTPUT
unsigned int *OUTPUT
unsigned short *OUTPUT
unsigned long *OUTPUT
double *OUTPUT
float *OUTPUT

</pre></blockquote>
These methods can be used as shown in an earlier example. For example, if you have this C function :<p>
<p>
<blockquote><pre>void add(double a, double b, double *c) {
	*c = a+b;
}
</pre></blockquote>

<p>
A SWIG interface file might look like this :<p>

<p>
<blockquote><pre>%module example
%include "typemaps.i"
...
extern void add(double a, double b, double *OUTPUT);

</pre></blockquote>

In this case, only a single output value is returned, but this is not
a restriction.  An arbitrary number of output values can be returned by applying
the output rules to more than one argument (as shown previously).

<h3>Input/Output Methods</h3>

When a pointer serves as both an input and output value you can use
the following methods :<p>

<blockquote><pre>
int *INOUT
short *INOUT
long *INOUT
unsigned int *INOUT
unsigned short *INOUT
unsigned long *INOUT
double *INOUT
float *INOUT

</pre></blockquote>

A C function that uses this might be something like this:<p>

<p>
<blockquote><pre>void negate(double *x) {
	*x = -(*x);
}

</pre></blockquote>

To make x function as both and input and output value, declare the
function like this in an interface file :<p>

<p>
<blockquote><pre>%module example
%include typemaps.i
...
extern void negate(double *INOUT);

</pre></blockquote>

Now within a script, you can simply call the function normally :<p>

<p>
<blockquote><pre>a = negate(3);         # a = -3 after calling this
</pre></blockquote>

One subtle point of the <tt>INOUT</tt> rule is that many scripting languages
enforce mutability constraints on primitive objects (meaning that simple objects
like integers and strings aren't supposed to change).   Because of this, you can't
just modify the object's value in place as the underlying C function does in this example.
Therefore, the <tt>INOUT</tt> rule returns the modified value as a new object
rather than directly overwriting the value of the original input object.

<p>
<b>Compatibility note :</b> The <tt>INOUT</tt> rule used to be known as <tt>BOTH</tt> in earlier versions of
SWIG.  Backwards compatibility is preserved, but deprecated.

<h3>Using different names</h3>

As previously shown, the <tt>%apply</tt> directive can be used to apply the <tt>INPUT</tt>, <tt>OUTPUT</tt>, and
<tt>INOUT</tt> rules to different argument names.  For example:

<p>
<blockquote><pre>// Make double *result an output value
%apply double *OUTPUT { double *result };

// Make Int32 *in an input value
%apply int *INPUT { Int32 *in };

// Make long *x inout
%apply long *INOUT {long *x};

</pre></blockquote>

To clear a rule, the <tt>%clear</tt> directive is used:

<p>
<blockquote><pre>%clear double *result;
%clear Int32 *in, long *x;
</pre></blockquote>

<h2>Applying constraints to input values</h2>

In addition to changing the handling of various input values, it is
also possible to use typemaps to apply constraints. For example, maybe you want to
insure that a value is positive, or that a pointer is non-NULL. This
can be accomplished including the <tt>constraints.i</tt> library file.

<h3>Simple constraint example</h3>

The constraints library is best illustrated by the following interface
file :<p>
<p>

<blockquote><pre>// Interface file with constraints
%module example
%include "constraints.i"

double exp(double x);
double log(double POSITIVE);         // Allow only positive values
double sqrt(double NONNEGATIVE);     // Non-negative values only
double inv(double NONZERO);          // Non-zero values
void   free(void *NONNULL);          // Non-NULL pointers only

</pre></blockquote>

The behavior of this file is exactly as you would expect. If any of
the arguments violate the constraint condition, a scripting language
exception will be raised. As a result, it is possible to catch bad
values, prevent mysterious program crashes and so on.<p>

<h3>Constraint methods</h3>

The following constraints are currently available<p>

<blockquote><pre>
POSITIVE                     Any number &gt; 0 (not zero)
NEGATIVE                     Any number &lt; 0 (not zero)
NONNEGATIVE                  Any number &gt;= 0
NONPOSITIVE                  Any number &lt;= 0
NONZERO                      Nonzero number
NONNULL                      Non-NULL pointer (pointers only).

</pre></blockquote>

<h3>Applying constraints to new datatypes</h3>

The constraints library only supports the primitive C datatypes, but it
is easy to apply it to new datatypes using <tt>%apply</tt>. For
example :<p>
<p>

<blockquote><pre>// Apply a constraint to a Real variable
%apply Number POSITIVE { Real in };

// Apply a constraint to a pointer type
%apply Pointer NONNULL { Vector * };

</pre></blockquote>

The special types of "Number" and "Pointer" can be applied to any
numeric and pointer variable type respectively. To later remove a
constraint, the <tt>%clear</tt> directive can be used :<p>

<p>
<blockquote><pre>%clear Real in;
%clear Vector *;
</pre></blockquote>

<h2>Writing new typemaps</h2>

So far, only a few examples of <em>using</em> typemaps have been
presented.  However, if you're willing to get your hands dirty and dig
into the internals of your favorite scripting language (and SWIG), it
is possible to do much more.

<p>
Before diving in, it needs to be stressed that under normal conditions,
SWIG does <b>NOT</b> require users to write new typemaps (and even when they are
used, it is probably better to use them sparingly).  A common
confusion among some new users to SWIG is that they somehow need to write typemaps
to handle new types when in fact they really only need to use a 
<tt>typedef</tt> declaration.  For example, if you have a declaration like this,

<blockquote>
<pre>
void blah(size_t len);
</pre>
</blockquote>

you really only need to supply an appropriate <tt>typedef</tt> to make
it work. For example:

<blockquote>
<pre>
typedef unsigned long size_t;
void blah(size_t len);
</pre>
</blockquote>

Typemaps are only used if you want to change the way that SWIG
actually generates its wrapper code.  For example, if you needed to
express <tt>size_t</tt> as a string of roman numerals to preserve
backwards compatibility with some piece of legacy software. A
more practical application is the conversion of common scripting language
objects such as lists and associative arrays into C datatypes.  For
example, converting a list of strings into a <tt>char *[]</tt> as
shown in the first part of this chapter.

<P>
Before proceding, you should first ask yourself if it is really necessary to change SWIG's
default behavior.  Next, you need to be aware that writing a typemap from scratch
usually requires a detailed knowledge of the internal C API of the target language.
Finally, it should also be stressed that by writing typemaps, it is easy to break all of the 
output code generated by SWIG.   With these risks in mind, this section describes the
basics of the SWIG type system and typemap construction.  Language specific information
is contained in later chapters.

<h3>The SWIG type system</h3>

Typemaps are tightly integrated with the internal operation of the
SWIG type system.  Internal to SWIG, all C++ datatypes are managed as
a pair of types <tt>(type, ltype)</tt>.  <tt>type</tt> is 
the actual C++ datatype as it is specified in the
interface file. <tt>ltype</tt> is a modified version of the datatype
that can be used as an assignable local variable (a type that can be
used on the left-hand side of a C assignment operator).  The
relationship between these two types directly pertains to the generation of wrapper code.
Specifically, <tt>ltype</tt> is used to declare
local variables used during argument conversion whereas <tt>type</tt>
is used to make sure the actual C/C++ function is called without any
type-errors.  For example, if you have a C declaration like this:

<blockquote>
<pre>
void func(..., <em>type</em>, ...);
</pre>
</blockquote>

The corresponding wrapper code will look approximately like this:

<blockquote>
<pre>
wrap_func(args) {
   ...
   <em>ltype</em> arg<em>n</em>;                    // Local type for argument
   ...
   arg<em>n</em> = ConvertValue(args[<em>n</em>]);
   ...
   func(..., (<em>type</em>) arg<em>n</em>, ...);   // Cast back to type
   ...
}
</pre>
</blockquote>

The relationship between the real C++ datatype and its ltype value is determined
by the following rules:

<ul>
<li>All qualifiers (<tt>const</tt>, <tt>volatile</tt>, etc.) are stripped.
<li>C++ References are converted to pointers.
<li>Arrays are converted to a pointer to an array of one less dimension.
<li>Objects manipulated by value are converted to a pass by reference.
</ul>

For example:

<blockquote>
<pre>
type                    ltype
----------------------  --------------------
primitive               primitive        (Note: int, double, float, short, etc..)
object                  object *         (Objects passed/returned by value)
object *                object *
const object *          object *
const object * const    object *
object &                object *
object [10]             object *
object [10][20]         object (*)[20]
</pre>
</blockquote>

In certain cases, names defined with <tt>typedef</tt> are also expanded.  For example,
if you have a type defined by a <tt>typedef</tt> as follows:

<blockquote>
<pre>
typedef double Matrix[4][4];
</pre>
</blockquote>

the ltype of <tt>Matrix</tt> is set to <tt>double (*)[4]</tt> since
there is no way for SWIG to create an assignable variable using
variations of the <tt>Matrix</tt> typename.

<p>
It should probably be stressed that these rules also define the
behavior of the SWIG run-time type checker.  Specifically, all of the
type checking described in Chapter 3 is actually performed using ltype
values and not the actual C datatype. This explains why, for instance,
there is no difference between pointers, references, and
one-dimensional arrays when they are used in the corresponding
scripting language module.  It also explains why qualifiers never
appear in the mangled type-names used for type checking.

<h3> What is a typemap?</h3>

A typemap is a code generation rule that is attached to a specific datatype.
It is specified using the <tt>%typemap</tt> directive.  For example,
a simple typemap might look like this:

<p>
<blockquote><pre>%module example
%typemap(python,in) int {
   $1 = (int) PyInt_AsLong($input);
   if (PyErr_Occurred()) return NULL;
   printf("received %d\n", $1);
}

int add(int a, int b);
</pre></blockquote>

<p>
In this case, the typemap defines a rule for handling input arguments
in Python. When used in a Python script, you would get the following
output:<p>

<p>
<blockquote><pre>>>> a = add(7,13)
received 7
received 13
</pre></blockquote>

In the typemap specification, the symbols <tt>$1</tt> and
<tt>$input</tt> are place holders for C variable names in the
generated wrapper code. In this case, <tt>$input</tt> is a variable 
containing the raw Python object supplied as input and
<tt>$1</tt> is the variable used to hold the converted value (in this case,
<tt>$1</tt> will be a C local variable of type <tt>int</tt>).  The
<tt>$1</tt> variable is <em>always</em> the ltype of the type supplied
to the <tt>%typemap</tt> directive.

<p>
To support different code-generation tasks, a variety of different
typemaps can be defined.  For example, the following typemap specifies
how to result integers back to Python

<blockquote>
<pre>
%typemap(python,out) int {
   $result = PyInt_FromLong($1);
}
</pre>
</blockquote>

In this case, <tt>$result</tt> refers to the Python object being returned to
the interpreter and <tt>$1</tt> refers to the variable holding the raw
integer value being returned.

<p>
At first, the use of <tt>$1</tt> to refer to the local variable in a typemap
may be counterintuitive.  However, this notation is used to support an
advanced feature of typemaps that allow rules to be written for groups
of consecutive types.  For example, a typemap can be written as follows:

<blockquote>
<pre>
%typemap(python,int) (char *buffer, int len) {
   $1 = PyString_AsString($input);
   $2 = PyString_Size($input);
}
...

// Some function
int count(char *buffer, int len, char *pattern);
</pre>
</blockquote>

In this case, the pattern <tt>(char *buffer, int len)</tt> is handled
as a single rule.  Within the typemap code, <tt>$1</tt> and
<tt>$2</tt> are used to refer to each part of the pattern.  For
instance, <tt>$1</tt> refers to a variable of type <tt>char *</tt> and
<tt>$2</tt> refers to a variable of type <tt>int</tt> (for the the
curious, this naming scheme is roughly taken from yacc). The use of
multi-argument maps is an advanced topic and is described a little
later.

<P>
<b>Compatibility note:</b> Prior to SWIG1.3.10, typemaps used the special variables
<tt>$source</tt> and <tt>$target</tt> to refer to local variables used during
conversion.   Unfortunately, the roles of these variables was somewhat
inconsistent (and in some places their meaning switched depending on the type
of the typemap).  In addition, this naming scheme is awkward when extended to
multiple arguments.  Although <tt>$source</tt> and <tt>$target</tt> are still
supported for backwards compatibility, all future use is deprecated and may be
eliminated in a future release.  In new versions, the local variables corresponding to
the types in the typemap specification are referenced using <tt>$1</tt>, <tt>$2</tt>, and so forth.
Objects in the target language passed as input are referenced by <tt>$input</tt>. 
Objects returned to the target language are referenced by <tt>$result</tt>.

<h3> Creating a new typemap</h3>

A new typemap is specified as follows :<p>
<blockquote><pre>
%typemap(lang,method) type {
    ... Conversion code ...
}

// Alternative version
%typemap(lang,method) type "Conversion Code";
</pre></blockquote>

<tt>lang</tt> specifies the target language and <tt>method</tt> defines a
particular conversion method.  <tt>type</tt> is the actual C++ datatype 
as it appears in the interface file (it is not the ltype value described
in the section on the SWIG type system). The code attached to the typemap
is supplied in braces or a quoted string after the declaration.  If braces
are used, they are included in the output---meaning that new local variables
can be declared inside the typemap code (the typemap defines a new C block scope).
If code is supplied in quotes, it is inlined into the generated wrappers with
no other surrounding code.

<p>
A single typemap rule can be applied to a list of matching datatypes by using a
comma separated list. For example :<p>
<p>
<blockquote><pre>%typemap(python,in) int, short, long, signed char {
   $1 = ($1_ltype) PyInt_AsLong($input);
   if (PyErr_Occurred()) return NULL;
   printf("received %d\n", $1);
}
</pre></blockquote>

Here, <tt>$1_ltype</tt> is expanded into the local datatype used during code
generation (this is the assignable version of the type described in the
SWIG type system section).   This form of specifying a typemap is a useful
way to reduce the amount of typing required when the same typemap code might
apply to a whole set of similar datatypes.  Also, note that this syntax
is not the same as a multi-argument typemap.

<p>
Typemaps may also be attached to specific declarator names as in:

<p>
<blockquote><pre>%typemap(perl5,in) char **argv {
   ... Turn a perl array into a char ** ...
}

</pre></blockquote>

A "named" typemap only applies to declarations that exactly match both the C
datatype and the name. Thus the <tt>char **argv</tt> typemap will only
be applied to function arguments that exactly match "<tt>char
**argv</tt>". Although the name is usually the name of a parameter in a 
function/method declaration, certain typemaps are applied to return values (in which
case, the name of the corresponding function or method is used).

<p>
Typemaps can also be specified for a group of consecutive types by enclosing the
types in parentheses.   For example:

<blockquote>
<pre>
%typemap(python,in) (char *buffer, int len) {
   ...
}
</pre>
</blockquote>

In this case, the typemap only applies to function/method arguments where the argument pair
<tt>char *buffer, int len</tt> appears. 

<p>
Finally, there is a shortened form of the typemap directive :<p>

<p>
<blockquote><pre>%typemap(method) Datatype {
	...
}

</pre></blockquote>

When the language name is ommitted, the typemap will be applied to the
current target language. This form is really only recommended for typemap
methods that are language independent (of which there are a few). It is not
recommended if you are building interfaces for multiple languages unless
you are careful to hide the typemap with conditional compilation.

<h3> Deleting a typemap</h3>

A typemap can be deleted by providing no conversion code. For example:<p>

<p>
<blockquote><pre>%typemap(lang,method) type;              // Deletes this typemap

</pre></blockquote>

<h3> Copying a typemap</h3>

A typemap can be copied using the following declaration :<p>

<p>
<blockquote><pre>%typemap(lang,method) type = srctype;     // Copies a typemap
</pre></blockquote>

This specifies that the typemap for <tt>type</tt> should be the same
as the <tt>srctype</tt> typemap. Here is an example:

<blockquote>
<pre>
%typemap(python,in) long = int;

// Copy a typemap with names
%typemap(python,in) int_64 *output = long *output;

// Copy a multi-argument typemap
%typemap(python,in) (char *data, int size) = (char *buffer, int len);
</pre>
</blockquote>

<h3>Typemap matching rules</h3>

When datatypes are processed in an interface file, SWIG tries to match types and names
to a typemap rule as follows:

<ul>
<li>Typemaps that exactly match the type and name (a named typemap).
<li>Typemaps that exactly match the type only (an unnamed typemap).
<li>Typemaps that match the stripped type and name (the type is stripped of qualifiers).
<Li>Typemaps that match the stripped type only.
<li>If the type is an array, try to match against typemaps defined with dimensions set to <tt>ANY</tt>.
<li>If the type is equivalent to another type via <tt>typedef</tt>, typemaps
for the <tt>typedef</tt> type are applied.
</ul>

When more than one typemap rule might be defined, only the first match
found is actually used.  Here is an example that
shows how some of the rules are applied:

<blockquote><pre>
typedef int Integer;

%typemap(python,in) int *x {
   ...
}

%typemap(python,in) int * {
   ...
}

%typemap(python,in) Integer *x {
   ...
}

void A(int *x);      // int *x rule 
void B(int *y);      // int * rule
void C(Integer *);   // int * rule (via typedef)
void D(Integer *x);  // Integer *x rule
void E(const int *); // int * rule (const stripped)
</pre>
</blockquote>

<p>
When multi-argument typemaps are specified, they take precedence over
any typemaps specified for a single type.  For example:

<blockquote>
<pre>
%typemap(python,in) (char *buffer, int len) {
   // typemap 1
}

%typemap(python,in) char *buffer {
   // typemap 2
}

void foo(char *buffer, int len, int count);    // (char *buffer, int len) applied
void bar(char *buffer, int blah);              // char *buffer applied
</blockquote>
</pre>

<p>
<b>Compatibility note:</b> SWIG1.1 applied a complex set of type-matching rules in which
a typemap for <tt>int *</tt> would also match many different variations including
<tt>int &</tt>, <tt>int []</tt>, and qualified variations.   This feature is revoked
in SWIG1.3. Typemaps must now exactly match the types and names used in the interface
file.

<p>
<b>Compatibility note:</b> Starting in SWIG1.3, typemap matching tries to follow <tt>typedef</tt>
declarations if possible (as shown in the above example).   This type of matching is
only performed in one direction.  For example, if you had <tt>typedef int Integer</tt> and then
defined a typemap for <tt>Integer</tt>, that typemap would <em>not</em> be applied to
the <tt>int</tt> datatype.  Earlier versions of SWIG did not follow <tt>typedef</tt> declarations
when matching typemaps.   This feature has primarily been added to assist language
modules that rely heavily on typemaps (e.g., a typemap for "int" now defines the default
for integers regardless of what kind of typedef name is being used to actually refer to an integer
in the source program).

<h2> Common typemap methods</h2>

When a typemap is specified, the supplied method identifies a specific aspect of wrapper
code generation.  For instance, the "in" method used earlier pertains to incoming argument
conversion.   The following list contains other commonly used methods that are
supported by most language modules:

<ul>
<li><tt>%typemap(lang,in)</tt><br>
Marshal function arguments from the target language to a C representation.

<p>
<li><tt>%typemap(lang,out)</tt><br>
Convert a function return value to an object in the target language.

<p>
<li><tt>%typemap(lang,ret)</tt><br>
Used to clean up the return value of a function.   For example,
if you needed to deallocate memory.  

<p>
<li><tt>%typemap(lang,freearg)</tt><br>
Used to clean up argument values. For example, if memory
was allocated to hold an argument prior to calling a function.

<p>
<li><tt>%typemap(lang,argout)</tt><br>
Used to handle arguments that hold output values.  This code
is used to extract the output values and generate result objects in the target language.

<p>
<li><tt>%typemap(lang,ignore)</tt><br>
Ignore an argument.

<p>
<li><tt>%typemap(lang,default)</tt><br>
Set a default value for an argument (making the argument optional).

<p>
<li><tt>%typemap(lang,arginit)</tt><br>
Initializes an argument to have a specific value prior to argument conversion.

<p>
<li><tt>%typemap(lang,check)</tt><br>
Allows an argument to be checked for a valid value.  For example, if
you wantd to disallow a NULL pointer or constrain an argument value to positive numbers.

<p>
<li><tt>%typemap(lang,memberin)</tt><br>
Used to supply special code for setting structure and class
data members.   Most commonly used to set array members.
</ul>

<p>
Each typemap is applied in a very specific location within the wrapper
functions generated by SWIG.   Specifically, the general form a wrapper function
is as follows:

<blockquote>
<pre>
_wrap_foo() {

   /* Marshal input values to C */
   [ ignore typemaps ]
   [ arginit typemaps ]
   [ in typemaps ]
   [ check typemaps ]

   /* Call the actual C function */
   call foo

   /* Return result to target language */
   [ out typemap ]
   [ argout typemaps ]
   [ freearg typemaps ]
   [ ret typemap ]
}
</pre>
</blockquote>

To illustrate, it is often useful to write a simple interface file
with some typemaps and to take a look at the generated wrapper code.
To illustrate, consider the following interface file (with typemaps):

<blockquote>
<pre>
%module example
%typemap(in) int {
   // "in" typemap. $1, $input 
}
%typemap(out) int {
   // "out" typemap. $1, $result
}
%typemap(ignore) int ignored {
   // "ignore" typemap. $1
}
%typemap(check) int {
   // "check" typemap. $1
}
%typemap(arginit) int *out {
   // "arginit" typemap. $1
}
%typemap(argout) int *out {
   // "argout" typemap. $1, $result
}
%typemap(ret) int {
   // "ret" typemap. $1
}
%typemap(freearg) int *out {
   // "freearg" typemap. $1
}

int foo(int, int ignored, int *out);
</pre>
</blockquote>

Now, let's take a look at the resulting wrapper function (generated for Python, but
it looks similar for other languages):

<blockquote>
<pre>
static PyObject *_wrap_foo(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    int arg0 ;
    int arg1 ;
    int *arg2 ;
    PyObject * obj0  = 0 ;
    PyObject * argo2 =0 ;
    int result ;
    
    {
        // "ignore" typemap. arg1
    }
    {
        // "arginit" typemap. arg2
    }
    if(!PyArg_ParseTuple(args,(char *)"OO:foo",&amp;obj0,&amp;argo2)) return NULL;
    {
        // "in" typemap. arg0, obj0
    }
    if ((SWIG_ConvertPtr(argo2,(void **) &amp;arg2,SWIGTYPE_p_int,1)) == -1) return NULL;
    {
        // "check" typemap. arg0
    }
    {
        // "check" typemap. arg1
    }
    result = (int )foo(arg0,arg1,arg2);
    {
        // "out" typemap. result, resultobj
    }
    {
        // "argout" typemap. arg2, resultobj
    }
    {
        // "freearg" typemap. arg2
    }
    {
        // "ret" typemap. result
    }
    return resultobj;
}
</pre>
</blockquote>

In this example, you can see how different typemaps are used for different purposes.
For example, the "arginit" and "ignore" typemaps appear first, and usually used to initialize
variables before anything else occurs.    The "in" typemap is used to help convert arguments
from the target language to C.  The "check" typemap appears just prior to the actual function
call and is used to validate arguments.  After the function has been called, the "out" and "argout" typemaps
are used to create an output values.   Typically, "argout" appends its result to any result already
set by the "out" typemap.   The last two typemaps, "freearg" and "ret" are used to perform cleanup
actions.

<p>
Within each typemap, the <tt>$1</tt> is always replaced by a C local variable corresponding
to that type.  For example, you can see how <tt>$1</tt> is replaced by <tt>arg0</tt>,
<tt>arg1</tt>, and <tt>arg2</tt> depending on the argument in question.    For typemaps
related to returning a result, <tt>$1</tt> is usually set to the local variable holding
the raw result of the function call (in this case, the variable <tt>result</tt>).

<h2> Writing typemap code</h2>

The conversion code supplied to a typemap needs to follow a few
conventions described here.<p>

<h3>Local scope</h3>

Typemap code is normally enclosed in braces when it is inserted into the
resulting wrapper code (using C's block-scope). It is perfectly legal
to declare local and static variables in a typemap.   For example, you 
could write this:

<blockquote>
<pre>
%typemap(perl5,in) int {
   int temp;
   temp = (int) SvIV($input);
   $1 = temp;
}
</pre>
</blockquote>

In this case, the local variable <tt>temp</tt> only exists inside the
typemap code itself.  It does not affect other variables in the wrapper
function and it does not matter whether or not other typemaps happen to
use the same variable name.

<h3>Creating persistent local variables</h3>

Sometimes it is useful to declare a new local variable that exists
in the scope of the entire wrapper function. This can be done by
specifying a typemap with parameters as follows :<p>

<p>
<blockquote><pre>%typemap(python,in) int *INPUT(int temp) {
    temp = (int) PyInt_AsLong($input);
    $1 = &amp;temp;
}

</pre></blockquote>

In this case, <tt>temp</tt> becomes a local variable in
the scope of the entire wrapper function. When you set it to a value,
that values persists for the duration of the wrapper function and gets
cleaned up automatically on exit. This is particularly useful when
a typemap needs to create a temporary value, but doesn't want to rely on heap allocation.

<p>
It is perfectly safe to use more than one typemap involving local
variables in the same declaration. For example, you could declare a
function as :<p>

<p>
<blockquote><pre>void foo(int *INPUT, int *INPUT, int *INPUT);

</pre></blockquote>

This is safely handled because SWIG implicitly renames all local
variable references with an argument number suffix.  Therefore, the
generated code would actually look like this:

<blockquote>
<pre>
wrap_foo() {
   int *arg1;    /* Actual arguments */
   int *arg2;
   int *arg3;
   int temp1;    /* Locals declared in the INPUT typemap */
   int temp2;
   int temp3;
   ...
   {
       temp1 = (int) PyInt_AsLong(...);
       arg1 = &amp;temp1;
   }
   {
       temp2 = (int) PyInt_AsLong(...);
       arg2 = &amp;temp2;
   }
   {
       temp3 = (int) PyInt_AsLong(...);
       arg3 = &amp;temp3;
   }
   ...
}
</pre>
</blockquote>

<p>
Some typemaps do not recognize local variables (or they may simply not
apply). At this time, only the "in", "argout", "default", and "ignore"
typemaps support local variables.<p>

<p>
It is also important to note that the primary use of local variables
is to create stack-allocated objects for temporary use inside a
wrapper function (this is faster and less-prone to error than
allocating data on the heap).  In general, the variables are not intended
to pass information between different types of typemaps.  However, this
can be done if you realize that local names have the argument number appended
to them.  For example, you could do this:

<blockquote>
<pre>
%typemap(python,in) int *(int temp) {
   temp = (int) PyInt_AsLong($input);
   $1 = &temp;
}

%typemap(argout) int * {
   PyObject *o = PyInt_FromLong(temp$argnum);
   ...
}
</pre>
</blockquote>

In this case, the <tt>$argnum</tt> variable is expanded into the argument
number.  Therefore, the code will reference the appropriate local
such as <tt>temp1</tt> and <tt>temp2</tt>.   It should be noted that there are 
plenty of opportunities to break the universe here and that accessing locals
in this manner should probably be avoided.  At the very least, you should make
sure that the typemaps sharing information have exactly the same types and names.

<p>
<B>HERE</b>

<h3> Special variables</h3>

The following special variables may be used within a typemap
conversion code :<p>

<center><img src="ch6.table.3.png"></center>
<p>
When found in the conversion code, these variables will be replaced
with the correct values. Not all values are used in all
typemaps. Please refer to the SWIG reference manual for the precise
usage. <p>

<h2> Typemaps for handling arrays</h2>

One of the most common uses of typemaps is providing some support for
arrays. Due to the subtle differences between pointers and arrays in
C, array support is somewhat limited unless you provide additional
support. For example, consider the following structure appears in an
interface file :<p>

<p>
<blockquote><pre>struct Person {
	char name[32];
	char address[64];
	int id;
};

</pre></blockquote>

When SWIG is run, you may get the following warnings :<p>

<p>
<blockquote><pre>swig -python  example.i
Generating wrappers for Python
example.i:2.  Warning. Array member will be read-only.
example.i:3.  Warning. Array member will be read-only.
</pre></blockquote>

<p>
These warning messages indicate that SWIG does not know how you want
to set the name and address fields. As a result, you will only be able
to query their value.<p>
<p>
To fix this, we could supply two typemaps in the file such as the
following :<p>

<blockquote><pre>

%typemap(memberin) char [32] {
	strncpy($target,$source,32);
}
%typemap(memberin) char [64] {
	strncpy($target,$source,64);
}

</pre></blockquote>

The "memberin" typemap is used to set members of structures and
classes. When you run the new version through SWIG, the warnings will
go away and you can now set each member. It is important to note that
<tt>char[32]</tt> and <tt>char[64]</tt> are different datatypes as far
as SWIG typemaps are concerned. However, both typemaps can be combined
as follows :<p>

<p>
<blockquote><pre>// A better typemap for char arrays
%typemap(memberin) char [] {
	strncpy($target,$source,$dim0);
}

</pre></blockquote>

When an empty dimension is used in a typemap, it matches any array dimension.
When used, the special variable <tt>$dim0</tt> will contain
the real dimension of the array and can be used as shown above.<p>

<p>
Multidimensional arrays can also be handled by typemaps. For example :<p>
<p>

<blockquote><pre>// A typemap for handling any int [][] array
%typemap(memberin) int [][] {
	int i,j;
	for (i = 0; i &lt; $dim0; i++)
		for (j = 0; j &lt; $dim1; j++) {
			$target[i][j] = *($source+$dim1*i+j);
		}
}

</pre></blockquote>

When multi-dimensional arrays are used, the symbols <tt>$dim0,</tt>
<tt>$dim1</tt>,<tt> $dim2</tt>, etc... get replaced by the actual
array dimensions being used. <p>
<p>

<h2> Typemaps and the SWIG Library</h2>

Writing typemaps is a tricky business. For this reason, many common
typemaps can be placed into a SWIG library file and reused in other
modules without having to worry about nasty underlying details. To do
this, you first write a file containing typemaps such as this :<p>
<p>

<blockquote><pre>// file : stdmap.i
// A file containing a variety of useful typemaps

%typemap(tcl,in) int INTEGER {
	...
}
%typemap(tcl,in) double DOUBLE {
	...
}
%typemap(tcl,out) int INT {
	...
}
%typemap(tcl,out) double DOUBLE {
	...
}
%typemap(tcl,argout) double DOUBLE {
	...
}
// and so on...

</pre></blockquote>

This file may contain dozens or even hundreds of possible
mappings. Now, to use this file with other modules, simply include it
in other files and use the <tt>%apply</tt> directive :<p>

<p>
<blockquote><pre>// interface.i
// My interface file

%include stdmap.i                         // Load the typemap library

// Now grab the typemaps we want to use
%apply double DOUBLE {double};

// Rest of your declarations
</pre></blockquote>

<p>
In this case, <tt>stdmap.i</tt> contains a variety of standard
mappings. The <tt>%apply</tt> directive lets us apply specific
versions of these to new datatypes without knowing the underlying
implementation details.<p>

<p>
To clear a typemap that has been applied, you can use the
<tt>%clear</tt> directive. For example :<p>
<p>
<blockquote><pre>%clear double x; 			// Clears any typemaps being applied to double x
</pre></blockquote>

<h2> Implementing constraints with typemaps</h2>

One particularly interesting application of typemaps is the
implementation of argument constraints. This can be done with the
"check" typemap. When used, this allows you to provide code for
checking the values of function arguments. For example :<p>
<p>
<blockquote><pre>%module math

%typemap(perl5,check) double *posdouble {
	if ($target &lt; 0) {
		croak("Expecting a positive number");
	}
}

...
double sqrt(double posdouble);

</pre></blockquote>

This provides a sanity check to your wrapper function. If a negative
number is passed to this function, a Perl exception will be raised and
your program terminated with an error message.<p>

<p>
This kind of checking can be particularly useful when working with
pointers. For example :<p>
<p>
<blockquote><pre>%typemap(python,check) Vector * {
	if ($target == 0) {
		PyErr_SetString(PyExc_TypeError,"NULL Pointer not allowed");
		return NULL;
	}
}

</pre></blockquote>

will prevent any function involving a <tt>Vector *</tt> from accepting
a NULL pointer. As a result, SWIG can often prevent a potential
segmentation faults or other run-time problems by raising an exception
rather than blindly passing values to the underlying C/C++ program.<p>

<h2> Typemap examples</h2>

Typemaps are inherently language dependent so more examples appear in
later chapters. The SWIG<tt> Examples </tt>directory also includes a
variety of examples. Sophisticated users may gain more by examining
the <tt>typemaps.i</tt> and <tt>constraints.i </tt>SWIG library
files.<p>

<h2> How to break everything with a typemap</h2>

It should be emphasized that typemaps provide a direct mechanism for
modifying SWIG's output. As a result, it can be very easy to break
almost everything if you don't know what you're doing. For this
reason, it should be stressed that typemaps are not required in order
to use SWIG with most kinds of applications. Power users, however,
will probably find typemaps to be a useful tool for creating extremely
powerful scripting language extensions. <p>

<h2> Typemaps and the future</h2>

The current typemap mechanism is in the process of refinement
and will probably be extended to handle groups of types in a future release.

<!--

<h2> The SWIG Pointer Library</h2>

If your interface involves C pointers, chances are you will need to
work with these pointers in some way or another. The SWIG pointer
library provides a collection of useful methods for manipulating
pointers. To use the library, simply put the following declaration in
your interface file :<p>

<p>
<blockquote><pre>%include pointer.i 				// Grab the SWIG pointer library

</pre></blockquote>
or run SWIG as follows :<p>
<p>
<blockquote><pre>swig -perl5 -lpointer.i interface.i 

</pre></blockquote>

Doing so adds a collection of pointer manipulation functions that are
described below. The functions are mainly designed to work with basic
C datatypes, but can often be used with more complicated
structures.<p>

<h3> Pointer Library Functions</h3>

<b>ptrcreate(type,?value?,?nitems?)</b><p>
<dl>
<dt><dd>
<dt><dd>Creates a new object and returns a pointer to
it. <tt>type</tt> is a string containing the C datatype and may be one
of
"<tt>int</tt>","<tt>short</tt>","<tt>long</tt>","<tt>float</tt>","<tt>double</tt>","<tt>char</tt>","<tt>char
*</tt>", or "<tt>void</tt>". <tt>value</tt> is the optional initial
value to be assigned to the object. <tt>nitems</tt> is an optional
parameter containing the number of objects to create. By default it is
1, but specifying another value allows you to create an array of
values. This function is really just a wrapper around the C
<tt>malloc()</tt> function.

</dl>
<b></b><p>
<b>ptrfree(ptr)</b><p>
<dl>
<dt><dd>Destroys an object created by <tt>ptrcreate</tt>. It is
generally unsafe to use this function on objects not created by
<tt>ptrcreate</tt>. Calls the C <tt>free()</tt> function.
</dl>
<p>
<b>ptrvalue(ptr,?index?,?type?)</b><p>
<dl>
<dt><dd>This dereferences a pointer and returns the value that it is
pointing to. <tt>index</tt> is an optional parameter that allows array
access by returning the value of <tt>ptr[index]</tt>. <tt>type</tt> is
an optional parameter that explicitly specifies the datatype. Since
SWIG pointers are encoded with type information, the type is usually
unnecessary. The <tt>type</tt> parameter provides somewhat better
performance and allows you to dereference a pointer of different type
however.
<dt><dd>
</dl>
<b>ptrset(ptr, value, ?index?, ?type?)</b><p>
<dl>
<dt><dd>Sets the value of the object a pointer is pointing
to. <tt>value</tt> is the new value of the object. <tt>index </tt>is
an optional parameter allowing array access by setting <tt>ptr[index]
= value</tt>. <tt>type </tt>is an optional parameter that explicitly
specifies the datatype as described above.
<dt><dd>
</dl>
<b>ptrcast(ptr, newtype)</b><p>
<dl>
<dt><dd>Casts a pointer to a new datatype and returns the new
value. <tt>newtype</tt> is a string containing the new datatype and
may either be the "mangled" version used by SWIG (such as
"<tt>_Vector_p</tt>") or the C version (such as "<tt>Vector
*</tt>"). This function works with any kind of pointer value. In
additional to pointers, <tt>ptr</tt> may also hold an integer value in
which case the integer is turned into a pointer of given type.
<dt><dd>
</dl>
<b>ptradd(ptr, offset)</b><p>
<dl>
<dt><dd>Adds an offset to a pointer and returns a new
pointer. <tt>offset</tt> is specified as the number of objects except
for unknown complex datatypes in which case it is the number of
bytes. For example, is <tt>ptr</tt> is a "<tt>double *</tt>",
<tt>ptradd(ptr,1)</tt> will return the next double. On the other hand,
if if <tt>ptr</tt> is "<tt>Vector *</tt>", then <tt>ptradd(ptr,1)</tt>
will update the pointer by 1 byte.
<dt><dd>
</dl>
<b>ptrmap(type1,type2)</b><p>
<dl>
<dt><dd>This performs a "runtime typedef" and makes SWIG recognize
pointers of <tt>type1</tt> and <tt>type2</tt> as
equivalent. <tt>type1</tt> and <tt>type2</tt> are specified as
strings. Not generally needed, but sometimes useful.
</dl>

<h3> A simple example</h3>

Suppose you have the following C function :<p>

<blockquote><pre>
void add(double a, double b, double *result) {
	*result = a + b;
}

</pre></blockquote>

To manage the result output, we can write an interface file like this
:<p>

<p>
<blockquote><pre>%module example
%include pointer.i

extern void add(double a, double b, double *result);

</pre></blockquote>

Now, let's use the pointer library (shown for a few languages) :<p>

<blockquote><pre>
# Tcl 
set result [ptrcreate double]          ;# Create a double
add 4.5 3 $result                      ;# Call our C function
puts [ptrvalue $result]                ;# Print out the result
ptrfree $result                        ;# Destroy the double

# Perl5
use example;
package example;                        # Functions are in example package
$result = ptrcreate("double");          # Create a double
add(4.5,3,$result);                     # Call C function
print ptrvalue($result),"\n";           # Print the result
ptrfree($result);                       # Destroy the double

# Python
import example
result = example.ptrcreate("double")    # Create a double
example.add(4.5,3,result)               # Call C function
print example.ptrvalue(result)          # Print the result
example.ptrfree(result)                 # Destroy the double

</pre></blockquote>

In this case, the idea is simple--we create a pointer, pass it to our
C function, and dereference it to get the result. It's essentially
identical to how we would have done it in C (well, minus the function
call to dereference the value).<p>

<h3> Creating arrays</h3>

Now suppose you have a C function involving arrays :<p>
<p>
<blockquote><pre>void addv(double a[], double b[], double c[], int nitems) {
	int i;
	for (i = 0; i &lt; nitems; i++) {
		c[i] = a[i]+b[i];
	}
}

</pre></blockquote>

This is also easily handled by our pointer library. For example (in Python) :<p>

<p>
<blockquote><pre># Python function to turn a list into an "array"
def build_array(l):
	nitems = len(l)
	a = ptrcreate("double",0,nitems)
	i = 0
	for item in l:
		ptrset(a,item,i)
		i = i + 1
	return a

# Python function to turn an array into list
def build_list(a,nitems):
	l = []
	for i in range(0,nitems):
		l.append(ptrvalue(a,i))
	return l

# Now use our functions
a = listtoarray([0.0,-2.0,3.0,9.0])
b = build_array([-2.0,3.5,10.0,22.0])
c = ptrcreate("double",0,4)            # For return result
add(a,b,c,4)                           # Call our C function
result = build_list(c)                 # Build a python list from the result
print result
ptrfree(a)
ptrfree(b)
ptrfree(c)

</pre></blockquote>

This example may look quite inefficient on the surface (due to the
translation of Python lists to and from C arrays). However, if you're
working with lots of C functions, it's possible to simply pass C
pointers around between them without any translation. As a result,
applications can run fast--even when controlled from a scripting
language. It's also worth emphasizing that the <tt>ptrcreate()</tt>
function created a real C array that can be interchanged with other
arrays. The <tt>ptrvalue()</tt> function can also dereference a C
pointer even if it wasn't created from Python. <p>

<h3> Packing a data structure</h3>

The pointer library can even be used to pack simple kinds of
data-structures, perhaps for sending across a network, or simply for
changing the value. For example, suppose you had this data
structure:<p>

<p>
<blockquote><pre>struct Point {
	double x,y;
	int color;
};

</pre></blockquote>

<p>
You could write a Tcl function to set the fields of the structure as
follows :<p>

<p>
<blockquote><pre>proc set_point { ptr x y c } {
	set p [ptrcast $ptr "double *"]       ;# Make a double *
	ptrset $p $x                          ;# Set x component
	set p [ptradd $p 1]                   ;# Update pointer
	ptrset $p $y                          ;# Set y component
	set p [ptrcast [ptradd $p 1] "int *"] ;# Update pointer and cast
	ptrset $p $c                          ;# Set color component
}
</pre></blockquote>
<p>
This function could be used even if you didn't tell SWIG anything
about the "Point" structure above. <p>

-->

<p><hr>

<address>SWIG 1.3 - Last Modified : September 23, 2001</address>
</body>
</html>
