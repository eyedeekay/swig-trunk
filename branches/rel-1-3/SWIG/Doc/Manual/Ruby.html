<!-- Published by Quadralay WebWorks HTML Lite 1.5.1 -->
<!-- And munged by Dave's special Python script -->
<!-- Further modified by Hugh Sasse <hgs@dmu.ac.uk> -->
<html>
<head>
<title>SWIG and Ruby</title>
</head>

<body bgcolor="#ffffff">
<a name="n0"></a><h1>SWIG and Ruby</h1>

<p><ul>
<li> <a href="#n1">Preliminaries</a>
<li> <a href="#n2">Building Ruby Extensions under Windows 95/NT</a>
</ul>

This chapter describes SWIG's support of Ruby. <p>

Note that this chapter is in its early infant stage and only really has some advice for using SWIG and Ruby on Windows. <p>

<a name="n1"></a><h2> Preliminaries</h2>
SWIG 1.3 is known to work with Ruby 1.6.4 and Ruby 1.6.5, but should work with other versions. Given the choice, you should use the latest version of Ruby. You should also determine if your system supports shared libraries and dynamic loading. SWIG will work with or without dynamic loading, but the compilation process will vary.<p>
<a name="n14"></a><h3> Running SWIG</h3>
<p>
As described in the <A HREF="Introduction.html">introduction</A>, a
module is created from an interface file, which contains function
prototypes and variable declarations.  For <tt>example.c</tt> this would
conventionally be called <tt>example.i</tt>.  Often it may be
possible to use the C file itself as if it were a <tt>.i</tt> file,
as described in the Shortcuts section of the <A
HREF="Introduction.html">introduction</A>.
</p>
<p>
To build a Ruby module, run SWIG using the <tt>-ruby</tt> option :<p>
<p>
<blockquote><pre>%swig -ruby example.i
</pre></blockquote>
<p>
It should be noted that if the <tt>.c</tt> file is used instead of the
<tt>.i</tt> file, then the <tt>-module Example</tt> must be used on the
command line:
</p>
<blockquote><pre>%swig -ruby -module Example example.i
</pre></blockquote>
<p>
Alternatively, a real <tt>.i</tt> file may be created containing
</p>
<blockquote><pre>%module Example 
</pre></blockquote>
<p>
Swig will create <tt>example_wrap.c</tt> which together with
<tt>example.c</tt> can then be compiled and linked to produce
<tt>example.so</tt>.  This library can then be handled by Ruby's
<tt>require</tt> statement.
</p>
<p>
If many <tt>.c</tt> files are to be used together in the same module, then
several <tt>.i</tt> files may be tied together by creating one overall
<tt>.i</tt> file
</P>
<blockquote><pre>
%module MyModule
%include somefuncs.i
%include someotherfuncs.i
</pre></blockquote>


<a name="n16"></a><h3> Compiling a dynamic module</h3>
<!-- Documentation on how to use/modify the Examples/Makefile needs -->
<!-- to be added here. This is prefereablt because it holds library -->
<!-- path information that the user may not remember. -->
<p>Conventionally with SWIG on Unix the compilation of examples
is done using the file
<tt>Example/Makefile</tt>.  This
makefile performs a manual module compilation which is platform
specific.  Typically, the steps look like this (Linux):
</p>
<blockquote>
<pre>
% swig -ruby example.i
% gcc -fpic -c example_wrap.c -I/usr/local/lib/ruby/1.4/i686-linux
% gcc -shared example_wrap.o $(OBJS) -o example.so
</pre>
</blockquote>
<p>
However the politically "correct" way to compile a Ruby extension is to
follow the steps described <tt>README.EXT</tt> in Ruby distribution:
</p>
<ol>
<li>Create a file called <tt>extconf.rb</tt> that looks like the
following:</>
<blockquote>
<pre>
require 'mkmf'
create_makefile('interface')
</pre>
</blockquote>
<li>Type the following to build the extension:</p>
<blockquote>
<pre>
% ruby extconf.rb
% make
% make install
</pre>
</blockquote>
</ol>
Because the compilation step is performed here, there should be no need
to invoke the SWIG <tt>Examples/Makefile</tt>

<a name="n18"></a><h3> Using your module</h3>
<p>
The library produced by SWIG contains a module in the Ruby sense.  Ic
may be accessed by having statements such as
</p>
<blockquote>
<pre>
require "Example"

Example.my_function(this, that, other)
</pre>
</blockquote>
<p>
in the code.
</p>
<a name="n2"></a><h2> Building Ruby Extensions under Windows 95/NT</h2>
Building a SWIG extension to Ruby under Windows 95/NT is roughly similar to the process used with Unix.   Normally, you will want to produce a DLL that can be loaded into the Ruby interpreter.    This section covers the process of using SWIG with Microsoft Visual C++ 6 although the procedure may be similar with other compilers.   In order to build extensions, you will need to download the source distribution to the Ruby package as you will need the Ruby header files.<p>
<a name="n20"></a><h3> Running SWIG from Developer Studio</h3>
If you are developing your application within Microsoft developer studio, SWIG can be invoked as a custom build option.      The process roughly follows these steps :<p>
<p>
<ul>
<li>Open up a new workspace and use the AppWizard to select a DLL project.
<li>Add both the SWIG interface file (the .i file), any supporting C files, and the name of the wrapper file that will be created by SWIG (ie. <tt>example_wrap.c</tt>).   Note : If using C++, choose a different suffix for the wrapper file such as <tt>example_wrap.cxx</tt>. Don't worry if the wrapper file doesn't exist yet--Developer Studio will keep a reference to it around.
<li>Select the SWIG interface file and go to the settings menu.   Under settings, select the "Custom Build" option.
<li>Enter "SWIG" in the description field.
<li>Enter "<tt>swig -ruby -o $(ProjDir)\$(InputName)_wrap.c $(InputPath)</tt>" in the "Build command(s) field". You may have to include the path to swig.exe.
<li>Enter "<tt>$(ProjDir)\$(InputName)_wrap.c</tt>" in the "Output files(s) field".
<li>Next, select the settings for the entire project and go to the C/C++ tab and select the Preprocessor category. Add NT=1 to the Preprocessor definitions. This must be set else you will get compilation errors. Also add IMPORT to the preprocessor definitions, else you may get runtime errors. Also add the include directories for your Ruby installation under "Additional include directories".
<li>Next, select the settings for the entire project and go to the Link tab and select the General category. Set the name of the output file to match the name of your Ruby module (ie. example.dll). Next add the Ruby library file to your link libraries under Object/Library modules.  For example "mswin32-ruby16.lib. You also need to add the path to the library under the Input tab - Additional library path.
<li>Finally still under the Link tab, add the dll entry point in the Project Options: Use "/EXPORT:Init_example" for when you have set the swig module name to 'example'. In general use "/EXPORT:Init_<module>", where <module> is the swig module name (specified using %module in your interface file).
<li>Build your project.
</ul>
<p>
Now, assuming all went well, SWIG will be automatically invoked when you build your project.  Any changes made to the interface file will result in SWIG being automatically invoked to produce a new version of the wrapper file.  To run your new Ruby extension, simply run Ruby and use the <tt>require</tt> command as normal. For example if you have this ruby file run.rb:<p>
<p>
<blockquote><pre>
# file: run.rb
require 'example'

# Call a c function
print "Foo = ", Example.Foo, "\n"
</pre></blockquote>

Ensure the dll just built is in your path or current directory, then run the Ruby script from the DOS/Command prompt:
<blockquote><pre>
c:\swigtest&gt;ruby run.rb
Foo = 3.0
</pre></blockquote>

<p><hr>

</body>
</html>
