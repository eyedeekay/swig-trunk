<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>SWIG and Ocaml</title>
    
</head>
  <body bgcolor="#ffffff">
          <a name="n1"></a>         
<a name="n1"></a><H1>15 SWIG and Ocaml</H1>
<!-- INDEX -->
<ul>
<li><a href="#n2">Preliminaries</a>
<ul>
<li><a href="#n3">Running SWIG</a>
<li><a href="#n4">Getting the right header files</a>
<li><a href="#n5">Compiling the code</a>
<li><a href="#n6">Current thoughts on best practice for Ocaml</a>
<li><a href="#n7">Using your module</a>
<li><a href="#n8">Compilation problems and compiling with C++</a>
</ul>
<li><a href="#n9">The low-level Ocaml/C interface</a>
<ul>
<li><a href="#n10">The generated module</a>
<li><a href="#n11">Types</a>
<li><a href="#n12">Enums</a>
<li><a href="#n13">C++ Classes</a>
<li><a href="#n14">Exceptions</a>
</ul>
</ul>
<!-- INDEX -->



                This chapter describes SWIG's
support of Ocaml.  Ocaml     is a relatively recent addition to the ML family,
and is a recent   addition     to SWIG.  It's the second compiled, typed
language to be added.    Ocaml   has  widely acknowledged benefits for engineers,
mostly derived  from  a sophistocated    type system, compile-time checking
which eliminates  several  classes of  common  programming errors, and good
native performance.   While  all of this  is wonderful,  there are well-written
C and C++ libraries  that  Ocaml users  will want to  take advantage of as
part of their arsenal  (such  as SSL and  gdbm), as well  as their own mature
C and C++ code.  SWIG  allows   this code  to be used in  a natural, type-safe
way with Ocaml, by  providing   the necessary,   but repetetive  glue code
which creates and uses Ocaml values  to communicate   with C and C++ code.
 In addition, SWIG also produces the needed Ocaml source   that binds  types,
variants, functions,  class, etc.        

<a name="n2"></a><H2>15.1 Preliminaries</H2>


                  SWIG 1.3 works with Ocaml 3.04 and above.  Given the choice,
   you  should  use the latest stable release.  The SWIG Ocaml module has
been   tested  on Linux (PPC,MIPS,Intel,Sparc) and Cygwin on Windows.  The
best  way to determine    whether your system will work is to compile the
examples  and test-suite  which  come with SWIG.  You can do this by running
<tt>make  check</tt> from  the  SWIG root directory after installing SWIG.
 The Ocaml  module has been  tested using the system's dynamic linking  (the
usual -lxxx  agains libxxx.so,  but not using the explicit dynamic linking
provided by  the Dl package  <a
 href="http://www.ocaml-programming.de/packages/documentation/dl/"> http://www.ocaml-programming.de/packages/documentation/dl/ 
      </a>, although I suspect that it will work without a problem.

<a name="n3"></a><H3>15.1.1 Running SWIG</H3>


                  The basics of getting a SWIG Ocaml module up and running
 can   be  seen  from one of SWIG's example Makefiles, but is also described
 here.   To  build  an Ocaml module, run SWIG using the <tt>-ocaml</tt> option. 
  Enabling   proxy  classes <tt>-objects</tt> is also used.  In order to disable
 the  non-object  interface, making methods only show up in the .mli as class
 methods, specify  <tt>-onlyobjects</tt>.             
<p> </p>
                       
<blockquote>                                    
  <pre>%swig -ocaml example.i<br></pre>
            </blockquote>
                         
<p> This will produce 3 files. The file <tt>example_wrap.c</tt> contains
all of the C code needed to build an Ocaml module.  To build the module,
you will compile the file  <tt>example_wrap.c</tt> with <tt>ocamlc</tt> or
<tt>ocamlopt</tt> to create the needed .o file.  You will need to compile
the resulting .ml and .mli files as well, and do the final link with -custom
(not needed for native link). </p>
               
<a name="n4"></a><H3>15.1.2 Getting the right header files</H3>


                  You may need the libswigocaml.h file that comes with the
 distribution     to  be included.  It provides several useful functions
that  almost all  programs    that use SWIG will need.  It is located in
$(prefix)/include/libswigocaml.h       where $(prefix) is usually /usr/local,
but could be /usr.  This is set    at   configure time.    <a name="n6"></a>
        
<a name="n5"></a><H3>15.1.3 Compiling the code</H3>


                  Use <tt>ocamlc</tt> or <tt>ocamlopt</tt> to compile your
 SWIG   interface   like:             
<p> </p>
                       
<blockquote>                                    
  <pre>% ocamlc -c -ccopt "-I/usr/include/foo -I/usr/local/include" example_wrap.c<br>% ocamlc -c example.mli<br>% ocamlc -c example.ml<br></pre>
            </blockquote>
                         
<p> <tt>ocamlc</tt> is aware of .c files and knows how to handle them. Unfortunately,
      it does not know about .cxx, .cc, or .cpp files, so when SWIG is invoked
     in C++ mode, you must: </p>
                       
<blockquote>                                    
  <pre>% cp example_wrap.cxx example_wrap.cxx.c<br>% ocamlc -c ... -ccopt -xc++ example_wrap.cxx.c<br>% ...<br></pre>
            </blockquote>

<a name="n6"></a><H3>15.1.4 Current thoughts on best practice for Ocaml</H3>


            Because the VC compiler (cl) needs link options specified after 
 all   compiler  options, and ocamlc doesn't really understand that, I think 
 that   this is  the best way to link ocaml code with C++ code.  I formulated 
 this   method to make it easy for co-workers who rely on MSDev to create 
GUIs, etc..  to live in harmony with the ocaml parts of the application. 
        
<p> Let's say you have ocaml sources foo.ml and bar.ml and interface frob.i;
     </p>
                 
<p> </p>
                 
<blockquote>                           
  <pre>swig -c++ -objects frob.i<br>ocamlc -custom -c frob.mli<br>ocamlc -custom -c frob.ml<br>cp frob_wrap.cxx frob_wrap.c<br>ocamlc -custom -c -I$(FROBLIB)/include frob_wrap.c<br>ocamlc -custom -c foo.ml<br>ocamlc -custom -c bar.ml<br>ocamlc -pack -o foobar.cmo foo.cmo bar.cmo frob.cmo<br>ocamlc -custom -output-obj -o foobar.obj foobar.cmo<br></pre>
         </blockquote>
                   
<p> At this point, foobar.obj can be included in your MSVC project and linked
     against other code.  This is how you link it: </p>
                 
<blockquote>                           
  <pre>link /OUT:big_program.exe \<br>  other1.obj other2.obj foobar.obj frob_wrap.obj \<br>  $(OCAMLLIB)/ocamlrun.lib $(FROBLIB)/lib/frob.lib<br></pre>
         </blockquote>
                   
<a name="n7"></a><H3>15.1.5 Using your module</H3>


                   You can test-drive your module by building a toplevel
ocaml   interpreter.     Consult the ocaml manual for details.          
  
<p>When linking any ocaml bytecode with your module, use the -custom option
      to build your functions into the primitive list. This option is not
needed    when you build native code.<br>

<a name="n8"></a><H3>15.1.6 Compilation problems and compiling with C++</H3>


                   As mentioned above, .cxx files need special handling to 
be  compile    with  <tt>ocamlc</tt>.  Other than that, C code that uses <tt>class</tt>
   as a non-keyword, and C code that is too liberal with pointer types may
 not  compile under the C++ compiler.  Most code meant to be compiled as
C++  will  not have problems.    

<a name="n9"></a><H2>15.2 The low-level Ocaml/C interface</H2>


         In order to provide access to overloaded functions, and provide
sensible     outputs from them, all C entites are represented as members
of the c_obj    type:<br>
        <br>
        In the code as seen by the typemap writer, there is a value, swig_result,
    that always contains the current data. &nbsp;<br>
                 
<blockquote>                        
  <pre>type c_obj =<br>    C_void<br>  | C_bool of bool<br>  | C_char of char<br>  | C_uchar of char<br>  | C_short of int<br>  | C_ushort of int<br>  | C_int of int<br>  | C_uint of int32<br> &nbsp;| C_int32 of int32<br>  | C_int64 of int64<br>  | C_float of float<br>  | C_double of float<br>  | C_ptr of int64 * int64<br>  | C_array of c_obj array<br> &nbsp;| C_list of c_obj list<br>  | C_obj of (string -&gt; c_obj -&gt; c_obj)<br>  | C_string of string<br>  | C_enum of c_enum_tag<br></pre>
        </blockquote>
        A few functions exist which generate and return these:<br>
               
<ul>
          <li>caml_ptr_val receives a c_obj and returns a void *. &nbsp;This
  should   be used for all pointer purposes.</li>
          <li>caml_long_val receives a c_obj and returns a long. &nbsp;This 
 should   be used for most integral purposes.<br>
          </li>
          <li>caml_val_ptr receives a void * and returns a c_obj.</li>
          <li>caml_val_bool receives a C int and returns a c_obj representing 
  it's  bool value.</li>
          <li>caml_val_(u)?(char|short|int|long|float|double) receives an 
appropriate    C value and returns a c_obj representing it.</li>
          <li>caml_val_string receives a char * and returns a string value.</li>
          <li>caml_val_string_len receives a char * and a length and returns
  a  string  value.</li>
          <li>caml_val_obj receives a void * and an object type and returns 
 a  C_obj,  which contains a closure giving method access.</li>
               
</ul>
        Because of this style, a typemap can return any kind of value it
wants    from  a function. &nbsp;This enables out typemaps and inout typemaps
to  work  well.  &nbsp;The one thing to remember about outputting values
is that  you  must append them to the return list with swig_result = caml_list_append(swig_result,v).
    &nbsp;This function will return a new list that has your element appended.
    Upon return to caml spaces, a list containing a single item contains
only     that item (i.e. [ C_int 3 ] -&gt; C_int 3), and a list containing
more  than   one item is wrapped in C_list (i.e. [ C_char 'a' ; C_char 'b'
-&gt;  C_list   [ C_char 'a' ; C_char b ]). &nbsp;This is in order to make
return  values  easier to handle when functions have only one return value,
such as constructors,   and operators. &nbsp;In addition, string, pointer,
and object values are  interchangable with respect to caml_ptr_val, so you
can allocate memory as  caml strings and still use the resulting pointers
for C purposes, even using  them to construct objects on.<br>
        <br>
        The wild card type that you can use in lots of different ways is
C_obj.    &nbsp;It allows you to wrap any type of thing you like as an object
using    the same mechanism that the ocaml module does. &nbsp;When evaluated
<br>
        <br>
        Please read <a
 href="http://caml.inria.fr/ocaml/htmlman/manual031.html">"Interfacing  
 C with Objective Caml"</a> before you start writing typemaps. &nbsp;This
 gives needed information about constructing values.<br>
        <br>

<a name="n10"></a><H3>15.2.1 The generated module</H3>


                  The SWIG <tt>%module</tt> directive specifies the name
of  the   Ocaml   module  to be generated.  If you specified `<tt>%module
example</tt>',    then   your  Ocaml code will be accessible in the module
Example.  The module   name   is  always capitalized as is the ocaml convention.
 Note that you  must not   use  any Ocaml keyword to name your module.  Remember 
that the  keywords are  not  the same as the C++ ones.   <br>
          
<a name="n11"></a><H3>15.2.2 Types</H3>


        As discussed above, the C type system is represented dynamically
by  the   ocaml module. &nbsp;This overloaded functions and operators to
work  as intended,   even though some of these features don't exist in ocaml
(such  as overloaded   operator "()").<br>
                  
<a name="n12"></a><H3>15.2.3 Enums</H3>


                  SWIG will wrap enumerations as polymorphic variants in
the   output   Ocaml  code, as above in C_enum.&nbsp; In order to support
all C++-style    uses of enums, the function int_to_enum and enum_to_int
are provided for   ocaml code to produce and consume these values as integers.
&nbsp;Other than  that, correct uses of enums will not have a problem. &nbsp;Since
enum labels  may overlap between enums, the enum_to_int and int_to_enum functions
 take  an enum type label as an argument.     Example:<br>
            <br>
            <code>%module enum_test<br>
     %{<br>
            enum c_enum_type { a = 1, b, c = 4, d = 8 };<br>
     %}<br>
     enum c_enum_type { a = 1, b, c = 4, d = 8 };</code><br>
               
<p> The output mli contains:<br>
        </p>
             
<blockquote>                     
  <pre>type c_enum_type = [<br>  `unknown<br>| `c_enum_type<br>]<br>type c_enum_tag = [<br>  `int of int<br>| `a<br>| `b<br>| `c<br>| `d<br>]<br>val int_to_enum c_enum_type -&gt; int -&gt; c_obj<br>val enum_to_int c_enum_type -&gt; c_obj -&gt; c_obj<br></pre>
     </blockquote>
   So it's possible to do this:   
<blockquote>      
  <pre>bash-2.05a$ ocamlmktop -custom enum_test_wrap.o enum_test.cmo -o enum_test_top<br>bash-2.05a$ ./enum_test_top <br>        Objective Caml version 3.04<br><br># open Enum_test ;;<br># let x = C_enum `a ;;<br>val x : Enum_test.c_obj = C_enum `a<br># enum_to_int `c_enum_type x ;;<br>- : Enum_test.c_obj = C_int 1<br># int_to_enum `c_enum_type 4 ;;<br>- : Enum_test.c_obj = C_enum `c<br></pre>
  </blockquote>
       
<p> </p>
   
<a name="n13"></a><H3>15.2.4 C++ Classes</H3>


                   C++ classes are represented by C_obj (string -&gt; c_obj 
 -&gt; c_obj)  wrapped closures. &nbsp;These objects contain a method list, 
 and a type, which allow them to be used like C++ objects. &nbsp;When passed 
 into typemaps that use pointers, they degrade to pointers through their "&amp;"
 method. &nbsp;Every method an object has is represented as a string in the
 object's method table, and each method table exists in memory only once.
&nbsp;In addition to any other operators an object might have, certain builtin
ones are provided by SWIG:<br>
        "~" -&gt; Delete this object (Requires C_void argument)<br>
        "&amp;" -&gt; Return an ordinary C_ptr value representing this object's 
   address (Requires C_void argument)<br>
        ":methods" -&gt; Returns a list of strings containing the names of
 the   methods  this object contains (Requires C_void argument)<br>
        ":classof" -&gt; Returns the name of the class this object belongs
 to.   &nbsp;Note  that this string belongs to the wrapper object, and not<br>
        the underlying pointer, so a typecast may alter the returned value
 wrapping    the same object.<br>
        <br>

<a name="n14"></a><H3>15.2.5 Exceptions</H3>


                Please view the "<a
 href="http://caml.inria.fr/ocaml/htmlman/manual031.html#s:c-exceptions">Raising
      Exceptions</a>" section of Interfacing C with Objective Caml.<br>
            <br>
           <br>
                 
</body>
</html>