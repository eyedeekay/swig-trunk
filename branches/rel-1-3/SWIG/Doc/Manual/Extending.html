<html>
<head>
<title>Extending SWIG</title>
</head>

<body bgcolor="#ffffff">
<h1>Extending SWIG</h1>

<b>Caution: This chapter is being rewritten! (11/25/01)</b>

<h2>Introduction</h2>
This chapter describes SWIG's internal organization and the process by which
new target languages can be developed.    First, a brief word of warning---SWIG
has been undergoing a massive redevelopment effort that has focused extensively
on its internal organization.   The information in this chapter is mostly up to
date, but changes are ongoing.   Expect to find a few inconsistencies.

<h3>Prerequisites</h3>

In order to extend SWIG, it is useful to have the following background:

<p>
<ul>
<li>An understanding of the C API for the target language.
<li>A good grasp of the C++ type system.
<li>An understanding of typemaps and some of SWIG's advanced features.
<li>Some familiarity with writing C++ (language modules are currently written in C++).
</ul>

<h3>High Level Overview</h3>

When you run SWIG on an interface, processing is handled in stages by a
few different system components:

<ul>
<li>An integrated C preprocessor reads a collection of configuration
files and the specified interface file into memory.  The preprocessor
performs the usual functions including macro expansion and file
inclusion.   However, the preprocessor also performs some transformations of the
interface.  For instance, <tt>#define</tt> statements are sometimes transformed into
<tt>%constant</tt> declarations.  In addition, information related to file/line number
tracking is inserted.

<p>
<li>A C/C++ parser reads the preprocessed input and generates a full
parse tree of all of the SWIG directives and C declarations found.
For the most part, this tree includes information about everything that
appeared in the input.  However, certain features such as C++
templates and <tt>%rename</tt> directives are handled by the parser and
may not appear in the resulting parse tree.   It is also important to
emphasize that the parser does not produce any output nor does it interact
with the target language module as it is running.

<p>
<li>One or more code generation components walk the parse tree in
order produce wrapper code.   All of SWIG's target languages are
currently implemented in this stage of processing.
</ul>

<h4>Preprocessing</h4>

The role of the preprocessor needs to be strongly emphasized. In reality, a lot
of SWIG's processing and internal configuration is managed not by code written in C, but
by configuration files that are contained in the SWIG library and parsed.   In fact, when you
run SWIG, parsing starts with a small interface file like this (note: this explains
the cryptic error messages that users sometimes get when SWIG is misconfigured or installed
incorrectly):

<blockquote>
<pre>
%include "swig.swg"             // Global SWIG configuration
%include "langconfig.swg"       // Language specific configuration
%include "yourinterface.i"      // Your interface file
</pre>
</blockquote>

The <tt>swig.swg</tt> file contains global configuration information.  In addition, this file
defines many of SWIG's standard directives as macros.  For instance, an excerpt of
of <tt>swig.swg</tt> looks like this:

<blockquote>
<pre>
...
/* Code insertion directives such as %wrapper %{ ... %} */

#define %init        %insert("init")
#define %wrapper     %insert("wrapper")
#define %header      %insert("header")
#define %runtime     %insert("runtime")

/* Access control directives */

#define %readonly    %pragma(swig) readonly;
#define %readwrite   %pragma(swig) readwrite;

/* Directives for callback functions */

#define %callback(x) %pragma(swig) callback=`x`;
#define %nocallback  %pragma(swig) nocallback;

/* Directives for attribute functions */

#define %attributefunc(_x,_y)  %pragma(swig)   attributefunction=`_x`":"`_y`;
#define %noattributefunc       %pragma(swig)   noattributefunction;

/* %ignore directive */

#define %ignore         %rename($ignore)
#define %ignorewarn(x)  %rename("$ignore:" x)

/* Generation of default constructors/destructors */

#define %nodefault     %pragma nodefault
#define %makedefault   %pragma makedefault

...
</pre>
</blockquote>

The fact that most of the standard SWIG directives are macros is intended to simplify the 
implementation of the parser.  For instance, rather than having to support dozens of
special grammar rules, it is easier to have a few basic primitives such as <tt>%pragma</tt> or
<tt>%insert</tt>.

<p>
The <tt>langconfig.swg</tt> file is supplied by the target
language. This file contains language-specific configuration
information.  More often than not, this file provides run-time wrapper
support code (e.g., the type-checker) as well as a collection of
typemaps that define the default wrapping behavior. 

<p>
Although the SWIG preprocessor is intended to mimic the behavior of the C preprocessor,
it is not meant to be a direct replacement.  Instead, its behavior is adapted for use with SWIG and
it provides a number of a non-standard extensions:

<ul>
<li>File inclusion directives such as <tt>#include &lt;stdio.h&gt;</tt> are ignored by default.
<P>
<li>When files are included, they are enclosed in a SWIG file-scope block that looks like this:
<blockquote>
<pre>
%includefile "example.i" {
...
}
</pre>
</blockquote>
These blocks are used during parsing and code generation to track the relationship between all of the files
that were included or imported into an interface.  This is especially important when SWIG is being used to create a collection
of interrelated extension modules.

<p>
<li>Preprocessing is disabled inside any <tt>%{ ... %}</tt> block.

<p>
<li><tt>#define</tt> statements are examined to see if they might be constants.  If so, they are transformed into
<tt>%constant</tt> declarations for the parser.    A <tt>#define</tt> statement is assumed to be a constant if it
does not contain any unresolved identifier names when expanded.

<p>
<li>Macro expansion supports the non-standard <tt>`x`</tt> operator.   This converts <tt>x</tt> into a quoted string unless
it is already a quoted string (in which case it remains quoted).   This is sometimes used to define SWIG directives
that support both quoted and non-quoted forms.

<p>
<li>Macros can be defined using <tt>%define</tt> and <tt>%enddef</tt>.  For example:
<blockquote>
<pre>
%define FOO(a,b)
...
%enddef
</pre>
</blockquote>
These macros differ from C preprocessor macros in two respects. First, they can span multiple lines.  Second,
when the macros are expanded, the expanded text is re-parsed by the preprocessor.
</ul>

<p>
As a debugging aide, the text that SWIG feeds to its C++ parser can be obtained by running
<tt>swig -E interface.i</tt>.   This output probably isn't too useful in general, but it
will show how macros have been expanded as well as everything else that goes into
the low-level construction of the wrapper code. 

<h4>Parsing</h4>

The current C++ parser handles a subset of C++.  Most incompatibilities with C are due to
subtle aspects of how SWIG parses declarations.  Specifically, SWIG expects all C/C++ declarations
to follow this general form:

<blockquote>
<pre>
<em>storage</em> <em>type</em> <em>declarator</em> <em>initializer</em>;
</pre>
</blockquote>

<tt><em>storage</em></tt> is a keyword such as <tt>extern</tt>,
<tt>static</tt>, <tt>typedef</tt>, or <tt>virtual</tt>.  <tt><em>type</em></tt> is a primitive
datatype such as <tt>int</tt> or <tt>void</tt>.   <tt><em>type</em></tt> may be optionally
qualified with a qualifier such as <tt>const</tt> or <tt>volatile</tt>. <tt><em>declarator</em></tt>
is a name with additional type-construction modifiers attached to it (pointers, arrays, references,
functions, etc.).  Examples of declarators include <tt>*x</tt>, <tt>**x</tt>, <tt>x[20]</tt>, and 
<tt>(*x)(int,double)</tt>.   The <tt><em>initializer</em></tt> may be a value assigned using <tt>=</tt> or 
body of code enclosed in braces <tt>{ ... }</tt>.

<p>
This declaration format covers the most common C++ programming style.  However, the C++ standard
is somewhat more flexible in the placement of the pieces.  For example, it is technically legal, although
probably poor form to write something like <tt>int typedef const a</tt> in your program.   SWIG simply
doesn't bother to deal with this (although it could probably be modified if there is sufficient demand).

<P>
The other significant difference between C++ and SWIG is in the
treatment of typenames.  In C++, if you have a declaration like this,

<blockquote>
<pre>
int blah(Foo *x, Bar *y);
</pre>
</blockquote>

it won't parse correctly unless <tt>Foo</tt> and <tt>Bar</tt> have
been previously defined as types either using a <tt>class</tt>
definition or a <tt>typedef</tt>.  The reasons for this are subtle,
but this treatment of typenames is normally integrated at the level of the C
tokenizer---when a typename appears, a different token is returned
instead of an identifier.  

<p>
SWIG does not operate in this manner--any legal identifier can be used
as a type name.  The reason for this is primarily motivated by the use of
SWIG with partially defined data.  Specifically, I wanted to make SWIG easy to use on interfaces
with missing type information.  On a more practical level however, the introduction of typenames
would greatly complicate other parts of SWIG such as the parsing of SWIG directives (many of which
also rely upon identifier names).

<p>
Because of the different treatment of typenames, the most serious limitation of the SWIG parser
is that it can't process declarations in which an extra (and unnecessary)
grouping has been used.  For example:

<blockquote>
<pre>
int (x);         /* A variable x */
int (y)(int);    /* A function y */
</pre>
</blockquote>

The parser is also unable to handle declarations with no return type or bare argument names.
For example, in an old C program, you might see things like this:

<blockquote>
<pre>
foo(a,b) {
...
}
</pre>
</blockquote>
In this case, the return type as well as the types of the arguments are taken to be an <tt>int</tt>.
However, SWIG behaves differently (in fact, the above declaration would be an abstract declarator
for a function returning a <tt>foo</tt> and taking types <tt>a</tt> and <tt>b</tt> as arguments).

<p>
<hr>

<address>SWIG 1.3 - Last Modified : November 25, 2001</address>
</body>
</html>

