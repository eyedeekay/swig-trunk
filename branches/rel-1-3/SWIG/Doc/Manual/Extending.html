<html>
<head>
<title>Extending SWIG</title>
</head>

<body bgcolor="#ffffff">
<h1>Extending SWIG</h1>

<b>Caution: This chapter is being rewritten! (11/25/01)</b>

<h2>Introduction</h2>
This chapter describes SWIG's internal organization and the process by which
new target languages can be developed.    First, a brief word of warning---SWIG
has been undergoing a massive redevelopment effort that has focused extensively
on its internal organization.   The information in this chapter is mostly up to
date, but changes are ongoing.   Expect to find a few inconsistencies.

<h3>Prerequisites</h3>

In order to extend SWIG, it is useful to have the following background:

<p>
<ul>
<li>An understanding of the C API for the target language.
<li>A good grasp of the C++ type system.
<li>An understanding of typemaps and some of SWIG's advanced features.
<li>Some familiarity with writing C++ (language modules are currently written in C++).
</ul>

Since SWIG is essentially a specialized C++ compiler, it may be useful
to have some prior experience with compiler design (perhaps even a
compilers course) to better understand certain parts of the system.  A
number of books will also be useful.  For example, "The C Programming
Language" by Kernighan and Ritchie (a.k.a, "K&R") and the "C++
Annotated Reference Manual" by Stroustrup (a.k.a, the "ARM") will be of great use.

<h3>High Level Overview</h3>

When you run SWIG on an interface, processing is handled in stages by a
few different system components:

<ul>
<li>An integrated C preprocessor reads a collection of configuration
files and the specified interface file into memory.  The preprocessor
performs the usual functions including macro expansion and file
inclusion.   However, the preprocessor also performs some transformations of the
interface.  For instance, <tt>#define</tt> statements are sometimes transformed into
<tt>%constant</tt> declarations.  In addition, information related to file/line number
tracking is inserted.

<p>
<li>A C/C++ parser reads the preprocessed input and generates a full
parse tree of all of the SWIG directives and C declarations found.
For the most part, this tree includes information about everything that
appeared in the input.  However, certain features such as C++
templates and <tt>%rename</tt> directives are handled by the parser and
may not appear in the resulting parse tree (at least not as special parse tree nodes).
It is also important to emphasize that the parser does not produce any output nor does it interact
with the target language module as it runs.   SWIG is not a one-pass compiler.

<p>
<li>One or more code generation components walk the parse tree in
order produce wrapper code.   All of SWIG's target languages are
currently implemented in this stage of processing.
</ul>

<h4>Preprocessing</h4>

The preprocessor plays a critical role in the SWIG implementation.  This is because a lot
of SWIG's processing and internal configuration is managed not by code written in C, but
by configuration files in the SWIG library.  In fact, when you
run SWIG, parsing starts with a small interface file like this (note: this explains
the cryptic error messages that new users sometimes get when SWIG is misconfigured or installed
incorrectly):

<blockquote>
<pre>
%include "swig.swg"             // Global SWIG configuration
%include "<em>langconfig.swg</em>"       // Language specific configuration
%include "yourinterface.i"      // Your interface file
</pre>
</blockquote>

The <tt>swig.swg</tt> file contains global configuration information.  In addition, this file
defines many of SWIG's standard directives as macros.  For instance, part of
of <tt>swig.swg</tt> looks like this:

<blockquote>
<pre>
...
/* Code insertion directives such as %wrapper %{ ... %} */

#define %init        %insert("init")
#define %wrapper     %insert("wrapper")
#define %header      %insert("header")
#define %runtime     %insert("runtime")

/* Access control directives */

#define %readonly    %pragma(swig) readonly;
#define %readwrite   %pragma(swig) readwrite;

/* Directives for callback functions */

#define %callback(x) %pragma(swig) callback=`x`;
#define %nocallback  %pragma(swig) nocallback;

/* Directives for attribute functions */

#define %attributefunc(_x,_y)  %pragma(swig)   attributefunction=`_x`":"`_y`;
#define %noattributefunc       %pragma(swig)   noattributefunction;

/* %ignore directive */

#define %ignore         %rename($ignore)
#define %ignorewarn(x)  %rename("$ignore:" x)

/* Generation of default constructors/destructors */

#define %nodefault     %pragma nodefault
#define %makedefault   %pragma makedefault

...
</pre>
</blockquote>

The fact that most of the standard SWIG directives are macros is
intended to simplify the implementation of the parser.  For instance,
rather than having to support dozens of special grammar rules, it is
easier to have a few basic primitives such as <tt>%pragma</tt> or
<tt>%insert</tt>.

<p>
The <em><tt>langconfig.swg</tt></em> file is supplied by the target
language. This file contains language-specific configuration
information.  More often than not, this file provides run-time wrapper
support code (e.g., the type-checker) as well as a collection of
typemaps that define the default wrapping behavior.  Note: the name of this
file depends on the target language and is usually something like <tt>python.swg</tt>
or <tt>perl5.swg</tt>.

<p>
Although the SWIG preprocessor is intended to mimic the behavior of
the C preprocessor, it is not meant to be a direct replacement.
Instead, its behavior is adapted for use with SWIG and it provides a
number of a non-standard extensions:

<ul>
<li>File inclusion directives such as <tt>#include &lt;stdio.h&gt;</tt> are ignored by default.
<P>
<li>When files are included, they are enclosed in a SWIG file-scope block that looks like this:
<blockquote>
<pre>
%includefile "example.i" {
...
}
</pre>
</blockquote>
These blocks are used during parsing and code generation to track the
relationship between all of the files that were included or imported
into an interface.  This is especially important when SWIG is being
used to create a collection of interrelated extension modules.

<p>
<li>Preprocessing is disabled inside any <tt>%{ ... %}</tt> block.

<p>
<li><tt>#define</tt> statements are examined to see if they might be constants.  If so, they are transformed into
<tt>%constant</tt> declarations for the parser.    A <tt>#define</tt> statement is assumed to be a constant if it
does not contain any unresolved identifier names when expanded.

<p>
<li>Macro expansion supports the non-standard <tt>`x`</tt> operator.   This converts <tt>x</tt> into a quoted string unless
it is already a quoted string (in which case it remains quoted).   This is sometimes used to define SWIG directives
that support both quoted and non-quoted arguments.

<p>
<li>Macro names can start with '%'.  This allows SWIG directives to be defined as macros.

<p>
<li>Macros can be defined using <tt>%define</tt> and <tt>%enddef</tt>.  For example:
<blockquote>
<pre>
%define FOO(a,b)
...
%enddef
</pre>
</blockquote>
These macros differ from C preprocessor macros in two respects. First, they can span multiple lines.  Second,
when the macros are expanded, the expanded text is re-parsed by the preprocessor.
</ul>

<p>
As a debugging aide, the text that SWIG feeds to its C++ parser can be obtained by running
<tt>swig -E interface.i</tt>.   This output probably isn't too useful in general, but it
will show how macros have been expanded as well as everything else that goes into
the low-level construction of the wrapper code. 

<h4>Parsing</h4>

The current C++ parser handles a subset of C++.  Most incompatibilities with C are due to
subtle aspects of how SWIG parses declarations.  Specifically, SWIG expects all C/C++ declarations
to follow this general form:

<blockquote>
<pre>
<em>storage</em> <em>type</em> <em>declarator</em> <em>initializer</em>;
</pre>
</blockquote>

<tt><em>storage</em></tt> is a keyword such as <tt>extern</tt>,
<tt>static</tt>, <tt>typedef</tt>, or <tt>virtual</tt>.  <tt><em>type</em></tt> is a primitive
datatype such as <tt>int</tt> or <tt>void</tt>.   <tt><em>type</em></tt> may be optionally
qualified with a qualifier such as <tt>const</tt> or <tt>volatile</tt>. <tt><em>declarator</em></tt>
is a name with additional type-construction modifiers attached to it (pointers, arrays, references,
functions, etc.).  Examples of declarators include <tt>*x</tt>, <tt>**x</tt>, <tt>x[20]</tt>, and 
<tt>(*x)(int,double)</tt>.   The <tt><em>initializer</em></tt> may be a value assigned using <tt>=</tt> or 
body of code enclosed in braces <tt>{ ... }</tt>.

<p>
This declaration format covers most common C++ declarations. However, the C++ standard
is somewhat more flexible in the placement of the pieces.  For example, it is technically legal, although
unusual to write something like <tt>int typedef const a</tt> in your program.   SWIG simply
doesn't bother to deal with this (although it could probably be modified if there is sufficient demand).

<P>
The other significant difference between C++ and SWIG is in the
treatment of typenames.  In C++, if you have a declaration like this,

<blockquote>
<pre>
int blah(Foo *x, Bar *y);
</pre>
</blockquote>

it won't parse correctly unless <tt>Foo</tt> and <tt>Bar</tt> have
been previously defined as types either using a <tt>class</tt>
definition or a <tt>typedef</tt>.  The reasons for this are subtle,
but this treatment of typenames is normally integrated at the level of the C
tokenizer---when a typename appears, a different token is returned to the parser
instead of an identifier.  

<p>
SWIG does not operate in this manner--any legal identifier can be used
as a type name.  The reason for this is primarily motivated by the use
of SWIG with partially defined data.  Specifically, 
SWIG is supposed to be easy to use on interfaces with missing type information.  On a
more practical level however, the introduction of typenames would
greatly complicate other parts of SWIG such as the parsing of SWIG
directives (many of which also rely upon identifier names).

<p>
Because of the different treatment of typenames, the most serious
limitation of the SWIG parser is that it can't process type declarations in
which an extra (and unnecessary) grouping operator is used.  For example:

<blockquote>
<pre>
int (x);         /* A variable x */
int (y)(int);    /* A function y */
</pre>
</blockquote>

The placing of extra parentheses in type declarations like this is
already recognized by the C++ community as a potential source of
strange programming errors. For example, Scott Meyers "Effective STL"
discusses this problem in a section on avoiding C++'s "most vexing
parse."
<p>

The parser is also unable to handle declarations with no return type or bare argument names.
For example, in an old C program, you might see things like this:

<blockquote>
<pre>
foo(a,b) {
...
}
</pre>
</blockquote>
In this case, the return type as well as the types of the arguments
are taken by the C compiler to be an <tt>int</tt>.  However, SWIG
interprets the above code as an abstract declarator for a function
returning a <tt>foo</tt> and taking types <tt>a</tt> and <tt>b</tt> as
arguments).

<h4>Parse Trees</h4>

The SWIG parser produces a complete parse tree of the input file before any wrapper code
is actually generated.  Each item in the tree is known as a "Node".   Each node is identified
by a symbolic tag.   Furthermore, a node may have an arbitrary number of children.
The parse tree structure and tag names of an interface can be displayed using <tt>swig -dump_tags</tt>.
For example:

<blockquote>
<pre>
$ <b>swig -c++ -python -dump_tags example.i</b>
 . top (example.i:1)
 . top . include (example.i:1)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/swig.swg:71)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/swig.swg:71)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/swig.swg:83)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/swig.swg:83)
 . top . include (example.i:4)
 . top . include . insert (/r0/beazley/Projects/lib/swig1.3/python/python.swg:7)
 . top . include . insert (/r0/beazley/Projects/lib/swig1.3/python/python.swg:8)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:19)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:19)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:19)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:20)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:20)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:20)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:21)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:21)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:21)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:22)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:22)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:22)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:23)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:23)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:24)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:24)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:25)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:25)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:26)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:26)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:29)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:29)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:32)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:32)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:42)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:42)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:42)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:42)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:45)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:45)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:46)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:46)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:49)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:49)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:61)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:61)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:61)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:62)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:62)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:63)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:63)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:66)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:66)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:66)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:66)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:69)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:69)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:72)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:72)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:75)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:75)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:75)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:84)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:84)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:114)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:114)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:114)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:124)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:124)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:137)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:137)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:154)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:154)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:164)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:164)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:173)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:173)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:173)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:182)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:182)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:191)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:191)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:200)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:200)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:208)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:208)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:208)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:211)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:211)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:211)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:214)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:214)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:214)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:214)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:217)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:217)
 . top . include (example.i:6)
 . top . include . module (example.i:2)
 . top . include . insert (example.i:6)
 . top . include . include (example.i:9)
 . top . include . include . class (example.h:3)
 . top . include . include . class . access (example.h:4)
 . top . include . include . class . constructor (example.h:7)
 . top . include . include . class . destructor (example.h:10)
 . top . include . include . class . cdecl (example.h:11)
 . top . include . include . class . cdecl (example.h:11)
 . top . include . include . class . cdecl (example.h:12)
 . top . include . include . class . cdecl (example.h:13)
 . top . include . include . class . cdecl (example.h:14)
 . top . include . include . class . cdecl (example.h:15)
 . top . include . include . class (example.h:18)
 . top . include . include . class . access (example.h:19)
 . top . include . include . class . cdecl (example.h:20)
 . top . include . include . class . access (example.h:21)
 . top . include . include . class . constructor (example.h:22)
 . top . include . include . class . cdecl (example.h:23)
 . top . include . include . class . cdecl (example.h:24)
 . top . include . include . class (example.h:27)
 . top . include . include . class . access (example.h:28)
 . top . include . include . class . cdecl (example.h:29)
 . top . include . include . class . access (example.h:30)
 . top . include . include . class . constructor (example.h:31)
 . top . include . include . class . cdecl (example.h:32)
 . top . include . include . class . cdecl (example.h:33)
</pre>
</blockquote>

Even for the most simple interface, the parse tree structure is larger than you might expect.  For example, in the
above output, a substantial number of nodes are actually generated by the <tt>python.swg</tt> configuration file
which defines typemaps and other directives.   The contents of the user-supplied input file don't appear until the end
of the output.

<p>
The contents of each parse tree node consist of a collection of attribute/value
pairs.  Internally, the nodes are simply stored as a hash table.  A display of
the parse-tree structure can be obtained using <tt>swig -dump_tree</tt>. For example:

<blockquote>
<pre>
$ swig -c++ -python -dump_tree example.i
...
      +++ include ----------------------------------------
      | name         - "example.i"

            +++ module ----------------------------------------
            | name         - "example"
            | 
            +++ insert ----------------------------------------
            | code         - "\n#include \"example.h\"\n"
            | 
            +++ include ----------------------------------------
            | name         - "example.h"

                  +++ class ----------------------------------------
                  | abstract     - "1"
                  | sym:name     - "Shape"
                  | name         - "Shape"
                  | kind         - "class"
                  | symtab       - 0x40194140
                  | sym:symtab   - 0x40191078

                        +++ access ----------------------------------------
                        | kind         - "public"
                        | 
                        +++ constructor ----------------------------------------
                        | sym:name     - "Shape"
                        | name         - "Shape"
                        | decl         - "f()."
                        | code         - "{\n    nshapes++;\n  }"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ destructor ----------------------------------------
                        | sym:name     - "~Shape"
                        | name         - "~Shape"
                        | storage      - "virtual"
                        | code         - "{\n    nshapes--;\n  }"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "x"
                        | name         - "x"
                        | decl         - ""
                        | type         - "double"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "y"
                        | name         - "y"
                        | decl         - ""
                        | type         - "double"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "move"
                        | name         - "move"
                        | decl         - "f(double,double)."
                        | parms        - double ,double 
                        | type         - "void"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "area"
                        | name         - "area"
                        | decl         - "f(void)."
                        | parms        - void 
                        | storage      - "virtual"
                        | value        - "0"
                        | type         - "double"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "perimeter"
                        | name         - "perimeter"
                        | decl         - "f(void)."
                        | parms        - void 
                        | storage      - "virtual"
                        | value        - "0"
                        | type         - "double"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "nshapes"
                        | name         - "nshapes"
                        | decl         - ""
                        | storage      - "static"
                        | type         - "int"
                        | sym:symtab   - 0x40194140
                        | 
                  +++ class ----------------------------------------
                  | sym:name     - "Circle"
                  | name         - "Circle"
                  | kind         - "class"
                  | bases        - 0x40194510
                  | symtab       - 0x40194538
                  | sym:symtab   - 0x40191078

                        +++ access ----------------------------------------
                        | kind         - "private"
                        | 
                        +++ cdecl ----------------------------------------
                        | name         - "radius"
                        | decl         - ""
                        | type         - "double"
                        | 
                        +++ access ----------------------------------------
                        | kind         - "public"
                        | 
                        +++ constructor ----------------------------------------
                        | sym:name     - "Circle"
                        | name         - "Circle"
                        | parms        - double 
                        | decl         - "f(double)."
                        | code         - "{ }"
                        | sym:symtab   - 0x40194538
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "area"
                        | name         - "area"
                        | decl         - "f(void)."
                        | parms        - void 
                        | storage      - "virtual"
                        | type         - "double"
                        | sym:symtab   - 0x40194538
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "perimeter"
                        | name         - "perimeter"
                        | decl         - "f(void)."
                        | parms        - void 
                        | storage      - "virtual"
                        | type         - "double"
                        | sym:symtab   - 0x40194538
                        | 
                  +++ class ----------------------------------------
                  | sym:name     - "Square"
                  | name         - "Square"
                  | kind         - "class"
                  | bases        - 0x40194760
                  | symtab       - 0x40194788
                  | sym:symtab   - 0x40191078

                        +++ access ----------------------------------------
                        | kind         - "private"
                        | 
                        +++ cdecl ----------------------------------------
                        | name         - "width"
                        | decl         - ""
                        | type         - "double"
                        | 
                        +++ access ----------------------------------------
                        | kind         - "public"
                        | 
                        +++ constructor ----------------------------------------
                        | sym:name     - "Square"
                        | name         - "Square"
                        | parms        - double 
                        | decl         - "f(double)."
                        | code         - "{ }"
                        | sym:symtab   - 0x40194788
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "area"
                        | name         - "area"
                        | decl         - "f(void)."
                        | parms        - void 
                        | storage      - "virtual"
                        | type         - "double"
                        | sym:symtab   - 0x40194788
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "perimeter"
                        | name         - "perimeter"
                        | decl         - "f(void)."
                        | parms        - void 
                        | storage      - "virtual"
                        | type         - "double"
                        | sym:symtab   - 0x40194788
</pre>
</blockquote>

<h4>Attribute namespaces</h4>

When attributes are added to parse tree nodes, their names may be
prepended with a namespace qualifier.  For example, the attributes
<tt>sym:name</tt> and <tt>sym:symtab</tt> are attributes related to
symbol table management and are prefixed with <tt>sym:</tt>.  As a
general rule, only very general attributes such as types, names, and so
forth appear without a prefix.

<p>
Target language modules may add additional attributes to nodes to assist the generation
of wrapper code.  The convention for doing this is to place these attributes in a namespace
that matches the name of the target language.  For example, <tt>python:foo</tt> or
<tt>perl:foo</tt>.

<h4>Symbol Tables</h4>

During parsing, all symbols are managed in the space of the target
language.  The <tt>sym:name</tt> attribute of each node contains the symbol name
selected by the parser.  Normally, <tt>sym:name</tt> and <tt>name</tt>
are the same.  However, the <tt>%rename</tt> directive can be used to
change the value of <tt>sym:name</tt>.  You can see the effect of
<tt>%rename</tt> by trying it on a simple interface and dumping the
parse tree.  For example:

<blockquote>
<pre>
%rename(foo_i) foo(int);
%rename(foo_d) foo(double);

void foo(int);
void foo(double);
void foo(Bar *b);
</pre>
</blockquote>

Now, running SWIG:

<blockquote>
<pre>
$ swig -dump_tree example.i
...
            +++ cdecl ----------------------------------------
            | sym:name     - "foo_i"
            | name         - "foo"
            | decl         - "f(int)."
            | parms        - int 
            | type         - "void"
            | sym:symtab   - 0x40165078
            | 
            +++ cdecl ----------------------------------------
            | sym:name     - "foo_d"
            | name         - "foo"
            | decl         - "f(double)."
            | parms        - double 
            | type         - "void"
            | sym:symtab   - 0x40165078
            | 
            +++ cdecl ----------------------------------------
            | sym:name     - "foo"
            | name         - "foo"
            | decl         - "f(p.Bar)."
            | parms        - Bar *
            | type         - "void"
            | sym:symtab   - 0x40165078
</pre>
</blockquote>

All symbol-related conflicts and complaints about overloading are based on <tt>sym:name</tt> values.
For instance, the following example uses <tt>%rename</tt> in reverse to generate a name clash.

<blockquote>
<pre>
%rename(foo) foo_i(int);
%rename(foo) foo_d(double;

void foo_i(int);
void foo_d(double);
void foo(Bar *b);
</pre>
</blockquote>

When you run SWIG on this you now get:

<blockquote>
<pre>
$ ./swig example.i
example.i:6. Overloaded declaration ignored.  foo_d(double )
example.i:5. Previous declaration is foo_i(int )
example.i:7. Overloaded declaration ignored.  foo(Bar *)
example.i:5. Previous declaration is foo_i(int )
</pre>
</blockquote>

<h4>The %feature directive</h4>

A number of SWIG directives such as <tt>%exception</tt> are implemented using the
lower-level <tt>%feature</tt> directive.  For example:

<blockquote>
<pre>
%feature("except") getitem(int) {
  try {
     $action
  } catch (badindex) {
     ...
  }
}

...
class Foo {
public:
    Object *getitem(int index) throws(badindex);
    ...
};
</pre>
</blockquote>

The behavior of <tt>%feature</tt> is very easy to describe--it simply
attaches a new attribute to any parse tree node that matches the
given prototype.   When a feature is added, it shows up in the <tt>feature:</tt> namespace.
You can see this when running with the <tt>-dump_tree</tt> option.   For example:

<blockquote>
<pre>
 +++ cdecl ----------------------------------------
 | sym:name     - "getitem"
 | name         - "getitem"
 | decl         - "f(int).p."
 | parms        - int 
 | type         - "Object"
 | feature:except - "{\n    try {\n       $action\n    } catc..."
 | sym:symtab   - 0x40168ac8
 | 
</pre>
</blockquote>

Feature names are completely arbitrary and a target language module can be
programmed to respond to any name that it wishes.  The data stored in a feature attribute
is usually just a raw unparsed string.   For example, the exception code above is simply
stored without any modifications.

<h4>Code Generation</h4>

Language modules work by defining handler functions that know how to respond to
different types of parse-tree nodes.  These handlers simply look at the
attributes of each node in order to produce low-level code. 

<p>
In reality, the generation of code is somewhat more subtle than simply
invoking handler functions.  This is because parse-tree nodes might be
transformed. For example, suppose you are wrapping a class like this:

<blockquote>
<pre>
class Foo {
public:
    virtual int *bar(int x);
};
</pre>
</blockquote>

When the parser constructs a node for the member <tt>bar</tt>, it creates a raw "cdecl" node with the following
attributes:

<blockquote>
<pre>
nodeType    : cdecl
name        : bar
type        : int
decl        : f(int).p
parms       : int x
storage     : virtual
sym:name    : bar
</pre>
</blockquote>

To produce wrapper code, this "cdecl" node undergoes a number of transformations.  First, the
node is recognized as a function declaration.   This adjusts some of the type information--specifically,
the declarator is joined with the base datatype to produce this:

<blockquote>
<pre>
nodeType    : cdecl
name        : bar
type        : p.int        &lt;-- Notice change in return type
decl        : f(int).p
parms       : int x
storage     : virtual
sym:name    : bar
</pre>
</blockquote>

Next, the context of the node indicates that the node is really a
member function.  This produces a transformation to a low-level
accessor function like this:

<blockquote>
<pre>
nodeType    : cdecl
name        : bar
type        : int.p
decl        : f(int).p
parms       : Foo *self, int x            &lt;-- Added parameter
storage     : virtual
wrap:action : result = (arg1)->bar(arg2)  &lt;-- Action code added
sym:name    : Foo_bar                     &lt;-- Symbol name changed
</pre>
</blockquote>

In this transformation, notice how an additional parameter was added
to the parameter list and how the symbol name of the node has suddenly
changed into an accessor using the naming scheme described in the
"SWIG Basics" chapter.  A small fragment of "action" code has also
been generated--notice how the <tt>wrap:action</tt> attribute defines
the access to the underlying method.  The data in this transformed
node is then used to generate a wrapper.

<p>
Language modules work by registering handler functions for dealing with
various types of nodes at different stages of transformation.   This is done by 
inheriting from a special <tt>Language</tt> class and defining a collection
of virtual methods.   For example, the Python module defines a class as
follows:

<blockquote>
<pre>
class PYTHON : public Language {
protected:
public :
  virtual void main(int, char *argv[]);
  virtual int  top(Node *); 
  virtual int  functionWrapper(Node *);
  virtual int  constantWrapper(Node *);
  virtual int  variableWrapper(Node *);
  virtual int  nativeWrapper(Node *);
  virtual int  membervariableHandler(Node *);
  virtual int  memberconstantHandler(Node *);
  virtual int  memberfunctionHandler(Node *);
  virtual int  constructorHandler(Node *);
  virtual int  destructorHandler(Node *);
  virtual int  classHandler(Node *);
  virtual int  classforwardDeclaration(Node *);
  virtual int  insertDirective(Node *);
  virtual void import_start(char *);
  virtual void import_end();
};
</pre>
</blockquote>

The role of these functions are described shortly.

<h4>SWIG and XML</h4>

Much of SWIG's current parser design was originally motivated by
interest in using XML to represent SWIG parse trees.  Although XML is
not currently used in any direct manner, the parse tree structure, use
of node tags, attributes, and attribute namespaces are all influenced
by aspects of XML parsing.  Therefore, in trying to understand SWIG's
internal data structures, it may be useful keep XML in the back of
your mind as a model.

<h4>Summary so far</h4>

SWIG is a multi-pass compiler that works by building a complete parse tree of
input files.   These parse trees are structured as a hierarchy of nodes
with arbitrary attributes.   Language modules are created by writing
special handlers for different types of parse tree nodes.

<p>
The rest of this chapter describes some of the internal data structures and 
various code generation tasks in more detail.


<hr>

<address>SWIG 1.3 - Last Modified : January 22, 2002</address>
</body>
</html>

