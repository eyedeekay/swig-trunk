<html>
<head>
<title>Extending SWIG</title>
</head>

<body bgcolor="#ffffff">
<h1>Extending SWIG</h1>

<b>Caution: This chapter is being rewritten! (11/25/01)</b>

<h2>Introduction</h2>
This chapter describes SWIG's internal organization and the process by which
new target languages can be developed.    First, a brief word of warning---SWIG
has been undergoing a massive redevelopment effort that has focused extensively
on its internal organization.   The information in this chapter is mostly up to
date, but changes are ongoing.   Expect to find a few inconsistencies.

<h2>Prerequisites</h2>

In order to extend SWIG, it is useful to have the following background:

<p>
<ul>
<li>An understanding of the C API for the target language.
<li>A good grasp of the C++ type system.
<li>An understanding of typemaps and some of SWIG's advanced features.
<li>Some familiarity with writing C++ (language modules are currently written in C++).
</ul>

Since SWIG is essentially a specialized C++ compiler, it may be useful
to have some prior experience with compiler design (perhaps even a
compilers course) to better understand certain parts of the system.  A
number of books will also be useful.  For example, "The C Programming
Language" by Kernighan and Ritchie (a.k.a, "K&R") and the "C++
Annotated Reference Manual" by Stroustrup (a.k.a, the "ARM") will be of great use.

<h2>The Big Picture</h2>

SWIG is a special purpose compiler that parses C++ declarations to
generate wrapper code.  To make this conversion possible, SWIG makes
three fundamental extensions to the C++ language:

<ul>
<li><b>Typemaps</b>. Typemaps are used to define the
conversion/marshalling behavior of specific C++ datatypes.  All type conversion in SWIG is
based on typemaps.  Furthermore, the association of typemaps to datatypes utilizes an advanced pattern matching
mechanism that is fully integrated with the C++ type system.

<p>
<li><b>Declaration Annotation</b>. To customize wrapper code
generation, most declarations can be annotated with special features.
For example, you can make a variable read-only, you can ignore a
declaration, you can rename a member function, you can add exception
handling, and so forth.  Virtually all of these features are are built on top of a low-level
declaration annotator that can attach arbitrary attributes to any declaration.

<p>
<li><b>Class extension</b>. SWIG allows classes and structures to be extended with new
methods and attributes (the <tt>%extend</tt> directive).   This has the effect of altering 
the API in the target language and can be used to generate OO interfaces to C libraries.
</ul>

It is important to emphasize that virtually all SWIG features reduce to one of these three
fundamental concepts.  The type system and pattern matching rules also play a critical
role in making the system work.  For example, both typemaps and declaration annotation are
based on pattern matching and interact heavily with the underlying type system.

<h2>Execution Model</h2>

When you run SWIG on an interface, processing is handled in stages by a series of system components:

<ul>
<li>An integrated C preprocessor reads a collection of configuration
files and the specified interface file into memory.  The preprocessor
performs the usual functions including macro expansion and file
inclusion.   However, the preprocessor also performs some transformations of the
interface.  For instance, <tt>#define</tt> statements are sometimes transformed into
<tt>%constant</tt> declarations.  In addition, information related to file/line number
tracking is inserted.

<p>
<li>A C/C++ parser reads the preprocessed input and generates a full
parse tree of all of the SWIG directives and C declarations found.
The parser is responsible for many aspects of the system including
renaming, declaration annotation, and template expansion.  However, the parser
does not produce any output nor does it interact with the target
language module as it runs.  SWIG is not a one-pass compiler.

<p>
<li>A type normalization pass is made. This adjusts all of the C++ typenames to properly
handle namespaces, typedefs, nested classes, and other issues related to type scoping.

<p>
<li>A semantic pass is made on the parse tree to collect information related to
properties of the C++ interface.   For example, this pass would determine whether or not a class allows
a default constructor.

<p>
<li>A code generation pass is made using a specific target language module.  This phase
is responsible for generating the actual wrapper code.  All of SWIG's user-defined modules are
invoked during this stage of compilation.
</ul>

The next few sections briefly describe some of these stages.

<h3>Preprocessing</h3>

The preprocessor plays a critical role in the SWIG implementation.  This is because a lot
of SWIG's processing and internal configuration is managed not by code written in C, but
by configuration files in the SWIG library.  In fact, when you
run SWIG, parsing starts with a small interface file like this (note: this explains
the cryptic error messages that new users sometimes get when SWIG is misconfigured or installed
incorrectly):

<blockquote>
<pre>
%include "swig.swg"             // Global SWIG configuration
%include "<em>langconfig.swg</em>"       // Language specific configuration
%include "yourinterface.i"      // Your interface file
</pre>
</blockquote>

The <tt>swig.swg</tt> file contains global configuration information.  In addition, this file
defines many of SWIG's standard directives as macros.  For instance, part of
of <tt>swig.swg</tt> looks like this:

<blockquote>
<pre>
...
/* Code insertion directives such as %wrapper %{ ... %} */

#define %init        %insert("init")
#define %wrapper     %insert("wrapper")
#define %header      %insert("header")
#define %runtime     %insert("runtime")

/* Access control directives */

#define %immutable   %feature("immutable","1")
#define %mutable     %feature("immutable")

/* Directives for callback functions */

#define %callback(x) %feature("callback") `x`;
#define %nocallback  %feature("callback");

/* %ignore directive */

#define %ignore         %rename($ignore)
#define %ignorewarn(x)  %rename("$ignore:" x)
...
</pre>
</blockquote>

The fact that most of the standard SWIG directives are macros is
intended to simplify the implementation of the parser.  For instance,
rather than having to support dozens of special grammar rules, it is
easier to have a few basic primitives such as <tt>%feature</tt> or
<tt>%insert</tt>.

<p>
The <em><tt>langconfig.swg</tt></em> file is supplied by the target
language. This file contains language-specific configuration
information.  More often than not, this file provides run-time wrapper
support code (e.g., the type-checker) as well as a collection of
typemaps that define the default wrapping behavior.  Note: the name of this
file depends on the target language and is usually something like <tt>python.swg</tt>
or <tt>perl5.swg</tt>.

<p>
As a debugging aide, the text that SWIG feeds to its C++ parser can be obtained by running
<tt>swig -E interface.i</tt>.   This output probably isn't too useful in general, but it
will show how macros have been expanded as well as everything else that goes into
the low-level construction of the wrapper code. 

<h3>Parsing</h3>

The current C++ parser handles a subset of C++.  Most incompatibilities with C are due to
subtle aspects of how SWIG parses declarations.  Specifically, SWIG expects all C/C++ declarations
to follow this general form:

<blockquote>
<pre>
<em>storage</em> <em>type</em> <em>declarator</em> <em>initializer</em>;
</pre>
</blockquote>

<tt><em>storage</em></tt> is a keyword such as <tt>extern</tt>,
<tt>static</tt>, <tt>typedef</tt>, or <tt>virtual</tt>.  <tt><em>type</em></tt> is a primitive
datatype such as <tt>int</tt> or <tt>void</tt>.   <tt><em>type</em></tt> may be optionally
qualified with a qualifier such as <tt>const</tt> or <tt>volatile</tt>. <tt><em>declarator</em></tt>
is a name with additional type-construction modifiers attached to it (pointers, arrays, references,
functions, etc.).  Examples of declarators include <tt>*x</tt>, <tt>**x</tt>, <tt>x[20]</tt>, and 
<tt>(*x)(int,double)</tt>.   The <tt><em>initializer</em></tt> may be a value assigned using <tt>=</tt> or 
body of code enclosed in braces <tt>{ ... }</tt>.

<p>
This declaration format covers most common C++ declarations. However, the C++ standard
is somewhat more flexible in the placement of the pieces.  For example, it is technically legal, although
unusual to write something like <tt>int typedef const a</tt> in your program.   SWIG simply
doesn't bother to deal with this (although it could probably be modified if there is sufficient demand).

<P>
The other significant difference between C++ and SWIG is in the
treatment of typenames.  In C++, if you have a declaration like this,

<blockquote>
<pre>
int blah(Foo *x, Bar *y);
</pre>
</blockquote>

it won't parse correctly unless <tt>Foo</tt> and <tt>Bar</tt> have
been previously defined as types either using a <tt>class</tt>
definition or a <tt>typedef</tt>.  The reasons for this are subtle,
but this treatment of typenames is normally integrated at the level of the C
tokenizer---when a typename appears, a different token is returned to the parser
instead of an identifier.  

<p>
SWIG does not operate in this manner--any legal identifier can be used
as a type name.  The reason for this is primarily motivated by the use
of SWIG with partially defined data.  Specifically, 
SWIG is supposed to be easy to use on interfaces with missing type information.  On a
more practical level however, the introduction of typenames would
greatly complicate other parts of SWIG such as the parsing of SWIG
directives (many of which also rely upon identifier names).

<p>
Because of the different treatment of typenames, the most serious
limitation of the SWIG parser is that it can't process type declarations in
which an extra (and unnecessary) grouping operator is used.  For example:

<blockquote>
<pre>
int (x);         /* A variable x */
int (y)(int);    /* A function y */
</pre>
</blockquote>

The placing of extra parentheses in type declarations like this is
already recognized by the C++ community as a potential source of
strange programming errors. For example, Scott Meyers "Effective STL"
discusses this problem in a section on avoiding C++'s "most vexing
parse."
<p>

The parser is also unable to handle declarations with no return type or bare argument names.
For example, in an old C program, you might see things like this:

<blockquote>
<pre>
foo(a,b) {
...
}
</pre>
</blockquote>
In this case, the return type as well as the types of the arguments
are taken by the C compiler to be an <tt>int</tt>.  However, SWIG
interprets the above code as an abstract declarator for a function
returning a <tt>foo</tt> and taking types <tt>a</tt> and <tt>b</tt> as
arguments).

<h3>Parse Trees</h3>

The SWIG parser produces a complete parse tree of the input file before any wrapper code
is actually generated.  Each item in the tree is known as a "Node".   Each node is identified
by a symbolic tag.   Furthermore, a node may have an arbitrary number of children.
The parse tree structure and tag names of an interface can be displayed using <tt>swig -dump_tags</tt>.
For example:

<blockquote>
<pre>
$ <b>swig -c++ -python -dump_tags example.i</b>
 . top (example.i:1)
 . top . include (example.i:1)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/swig.swg:71)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/swig.swg:71)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/swig.swg:83)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/swig.swg:83)
 . top . include (example.i:4)
 . top . include . insert (/r0/beazley/Projects/lib/swig1.3/python/python.swg:7)
 . top . include . insert (/r0/beazley/Projects/lib/swig1.3/python/python.swg:8)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:19)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:19)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:19)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:20)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:20)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:20)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:21)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:21)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:21)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:22)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:22)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:22)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:23)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:23)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:24)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:24)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:25)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:25)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:26)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:26)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:29)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:29)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:32)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:32)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:42)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:42)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:42)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:42)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:45)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:45)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:46)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:46)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:49)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:49)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:59)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:61)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:61)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:61)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:62)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:62)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:63)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:63)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:66)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:66)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:66)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:66)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:69)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:69)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:72)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:72)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:75)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:75)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:75)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:84)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:84)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:105)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:114)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:114)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:114)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:124)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:124)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:137)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:137)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:154)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:154)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:164)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:164)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:173)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:173)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:173)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:182)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:182)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:191)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:191)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:200)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:200)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:205)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:208)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:208)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:208)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:211)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:211)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:211)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:214)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:214)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:214)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:214)
 . top . include . typemap (/r0/beazley/Projects/lib/swig1.3/python/python.swg:217)
 . top . include . typemap . typemapitem (/r0/beazley/Projects/lib/swig1.3/python/python.swg:217)
 . top . include (example.i:6)
 . top . include . module (example.i:2)
 . top . include . insert (example.i:6)
 . top . include . include (example.i:9)
 . top . include . include . class (example.h:3)
 . top . include . include . class . access (example.h:4)
 . top . include . include . class . constructor (example.h:7)
 . top . include . include . class . destructor (example.h:10)
 . top . include . include . class . cdecl (example.h:11)
 . top . include . include . class . cdecl (example.h:11)
 . top . include . include . class . cdecl (example.h:12)
 . top . include . include . class . cdecl (example.h:13)
 . top . include . include . class . cdecl (example.h:14)
 . top . include . include . class . cdecl (example.h:15)
 . top . include . include . class (example.h:18)
 . top . include . include . class . access (example.h:19)
 . top . include . include . class . cdecl (example.h:20)
 . top . include . include . class . access (example.h:21)
 . top . include . include . class . constructor (example.h:22)
 . top . include . include . class . cdecl (example.h:23)
 . top . include . include . class . cdecl (example.h:24)
 . top . include . include . class (example.h:27)
 . top . include . include . class . access (example.h:28)
 . top . include . include . class . cdecl (example.h:29)
 . top . include . include . class . access (example.h:30)
 . top . include . include . class . constructor (example.h:31)
 . top . include . include . class . cdecl (example.h:32)
 . top . include . include . class . cdecl (example.h:33)
</pre>
</blockquote>

Even for the most simple interface, the parse tree structure is larger than you might expect.  For example, in the
above output, a substantial number of nodes are actually generated by the <tt>python.swg</tt> configuration file
which defines typemaps and other directives.   The contents of the user-supplied input file don't appear until the end
of the output.

<p>
The contents of each parse tree node consist of a collection of attribute/value
pairs.  Internally, the nodes are simply represented by hash tables.  A display of
the parse-tree structure can be obtained using <tt>swig -dump_tree</tt>. For example:

<blockquote>
<pre>
$ swig -c++ -python -dump_tree example.i
...
      +++ include ----------------------------------------
      | name         - "example.i"

            +++ module ----------------------------------------
            | name         - "example"
            | 
            +++ insert ----------------------------------------
            | code         - "\n#include \"example.h\"\n"
            | 
            +++ include ----------------------------------------
            | name         - "example.h"

                  +++ class ----------------------------------------
                  | abstract     - "1"
                  | sym:name     - "Shape"
                  | name         - "Shape"
                  | kind         - "class"
                  | symtab       - 0x40194140
                  | sym:symtab   - 0x40191078

                        +++ access ----------------------------------------
                        | kind         - "public"
                        | 
                        +++ constructor ----------------------------------------
                        | sym:name     - "Shape"
                        | name         - "Shape"
                        | decl         - "f()."
                        | code         - "{\n    nshapes++;\n  }"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ destructor ----------------------------------------
                        | sym:name     - "~Shape"
                        | name         - "~Shape"
                        | storage      - "virtual"
                        | code         - "{\n    nshapes--;\n  }"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "x"
                        | name         - "x"
                        | decl         - ""
                        | type         - "double"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "y"
                        | name         - "y"
                        | decl         - ""
                        | type         - "double"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "move"
                        | name         - "move"
                        | decl         - "f(double,double)."
                        | parms        - double ,double 
                        | type         - "void"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "area"
                        | name         - "area"
                        | decl         - "f(void)."
                        | parms        - void 
                        | storage      - "virtual"
                        | value        - "0"
                        | type         - "double"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "perimeter"
                        | name         - "perimeter"
                        | decl         - "f(void)."
                        | parms        - void 
                        | storage      - "virtual"
                        | value        - "0"
                        | type         - "double"
                        | sym:symtab   - 0x40194140
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "nshapes"
                        | name         - "nshapes"
                        | decl         - ""
                        | storage      - "static"
                        | type         - "int"
                        | sym:symtab   - 0x40194140
                        | 
                  +++ class ----------------------------------------
                  | sym:name     - "Circle"
                  | name         - "Circle"
                  | kind         - "class"
                  | bases        - 0x40194510
                  | symtab       - 0x40194538
                  | sym:symtab   - 0x40191078

                        +++ access ----------------------------------------
                        | kind         - "private"
                        | 
                        +++ cdecl ----------------------------------------
                        | name         - "radius"
                        | decl         - ""
                        | type         - "double"
                        | 
                        +++ access ----------------------------------------
                        | kind         - "public"
                        | 
                        +++ constructor ----------------------------------------
                        | sym:name     - "Circle"
                        | name         - "Circle"
                        | parms        - double 
                        | decl         - "f(double)."
                        | code         - "{ }"
                        | sym:symtab   - 0x40194538
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "area"
                        | name         - "area"
                        | decl         - "f(void)."
                        | parms        - void 
                        | storage      - "virtual"
                        | type         - "double"
                        | sym:symtab   - 0x40194538
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "perimeter"
                        | name         - "perimeter"
                        | decl         - "f(void)."
                        | parms        - void 
                        | storage      - "virtual"
                        | type         - "double"
                        | sym:symtab   - 0x40194538
                        | 
                  +++ class ----------------------------------------
                  | sym:name     - "Square"
                  | name         - "Square"
                  | kind         - "class"
                  | bases        - 0x40194760
                  | symtab       - 0x40194788
                  | sym:symtab   - 0x40191078

                        +++ access ----------------------------------------
                        | kind         - "private"
                        | 
                        +++ cdecl ----------------------------------------
                        | name         - "width"
                        | decl         - ""
                        | type         - "double"
                        | 
                        +++ access ----------------------------------------
                        | kind         - "public"
                        | 
                        +++ constructor ----------------------------------------
                        | sym:name     - "Square"
                        | name         - "Square"
                        | parms        - double 
                        | decl         - "f(double)."
                        | code         - "{ }"
                        | sym:symtab   - 0x40194788
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "area"
                        | name         - "area"
                        | decl         - "f(void)."
                        | parms        - void 
                        | storage      - "virtual"
                        | type         - "double"
                        | sym:symtab   - 0x40194788
                        | 
                        +++ cdecl ----------------------------------------
                        | sym:name     - "perimeter"
                        | name         - "perimeter"
                        | decl         - "f(void)."
                        | parms        - void 
                        | storage      - "virtual"
                        | type         - "double"
                        | sym:symtab   - 0x40194788
</pre>
</blockquote>

<h3>Attribute namespaces</h3>

When attributes are added to parse tree nodes, their names may be
prepended with a namespace qualifier.  For example, the attributes
<tt>sym:name</tt> and <tt>sym:symtab</tt> are attributes related to
symbol table management and are prefixed with <tt>sym:</tt>.  As a
general rule, only very general attributes such as types, names, and so
forth appear without a prefix.

<p>
Target language modules may add additional attributes to nodes to assist the generation
of wrapper code.  The convention for doing this is to place these attributes in a namespace
that matches the name of the target language.  For example, <tt>python:foo</tt> or
<tt>perl:foo</tt>.

<h3>Symbol Tables</h3>

During parsing, all symbols are managed in the space of the target
language.  The <tt>sym:name</tt> attribute of each node contains the symbol name
selected by the parser.  Normally, <tt>sym:name</tt> and <tt>name</tt>
are the same.  However, the <tt>%rename</tt> directive can be used to
change the value of <tt>sym:name</tt>.  You can see the effect of
<tt>%rename</tt> by trying it on a simple interface and dumping the
parse tree.  For example:

<blockquote>
<pre>
%rename(foo_i) foo(int);
%rename(foo_d) foo(double);

void foo(int);
void foo(double);
void foo(Bar *b);
</pre>
</blockquote>

Now, running SWIG:

<blockquote>
<pre>
$ swig -dump_tree example.i
...
            +++ cdecl ----------------------------------------
            | sym:name     - "foo_i"
            | name         - "foo"
            | decl         - "f(int)."
            | parms        - int 
            | type         - "void"
            | sym:symtab   - 0x40165078
            | 
            +++ cdecl ----------------------------------------
            | sym:name     - "foo_d"
            | name         - "foo"
            | decl         - "f(double)."
            | parms        - double 
            | type         - "void"
            | sym:symtab   - 0x40165078
            | 
            +++ cdecl ----------------------------------------
            | sym:name     - "foo"
            | name         - "foo"
            | decl         - "f(p.Bar)."
            | parms        - Bar *
            | type         - "void"
            | sym:symtab   - 0x40165078
</pre>
</blockquote>

All symbol-related conflicts and complaints about overloading are based on <tt>sym:name</tt> values.
For instance, the following example uses <tt>%rename</tt> in reverse to generate a name clash.

<blockquote>
<pre>
%rename(foo) foo_i(int);
%rename(foo) foo_d(double;

void foo_i(int);
void foo_d(double);
void foo(Bar *b);
</pre>
</blockquote>

When you run SWIG on this you now get:

<blockquote>
<pre>
$ ./swig example.i
example.i:6. Overloaded declaration ignored.  foo_d(double )
example.i:5. Previous declaration is foo_i(int )
example.i:7. Overloaded declaration ignored.  foo(Bar *)
example.i:5. Previous declaration is foo_i(int )
</pre>
</blockquote>

<h3>The %feature directive</h3>

A number of SWIG directives such as <tt>%exception</tt> are implemented using the
low-level <tt>%feature</tt> directive.  For example:

<blockquote>
<pre>
%feature("except") getitem(int) {
  try {
     $action
  } catch (badindex) {
     ...
  }
}

...
class Foo {
public:
    Object *getitem(int index) throws(badindex);
    ...
};
</pre>
</blockquote>

The behavior of <tt>%feature</tt> is very easy to describe--it simply
attaches a new attribute to any parse tree node that matches the
given prototype.   When a feature is added, it shows up in the <tt>feature:</tt> namespace.
You can see this when running with the <tt>-dump_tree</tt> option.   For example:

<blockquote>
<pre>
 +++ cdecl ----------------------------------------
 | sym:name     - "getitem"
 | name         - "getitem"
 | decl         - "f(int).p."
 | parms        - int 
 | type         - "Object"
 | feature:except - "{\n    try {\n       $action\n    } catc..."
 | sym:symtab   - 0x40168ac8
 | 
</pre>
</blockquote>

Feature names are completely arbitrary and a target language module can be
programmed to respond to any name that it wishes.  The data stored in a feature attribute
is usually just a raw unparsed string.   For example, the exception code above is simply
stored without any modifications.

<h3>Code Generation</h3>

Language modules work by defining handler functions that know how to respond to
different types of parse-tree nodes.  These handlers simply look at the
attributes of each node in order to produce low-level code. 

<p>
In reality, the generation of code is somewhat more subtle than simply
invoking handler functions.  This is because parse-tree nodes might be
transformed. For example, suppose you are wrapping a class like this:

<blockquote>
<pre>
class Foo {
public:
    virtual int *bar(int x);
};
</pre>
</blockquote>

When the parser constructs a node for the member <tt>bar</tt>, it creates a raw "cdecl" node with the following
attributes:

<blockquote>
<pre>
nodeType    : cdecl
name        : bar
type        : int
decl        : f(int).p
parms       : int x
storage     : virtual
sym:name    : bar
</pre>
</blockquote>

To produce wrapper code, this "cdecl" node undergoes a number of transformations.  First, the
node is recognized as a function declaration.   This adjusts some of the type information--specifically,
the declarator is joined with the base datatype to produce this:

<blockquote>
<pre>
nodeType    : cdecl
name        : bar
type        : p.int        &lt;-- Notice change in return type
decl        : f(int).p
parms       : int x
storage     : virtual
sym:name    : bar
</pre>
</blockquote>

Next, the context of the node indicates that the node is really a
member function.  This produces a transformation to a low-level
accessor function like this:

<blockquote>
<pre>
nodeType    : cdecl
name        : bar
type        : int.p
decl        : f(int).p
parms       : Foo *self, int x            &lt;-- Added parameter
storage     : virtual
wrap:action : result = (arg1)->bar(arg2)  &lt;-- Action code added
sym:name    : Foo_bar                     &lt;-- Symbol name changed
</pre>
</blockquote>

In this transformation, notice how an additional parameter was added
to the parameter list and how the symbol name of the node has suddenly
changed into an accessor using the naming scheme described in the
"SWIG Basics" chapter.  A small fragment of "action" code has also
been generated--notice how the <tt>wrap:action</tt> attribute defines
the access to the underlying method.  The data in this transformed
node is then used to generate a wrapper.

<p>
Language modules work by registering handler functions for dealing with
various types of nodes at different stages of transformation.   This is done by 
inheriting from a special <tt>Language</tt> class and defining a collection
of virtual methods.   For example, the Python module defines a class as
follows:

<blockquote>
<pre>
class PYTHON : public Language {
protected:
public :
  virtual void main(int, char *argv[]);
  virtual int  top(Node *); 
  virtual int  functionWrapper(Node *);
  virtual int  constantWrapper(Node *);
  virtual int  variableWrapper(Node *);
  virtual int  nativeWrapper(Node *);
  virtual int  membervariableHandler(Node *);
  virtual int  memberconstantHandler(Node *);
  virtual int  memberfunctionHandler(Node *);
  virtual int  constructorHandler(Node *);
  virtual int  destructorHandler(Node *);
  virtual int  classHandler(Node *);
  virtual int  classforwardDeclaration(Node *);
  virtual int  insertDirective(Node *);
  virtual int  importDirective(Node *);
};
</pre>
</blockquote>

The role of these functions is described shortly.

<h3>SWIG and XML</h3>

Much of SWIG's current parser design was originally motivated by
interest in using XML to represent SWIG parse trees.  Although XML is
not currently used in any direct manner, the parse tree structure, use
of node tags, attributes, and attribute namespaces are all influenced
by aspects of XML parsing.  Therefore, in trying to understand SWIG's
internal data structures, it may be useful keep XML in the back of
your mind as a model.

<p>
<B>**** Under Construction ****</b>



<h2>Primitive Data Structures</h2>

Most of SWIG is constructed using three basic data structures:
strings, hashes, and lists.  These data structures are dynamic like
similar structures found in many scripting languages.  For instance,
you can have containers (lists and hash tables) of mixed types and
certain operations are polymorphic.

<p>
When describing the low-level API, the following type name conventions are
used:

<ul>
<li><tt>String</tt>.  A string object.
<li><tt>Hash</tt>. A hash object.
<li><tt>List</tt>. A list object.
<li><tt>String_or_char</tt>. A string object or a <tt>char *</tt>.
<li><tt>Object_or_char</tt>. An object or a <tt>char *</tt>.
<li><tt>Object</tt>.  Any object (string, hash, list, etc.)
</ul>

In most cases, other typenames are simply aliases for one of these 
primitive types.   Specifically:

<blockquote>
<pre>
typedef String SwigType;
typedef Hash   Parm;
typedef Hash   ParmList;
typedef Hash   Node;
typedef Hash   Symtab;
typedef Hash   Typetab;
</pre>
</blockquote>

<h3>Strings</h3>

<p>
<b><tt>String *NewString(const String_or_char *val)</tt></b>
<blockquote>
Creates a new string with initial value <tt>val</tt>. <tt>val</tt> may
be a <tt>char *</tt> or another <tt>String</tt> object.   If you want
to create an empty string, use "" for val.
</blockquote>

<p>
<b><tt>String *NewStringf(const char *fmt, ...)</tt></b>
<blockquote>
Creates a new string whose initial value is set according to a C <tt>printf</tt> style
format string in <tt>fmt</tt>.   Additional arguments follow depending
on <tt>fmt</tt>.
</blockquote>

<p>
<b><tt>String *Copy(String *s)</tt></b>
<blockquote>
Make a copy of the string <tt>s</tt>.
</blockquote>

<p>
<b><tt>void Delete(String *s)</tt></b>
<blockquote>
Deletes <tt>s</tt>.
</blockquote>

<p>
<b><tt>int Len(String_or_char *s)</tt></b>
<blockquote>
Returns the length of the string.
</blockquote>

<p>
<b><tt>char *Char(String_or_char *s)</tt></b>
<blockquote>
Returns a pointer to the first character in the string.
</blockquote>

<p>
<b><tt>void Append(String *s, String_or_char *t)</tt></b>
<blockquote>
Appends <tt>t</tt> to the end of <tt>s</tt>.
</blockquote>

<p>
<b><tt>void Insert(String *s, int pos, String_or_char *t)</tt></b>
<blockquote>
Inserts <tt>t</tt> into <tt>s</tt> at position <tt>pos</tt>.  The contents
of <tt>s</tt> are shifted accordingly.    The special value <tt>DOH_END</tt>
can be used for <tt>pos</tt> to indicate insertion at the end of the string (appending).
</blockquote>

<p>
<b><tt>int Strcmp(const String_or_char *s, const String_or_char *t)</tt></b>
<blockquote>
Compare strings <tt>s</tt> and <tt>t</tt>.   Same as the C <tt>strcmp()</tt>
function.
</blockquote>

<p>
<b><tt>int Strncmp(const String_or_char *s, const String_or_char *t, int len)</tt></b>
<blockquote>
Compare the first <tt>len</tt> characters of strings <tt>s</tt> and <tt>t</tt>.   Same as the C <tt>strncmp()</tt>
function.
</blockquote>

<p>
<b><tt>char *Strstr(const String_or_char *s, const String_or_char *pat)</tt></b>
<blockquote>
Returns a pointer to the first occurrence of <tt>pat</tt> in <tt>s</tt>.
Same as the C <tt>strstr()</tt> function.
</blockquote>

<p>
<b><tt>char *Strchr(const String_or_char *s, char ch)</tt></b>
<blockquote>
Returns a pointer to the first occurrence of character <tt>ch</tt> in <tt>s</tt>.
Same as the C <tt>strchr()</tt> function.
</blockquote>

<p>
<b><tt>void Chop(String *s)</tt></b>
<blockquote>
Chops trailing whitespace off the end of <tt>s</tt>.
</blockquote>

<p>
<b><tt>int Replace(String *s, const String_or_char *pat, const String_or_char *rep, int flags)</tt></b>
<blockquote>
Replaces the pattern <tt>pat</tt> with <tt>rep</tt> in string <tt>s</tt>.  
<tt>flags</tt> is a combination of the following flags:
<blockquote>
<pre>
DOH_REPLACE_ANY       - Replace all occurrences
DOH_REPLACE_ID        - Valid C identifiers only
DOH_REPLACE_NOQUOTE   - Don't replace in quoted strings
DOH_REPLACE_FIRST     - Replace first occurrence only.
</pre>
</blockquote>

Returns the number of replacements made (if any).
</blockquote>


<h3>Hashes</h3>

<p>
<b><tt>Hash *NewHash()</tt></b>
<blockquote>
Creates a new empty hash table.
</blockquote>

<p>
<b><tt>Hash *Copy(Hash *h)</tt></b>
<blockquote>
Make a shallow copy of the hash <tt>h</tt>.
</blockquote>

<p>
<b><tt>void Delete(Hash *h)</tt></b>
<blockquote>
Deletes <tt>h</tt>.
</blockquote>

<p>
<b><tt>int Len(Hash *h)</tt></b>
<blockquote>
Returns the number of items in <tt>h</tt>.
</blockquote>

<p>
<b><tt>Object *Getattr(Hash *h, String_or_char *key)</tt></b>
<blockquote>
Gets an object from <tt>h</tt>.  <tt>key</tt> may be a string or
a simple <tt>char *</tt> string.   Returns NULL if not found.
</blockquote>

<p>
<b><tt>int *Setattr(Hash *h, String_or_char *key, Object_or_char *val)</tt></b>
<blockquote>
Stores <tt>val</tt> in <tt>h</tt>. <tt>key</tt> may be a string or
a simple <tt>char *</tt>. If <tt>val</tt> is not a standard
object (String, Hash, or List) it is assumed to be a <tt>char *</tt> in which
case it is used to construct a <tt>String</tt> that is stored in the hash.
If <tt>val</tt> is NULL, the object is deleted. Increases the reference count
of <tt>val</tt>.   Returns 1 if this operation replaced an existing hash entry,
0 otherwise.
</blockquote>

<p>
<b><tt>int *Delattr(Hash *h, String_or_char *key)</tt></b>
<blockquote>
Deletes the hash item referenced by <tt>key</tt>.  Decreases the
reference count on the corresponding object (if any).  Returns 1
if an object was removed, 0 otherwise.
</blockquote>

<p>
<b><tt>String *Firstkey(Hash *h)</tt></b>
<blockquote>
Returns the first hash table key or NULL if the hash is empty. Used
for iteration.
</blockquote>

<p>
<b><tt>String *Nextkey(Hash *h)</tt></b>
<blockquote>
Returns the next hash table key or NULL if the end of the hash has been
reached.  Used for iteration.
</blockquote>

<p>
<b><tt>List *Keys(Hash *h)</tt></b>
<blockquote>
Returns the list of hash table keys.
</blockquote>


<h3>Lists</h3>

<p>
<b><tt>List *NewList()</tt></b>
<blockquote>
Creates a new empty list.
</blockquote>

<p>
<b><tt>List *Copy(List *x)</tt></b>
<blockquote>
Make a shallow copy of the List <tt>x</tt>.
</blockquote>

<p>
<b><tt>void Delete(List *x)</tt></b>
<blockquote>
Deletes <tt>x</tt>.
</blockquote>

<p>
<b><tt>int Len(List *x)</tt></b>
<blockquote>
Returns the number of items in <tt>x</tt>.
</blockquote>

<p>
<b><tt>Object *Getitem(List *x, int n)</tt></b>
<blockquote>
Returns an object from <tt>x</tt> with index <tt>n</tt>.  If <tt>n</tt> is
beyond the end of the list, the last item is returned. If <tt>n</tt> is
negative, the first item is returned.
</blockquote>

<p>
<b><tt>int *Setitem(List *x, int n, Object_or_char *val)</tt></b>
<blockquote>
Stores <tt>val</tt> in <tt>x</tt>. 
If <tt>val</tt> is not a standard
object (String, Hash, or List) it is assumed to be a <tt>char *</tt> in which
case it is used to construct a <tt>String</tt> that is stored in the list.
<tt>n</tt> must be in range.  Otherwise, an assertion will be raised.
</blockquote>

<p>
<b><tt>int *Delitem(List *x, int n)</tt></b>
<blockquote>
Deletes item <tt>n</tt> from the list, shifting items down if necessary.  
To delete the last item in the list, use the special value <tt>DOH_END</tt>
for <tt>n</tt>.
</blockquote>

<p>
<b><tt>Object *Firstitem(List *x)</tt></b>
<blockquote>
Returns the first item in <tt>x</tt> or NULL if the list is empty.
</blockquote>

<p>
<b><tt>Object *Nextitem(List *x)</tt></b>
<blockquote>
Returns the next item in <tt>x</tt> or NULL if the end of the list has been
reached.  Used for iteration.
</blockquote>

<p>
<b><tt>void Append(List *x, Object_or_char *t)</tt></b>
<blockquote>
Appends <tt>t</tt> to the end of <tt>x</tt>.  If <tt>t</tt> is not
a standard object, it is assumed to be a <tt>char *</tt> and is
used to create a String object.
</blockquote>

<p>
<b><tt>void Insert(String *s, int pos, Object_or_char *t)</tt></b>
<blockquote>
Inserts <tt>t</tt> into <tt>s</tt> at position <tt>pos</tt>.  The contents
of <tt>s</tt> are shifted accordingly.    The special value <tt>DOH_END</tt>
can be used for <tt>pos</tt> to indicate insertion at the end of the list (appending).
If <tt>t</tt> is not a standard object, it is assumed to be a <tt>char *</tt>
and is used to create a String object.
</blockquote>

<h3>Common operations</h3>

The following operations are applicable to all datatypes.

<p>
<b><tt>Object *Copy(Object *x)</tt></b>
<blockquote>
Make a copy of the object <tt>x</tt>.
</blockquote>

<p>
<b><tt>void Delete(Object *x)</tt></b>
<blockquote>
Deletes <tt>x</tt>.
</blockquote>

<p>
<b><tt>void Setfile(Object *x, String_or_char *f)</tt></b>
<blockquote>
Sets the filename associated with <tt>x</tt>.  Used to track
objects and report errors.
</blockquote>

<p>
<b><tt>String *Getfile(Object *x)</tt></b>
<blockquote>
Gets the filename associated with <tt>x</tt>.
</blockquote>

<p>
<b><tt>void Setline(Object *x, int n)</tt></b>
<blockquote>
Sets the line number associated with <tt>x</tt>.  Used to track
objects and report errors.
</blockquote>

<p>
<b><tt>int Getline(Object *x)</tt></b>
<blockquote>
Gets the line number associated with <tt>x</tt>.
</blockquote>

<h3>I/O</h3>

Special I/O functions are used for all internal I/O.  These operations
work on C <tt>FILE *</tt> objects, special File objects, and String objects.

<p>
<b><tt>int Printf(String_or_FILE *f, const char *fmt, ...)</tt></b>
<blockquote>
Formatted I/O.   Same as the C <tt>fprintf()</tt> function except that output
can also be directed to a string object.  Note:  the <tt>%s</tt> format 
specifier works with both strings and <tt>char *</tt>.  All other format
operators have the same meaning.
</blockquote>

<p>
<b><tt>int Printv(String_or_FILE *f, String_or_char *arg1,..., NULL)</tt></b>
<blockquote>
Prints a variable number of strings arguments to the output.  The last
argument to this function must be NULL.   The other arguments can either
be <tt>char *</tt> or string objects.
</blockquote>

<p>
<b><tt>int Putc(int ch, String_or_FILE *f)</tt></b>
<blockquote>
Same as the C <tt>fputc()</tt> function.
</blockquote>

<p>
<b><tt>int Write(String_or_FILE *f, void *buf, int len)</tt></b>
<blockquote>
Same as the C <tt>write()</tt> function.
</blockquote>

<p>
<b><tt>int Read(String_or_FILE *f, void *buf, int maxlen)</tt></b>
<blockquote>
Same as the C <tt>read()</tt> function.
</blockquote>

<p>
<b><tt>int Getc(String_or_FILE *f)</tt></b>
<blockquote>
Same as the C <tt>fgetc()</tt> function.
</blockquote>

<p>
<b><tt>int Ungetc(int ch, String_or_FILE *f)</tt></b>
<blockquote>
Same as the C <tt>ungetc()</tt> function.
</blockquote>

<p>
<b><tt>int Seek(String_or_FILE *f, int offset, int whence)</tt></b>
<blockquote>
Same as the C <tt>seek()</tt> function.  <tt>offset</tt> is the number
of bytes.  <tt>whence</tt> is one of <tt>SEEK_SET</tt>,<tt>SEEK_CUR</tt>,
or <tt>SEEK_END</tt>..
</blockquote>

<p>
<b><tt>long Tell(String_or_FILE *f)</tt></b>
<blockquote>
Same as the C <tt>tell()</tt> function.
</blockquote>

<p>
<b><tt>File *NewFile(const char *filename, const char *mode)</tt></b>
<blockquote>
Create a File object using the <tt>fopen()</tt> library call.  This
file differs from <tt>FILE *</tt> in that it can be placed in the standard
SWIG containers (lists, hashes, etc.). 
</blockquote>

<p>
<b><tt>File *NewFileFromFile(FILE *f)</tt></b>
<blockquote>
Create a File object wrapper around an existing <tt>FILE</tt> object.
</blockquote>

<p>
<b><tt>int Close(String_or_FILE *f)</tt></b>
<blockquote>
Closes a file.  Has no effect on strings.
</blockquote>

The use of the above I/O functions and strings play a critical role in SWIG.   It is
common to see small code fragments of code generated kind of like this:

<blockquote>
<pre>
/* Print into a string */
String *s = NewString("");
Printf(s,"Hello\n");
for (i = 0; i < 10; i++) {
    Printf(s,"%d\n", i);
}
...
/* Print string into a file */
Printf(f, "%s\n", s);
</pre>
</blockquote>

Similarly, the preprocessor and parser all operate on string-files.

<h2>Type system</h2>

SWIG implements the complete C++ type system including typedef, inheritance,
pointers, references, and pointers to members.   A detailed discussion of
type theory is impossible here.   However, let's cover the highlights.

<h3>String encoding of types</h3>

<p>
All types in SWIG consist of a base datatype and a collection of type
operators that are applied to the base.   A base datatype is almost
always some kind of primitive type such as <tt>int</tt> or <tt>double</tt>.
The operators consist of things like pointers, references, arrays, and so forth.
Internally, types are represented as strings that are constructed in a very
precise manner.  Here are some examples:

<blockquote>
<pre>
C datatype                     SWIG encoding (strings)
-----------------------------  --------------------------
int                            "int"
int *                          "p.int"
const int *                    "p.q(const).int"
int (*x)(int,double)           "p.f(int,double).int"
int [20][30]                   "a(20).a(30).int"
int (F::*)(int)                "m(F).f(int).int"
vector&lt;int&gt; *                  "p.vector&lt;(int)&gt;"
</pre>
</blockquote>

Reading the SWIG encoding is often easier than figuring out the C code---just
read it from left to right.  For a type of "p.f(int,double).int" is
a "pointer to a function(int,double) that returns int".  

<p>
The following operator encodings are used in type strings:

<blockquote>
<pre>
Operator              Meaning
-------------------   -------------------------------
p.                    Pointer to
a(n).                 Array of dimension n
r.                    C++ reference
m(class).             Member pointer to class
f(args).              Function.
q(qlist).             Qualifiers
</pre>
</blockquote>

In addition, type names may be parameterized by templates.  This is
represented by enclosing the template parameters in <tt>&lt;(
... )&gt;</tt>.  Variable length arguments are represented by the
special base type of <tt>v(...)</tt>.

<p>
If you want to experiment with type encodings, the raw type strings can
be inserted into an interface file using backticks `` wherever a type
is expected.  For instance, here is
an extremely perverted example:

<blockquote>
<pre>
`p.a(10).p.f(int,p.f(int).int)` foo(int, int (*x)(int));
</pre>
</blockquote>

This corresponds to the immediately obvious C declaration:

<blockquote>
<pre>
(*(*foo(int,int (*)(int)))[10])(int,int (*)(int));
</pre>
</blockquote>

Aside from the potential use of this declaration on a C programming quiz,
it motivates the use of the special SWIG encoding of types.   The SWIG
encoding is much easier to work with because types can be easily examined,
modified, and constructed using simple string operations (comparison,
substrings, concatenation, etc.).   For example, in the parser, a declaration
like this

<blockquote>
<pre>
int *a[30];
</pre>
</blockquote>

is processed in a few pieces.  In this case, you have the base type
"<tt>int</tt>" and the declarator of type "<tt>a(30).p.</tt>".  To
make the final type, the two parts are just joined together using
string concatenation.

<h3>Type construction</h3>

The following functions are used to construct types.  You should use
these functions instead of trying to build the type strings yourself.

<p>
<b><tt>void SwigType_add_pointer(SwigType *ty)</tt></b>
<blockquote>
Adds a pointer to <tt>ty</tt>.
</blockquote>

<p>
<b><tt>void SwigType_del_pointer(SwigType *ty)</tt></b>
<blockquote>
Removes a single pointer from <tt>ty</tt>.
</blockquote>

<p>
<b><tt>void SwigType_add_reference(SwigType *ty)</tt></b>
<blockquote>
Adds a reference to <tt>ty</tt>.
</blockquote>

<p>
<b><tt>void SwigType_add_array(SwigType *ty, String_or_char *dim)</tt></b>
<blockquote>
Adds an array with dimension <tt>dim</tt> to <tt>ty</tt>.
</blockquote>

<p>
<b><tt>void SwigType_add_qualifier(SwigType *ty, String_or_char *q)</tt></b>
<blockquote>
Adds a type qualifier <tt>q</tt> to <tt>ty</tt>.  <tt>q</tt> is typically
<tt>"const"</tt> or <tt>"volatile"</tt>.
</blockquote>

<p>
<b><tt>void SwigType_add_memberpointer(SwigType *ty, String_or_char *cls)</tt></b>
<blockquote>
Adds a pointer to a member of class <tt>cls</tt> to <tt>ty</tt>.
</blockquote>

<p>
<b><tt>void SwigType_add_function(SwigType *ty, ParmList *p)</tt></b>
<blockquote>
Adds a function to <tt>ty</tt>.  <tt>p</tt> is a linked-list of parameter
nodes as generated by the parser. See the section on parameter lists
for details about the representation.
</blockquote>

<p>
<b><tt>SwigType *SwigType_pop(SwigType *ty)</tt></b>
<blockquote>
Removes the last type constructor from <tt>ty</tt> and returns it.
<tt>ty</tt> is modified.
</blockquote>

<p>
<b><tt>void SwigType_push(SwigType *ty, SwigType *op)</tt></b>
<blockquote>
Pushes the type operators in <tt>op</tt> onto type <tt>ty</tt>.  The
opposite of <tt>SwigType_pop()</tt>.
</blockquote>

<p>
<b><tt>SwigType *SwigType_pop_arrays(SwigType *ty)</tt></b>
<blockquote>
Removes all leading array operators from <tt>ty</tt> and returns them. 
<tt>ty</tt> is modified.   For example, if <tt>ty</tt> is <tt>"a(20).a(10).p.int"</tt>,
then this function would return <tt>"a(20).a(10)."</tt> and modify <tt>ty</tt>
so that it has the value <tt>"p.int"</tt>.
</blockquote>

<p>
<b><tt>SwigType *SwigType_pop_function(SwigType *ty)</tt></b>
<blockquote>
Removes a function operator from <tt>ty</tt> including any qualification.
<tt>ty</tt> is modified.   For example, if <tt>ty</tt> is <tt>"f(int).int"</tt>,
then this function would return <tt>"f(int)."</tt> and modify <tt>ty</tt>
so that it has the value <tt>"int"</tt>.
</blockquote>

<p>
<b><tt>SwigType *SwigType_base(SwigType *ty)</tt></b>
<blockquote>
Returns the base type of a type.  For example, if <tt>ty</tt> is
<tt>"p.a(20).int"</tt>, this function would return <tt>"int"</tt>.
<tt>ty</tt> is unmodified.
</blockquote>

<p>
<b><tt>SwigType *SwigType_prefix(SwigType *ty)</tt></b>
<blockquote>
Returns the prefix of a type. For example, if <tt>ty</tt> is
<tt>"p.a(20).int"</tt>, this function would return <tt>"p.a(20)."</tt>.
<tt>ty</tt> is unmodified.
</blockquote>

<h3>Type tests</h3>

The following functions can be used to test properties of a datatype.

<p>
<b><tt>int SwigType_ispointer(SwigType *ty)</tt></b>
<blockquote>
Checks if <tt>ty</tt> is a standard pointer.
</blockquote>

<p>
<b><tt>int SwigType_ismemberpointer(SwigType *ty)</tt></b>
<blockquote>
Checks if <tt>ty</tt> is a member pointer.
</blockquote>

<p>
<b><tt>int SwigType_isreference(SwigType *ty)</tt></b>
<blockquote>
Checks if <tt>ty</tt> is a C++ reference.
</blockquote>

<p>
<b><tt>int SwigType_isarray(SwigType *ty)</tt></b>
<blockquote>
Checks if <tt>ty</tt> is an array.
</blockquote>

<p>
<b><tt>int SwigType_isfunction(SwigType *ty)</tt></b>
<blockquote>
Checks if <tt>ty</tt> is a function.
</blockquote>

<p>
<b><tt>int SwigType_isqualifier(SwigType *ty)</tt></b>
<blockquote>
Checks if <tt>ty</tt> is a qualifier.
</blockquote>

<p>
<b><tt>int SwigType_issimple(SwigType *ty)</tt></b>
<blockquote>
Checks if <tt>ty</tt> is a simple type.  No operators applied.
</blockquote>

<p>
<b><tt>int SwigType_isconst(SwigType *ty)</tt></b>
<blockquote>
Checks if <tt>ty</tt> is a const type.
</blockquote>

<p>
<b><tt>int SwigType_isvarargs(SwigType *ty)</tt></b>
<blockquote>
Checks if <tt>ty</tt> is a varargs type.
</blockquote>

<p>
<b><tt>int SwigType_istemplate(SwigType *ty)</tt></b>
<blockquote>
Checks if <tt>ty</tt> is a templatized type. 
</blockquote>

<h3>Typedef and inheritance</h3>

The behavior of <tt>typedef</tt> declaration is to introduce a type alias.
For instance, <tt>typedef int Integer</tt> makes the identifier 
<tt>Integer</tt> an alias for <tt>int</tt>.  The treatment of typedef in
SWIG is somewhat complicated due to the pattern matching rules that get applied
in typemaps and the fact that SWIG prefers to generate wrapper code
that closely matches the input to simplify debugging (a user will see the
typedef names used in their program instead of the low-level primitive C
datatypes).

<p>
To handle <tt>typedef</tt>, SWIG builds a collection of trees containing typedef relations. For example,

<blockquote>
<pre>
typedef int Integer;
typedef Integer *IntegerPtr;
typedef int Number;
typedef int Size;
</pre>
</blockquote>

produces two trees like this:

<blockquote>
<pre>
                 int               p.Integer
               ^  ^  ^                 ^ 
              /   |   \                |
             /    |    \               |
        Integer  Size   Number    IntegerPtr
</pre>
</blockquote>

To resolve a single typedef relationship, the following function is used:

<p>
<b><tt>SwigType *SwigType_typedef_resolve(SwigType *ty)</tt></b>
<blockquote>
Checks if <tt>ty</tt> can be reduced to a new type via typedef.  If so,
returns the new type.  If not, returns NULL.
</blockquote>

Typedefs are only resolved in simple typenames that appear in a type.
For example, the type base name and in function parameters.   When 
resolving types, the process starts in the leaf nodes and moves up
the tree towards the root.   Here are a few examples that show how it works:

<blockquote>
<pre>
Original type            After typedef_resolve()
------------------------ -----------------------
Integer                  int
a(30).Integer            int
p.IntegerPtr             p.p.Integer
p.p.Integer              p.p.int
</pre>
</blockquote>

For complicated types, the process can be quite involved.  Here is the
reduction of a function pointer:

<blockquote>
<pre>
p.f(Integer, p.IntegerPtr, Size).Integer          : Start
p.f(Integer, p.IntegerPtr, Size).int
p.f(int, p.IntegerPtr, Size).int
p.f(int, p.p.Integer, Size).int
p.f(int, p.p.int, Size).int
p.f(int, p.p.int, int).int                        : End
</pre>
</blockquote>

Two types are equivalent if their full type reductions are the same.
The following function will fully reduce a datatype:

<p>
<b><tt>SwigType *SwigType_typedef_resolve_all(SwigType *ty)</tt></b>
<blockquote>
Fully reduces <tt>ty</tt> according to typedef rules.  Resulting datatype
will consist only of primitive typenames.
</blockquote>

<h3>Output functions</h3>


<h2>Parse Tree Navigation</h2>

<h2>Writing a Language Module</h2>

<h2>Typemaps</h2>

<h2>Guide to parse tree nodes</h2>

This section describes the different parse tree nodes and their attributes.

<p>
<b>cdecl</b>

<blockquote>
Describes general C declarations including variables, functions, and typedefs.
A declaration is parsed as "storage T D" where storage is a storage class, T is a base type,
and D is a declarator.

<pre>
"name"          - Declarator name
"type"          - Base type T
"decl"          - Declarator type (abstract)
"storage"       - Storage class (static, extern, typedef, etc.)
"parms"         - Function parameters (if a function)
"code"          - Function body code (if supplied)
"value"         - Default value (if supplied)
</pre>

</blockquote>

<p>
<b>constructor</b>
<blockquote>
C++ constructor declaration.

<pre>
"name"          - Name of constructor
"parms"         - Parameters
"decl"          - Declarator (function with parameters)
"code"          - Function body code (if any)
"feature:new"   - Set to indicate return of new object.
</pre>
</blockquote>


<p>
<b>destructor</b>
<blockquote>
C++ destructor declaration.

<pre>
"name"          - Name of destructor
"code"          - Function body code (if any)
"storage"       - Storage class (set if virtual)
"value"         - Default value (set if pure virtual).
</pre>
</blockquote>


<p>
<b>access</b>
<blockquote>
C++ access change.

<pre>
"kind"          - public, protected, private
</pre>
</blockquote>


<p>
<b>constant</b>
<blockquote>
Constant created by %constant or #define.

<pre>
"name"          - Name of constant.
"type"          - Base type.
"value"         - Value.
"storage"       - Set to %constant
"feature:immutable" - Set to indicate read-only
</pre>
</blockquote>

<p>
<b>class</b>
<blockquote>
C++ class definition or C structure definition.

<pre>
"name"          - Name of the class.
"kind"          - Class kind ("struct", "union", "class")
"symtab"        - Enclosing symbol table.
"tdname"        - Typedef name. Use for typedef struct { ... } A.
"abstract"      - Set if class has pure virtual methods.
"baselist"      - List of base class names.
"storage"       - Storage class (if any)
"unnamed"       - Set if class is unnamed.
</pre>
</blockquote>


<p>
<b>enum</b>
<blockquote>
Enumeration.

<pre>
"name"          - Name of the enum (if supplied).
"storage"       - Storage class (if any)
"tdname"        - Typedef name (typedef enum { ... } name).
"unnamed"       - Set if enum is unnamed.
</pre>
</blockquote>


<p>
<b>enumitem</b>
<blockquote>
Enumeration value.

<pre>
"name"          - Name of the enum value.
"type"          - Type (integer or char)
"value"         - Enum value (if given)
"feature:immutable" - Set to indicate read-only
</pre>
</blockquote>

<p>
<b>namespace</b>
<blockquote>
C++ namespace.

<pre>
"name"          - Name of the namespace.
"symtab"        - Symbol table for enclosed scope.
"unnamed"       - Set if unnamed namespace
"alias"         - Alias name. Set for namespace A = B;
</pre>
</blockquote>


<p>
<b>using</b>
<blockquote>
C++ using directive.

<pre>
"name"          - Name of the object being referred to.
"uname"         - Qualified name actually given to using.
"node"          - Node being referenced.
"namespace"     - Namespace name being reference (using namespace name)
</pre>
</blockquote>


<p>
<b>classforward</b>
<blockquote>
A forward C++ class declaration.

<pre>
"name"          - Name of the class.
"kind"          - Class kind ("union", "struct", "class")
</pre>
</blockquote>


<p>
<b>insert</b>
<blockquote>
Code insertion directive.  For example, %{ ... %} or 
%insert(section).

<pre>
"code"          - Inserted code
"section"       - Section name ("header", "wrapper", etc.)
</pre>
</blockquote>

<p>
<b>top</b>
<blockquote>
Top of the parse tree.

<pre>
"module"        - Module name
</pre>
</blockquote>

<p>
<b>extend</b>
<blockquote>
%extend directive.

<pre>
"name"          - Module name
"symtab"        - Symbol table of enclosed scope.
</pre>
</blockquote>

<p>
<b>apply</b>
<blockquote>
%apply pattern { patternlist }.

<pre>
"pattern"       - Source pattern.
"symtab"        - Symbol table of enclosed scope.
</pre>
</blockquote>

<p>
<b>clear</b>
<blockquote>
%clear patternlist;

<pre>
"firstChild"    - Patterns to clear
</pre>
</blockquote>

<p>
<b>include</b>
<blockquote>
%include directive.

<pre>
"name"         - Filename
"firstChild"   - Children
</pre>
</blockquote>

<p>
<b>import</b>
<blockquote>
%import directive.

<pre>
"name"         - Filename
"firstChild"   - Children
</pre>
</blockquote>


<p>
<b>module</b>
<blockquote>
%module directive.

<pre>
"name"         - Name of the module
</pre>
</blockquote>


<p>
<b>typemap</b>
<blockquote>
%typemap directive.

<pre>
"method"       - Typemap method name.
"code"         - Typemap code.
"kwargs"       - Keyword arguments (if any)
"firstChild"   - Typemap patterns
</pre>
</blockquote>

<p>
<b>typemapcopy</b>
<blockquote>
%typemap directive with copy.

<pre>
"method"       - Typemap method name.
"pattern"      - Typemap source pattern.
"firstChild"   - Typemap patterns
</pre>
</blockquote>


<p>
<b>typemapitem</b>
<blockquote>
%typemap pattern. Used with %apply, %clear, %typemap.

<pre>
"pattern"      - Typemap pattern (a parameter list)
"parms"        - Typemap parameters.
</pre>
</blockquote>

<p>
<b>types</b>
<blockquote>
%types directive.

<pre>
"parms"        - List of parameter types.
</pre>
</blockquote>


<p>
<b>extern</b>
<blockquote>
extern "X" { ... } declaration.

<pre>
"name"       - Name "C", "Fortran", etc.
</pre>
</blockquote>




<hr>

<address>SWIG 1.3 - Last Modified : January 22, 2002</address>
</body>
</html>

