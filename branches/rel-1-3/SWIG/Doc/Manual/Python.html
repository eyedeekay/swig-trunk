<html>
<head>
<title>SWIG and Python</title>
</head>

<body bgcolor="#ffffff">
<h1>9 SWIG and Python</h1>

<b>Caution: This chapter is under repair!</b>

<p>

This chapter describes SWIG's support of Python.  SWIG is compatible
with most recent Python versions including Python 2.2 as well as older
versions dating back to Python 1.5.  The original release of SWIG was
developed for Python 1.3 so current versions may still work with that
release.  However, this hasn't been tested for quite some time and
your mileage might vary.  For the best results, consider using Python
2.0 or newer.

<p>
This chapter covers most SWIG features, but general features are cover
in less depth than is found in earlier chapters.  At the very least,
make sure you read the "<a href="SWIG.html">SWIG Basics</a>" chapter.

<h2>Overview</h2>

To build Python extension modules, SWIG uses a layered approach.  At
the lowest level, simple procedural wrappers are generated for
functions, classes, methods, and other declarations in the input file.
Then, for structures and classes, an optional collection of Python
proxy classes are generated in order to provide a more natural Python
interface to the objects in your program.  These proxy classes simply
build upon the low-level interface.

<p>
This layered approach to wrapping has a number of benefits.  First,
the low-level procedural interface is relatively simple and can be
packaged into an extension module that works with virtually every
version of Python.  In addition, the use of proxy classes means that
C/C++ objects are wrapped by real Python classes which are free from
the limitations that arise when classes are wrapped into new 
built-in types (a common approach to object wrapping prior to Python 2.2).

<p>
In describing Python interface, this chapter starts by covering the
most critical topics.  First, the problem of configuration, compiling,
and installing Python modules is discussed.  Next, the low-level
procedural interface is presented.  Finally, proxy classes are
described.  Advanced customization features, typemaps, and other
options are found near the end of the chapter.

<h2>Preliminaries</h2>

To build a Python module, run SWIG using the <tt>-python</tt> option :<p>

<p>
<blockquote><pre>$ swig -python example.i
</pre></blockquote>

If building a C++ extension, add the <tt>-c++</tt> option:

<p>
<blockquote><pre>$ swig -c++ -python example.i
</pre></blockquote>

<p>
This creates a file <tt>example_wrap.c</tt> or
<tt>example_wrap.cxx</tt> that contains all of the code needed to
build a Python extension module.  To finish building the module, you 
need to compile this file and link it with the rest of your program.

<h3>Getting the right header files</h3>

In order to compile the wrapper code, the compiler needs the <tt>Python.h</tt> header file.
This file is usually contained in a directory such as 

<p>
<blockquote><pre>/usr/local/include/python2.0
</pre></blockquote>

The exact location may vary on your machine, but the above location is
typical.  If you are not entirely sure where Python is installed, you
can run Python to find out.  For example:

<blockquote>
<pre>
$ python
Python 2.1.1 (#1, Jul 23 2001, 14:36:06)
[GCC egcs-2.91.66 19990314/Linux (egcs-1.1.2 release)] on linux2
Type "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; print sys.prefix
/usr/local
&gt;&gt;&gt;           
</pre>
</blockquote>

<h3>Compiling a dynamic module</h3>

The preferred approach to building an extension module is to compile it into
a shared object file or DLL.   To do this, you will need to compile your program
using comands like this (shown for Linux):

<p>
<blockquote><pre>$ swig -python example.i
$ gcc -c example.c
$ gcc -c example_wrap.c -I/usr/local/include/python2.0
$ gcc -shared example.o example_wrap.o -o examplemodule.so
</pre></blockquote>

The exact commands for doing this vary from platform to platform. 
SWIG tries to guess the right options when it is installed.  Therefore, 
you may want to start with one of the examples in the <tt>SWIG/Examples/python</tt> 
directory.   If that doesn't work, you will need to read the man-pages for
your compiler and linker to get the right set of options.  You might also
check the <a href="http://swig.cs.uchicago.edu/cgi-bin/wiki.pl">SWIG Wiki</a> for
additional information.
<p>
When linking the module, the name of the output file has to match the name
of the module.  If the name of your SWIG module is "<tt>example</tt>", the
name of the corresponding object file should be
"<tt>examplemodule.so</tt>" or "<tt>example.so</tt>".
The name of the module is specified using the <tt>%module</tt> directive or the 
<tt> -module</tt> command line option.<p>

<h3>Using distutils</h3>

<h3>Static linking</h3>

An alternative approach to dynamic linking is to rebuild the Python
interpreter with your extension module added to it.  In the past,
this approach was sometimes necesssary due to limitations in dynamic loading
support on certain machines.  However, the situation has improved greatly
over the last few years and you should not consider this approach 
unless there is really no other option.

<p>
The usual procedure for adding a new module to Python involves finding
the Python source, adding an entry to the <tt>Modules/Setup</tt> file,
and rebuilding the interpreter using the Python Makefile.  However,
newer Python versions have changed the build process.  You may need to edit
the 'setup.py' file in the Python distribution instead.

<p>
In earlier versions of SWIG, the <tt>embed.i</tt> library file could be used to
rebuild the interpreter.  For example:

<p>
<blockquote><pre>%module example

extern int fact(int);
extern int mod(int, int);
extern double My_variable;

%include embed.i       // Include code for a static version of Python

</pre></blockquote>

The <tt>embed.i</tt> library file includes supporting code that
contains everything needed to rebuild Python. To rebuild the interpreter,
you simply do something like this:

<p>
<blockquote><pre>$ swig -python example.i
$ gcc example.c example_wrap.c \
        -Xlinker -export-dynamic \
        -DHAVE_CONFIG_H -I/usr/local/include/python2.1 \
	-I/usr/local/lib/python2.1/config \
	-L/usr/local/lib/python2.1/config -lpython2.1 -lm -ldl \
	-o mypython

</pre></blockquote>
You will need to supply the same libraries that were used to build Python the first
time.  This may include system libraries such as <tt>-lsocket</tt>, <tt>-lnsl</tt>,
and <tt>-lpthread</tt>.  Assuming this actually works, the new version of Python
should be identical to the default version except that your extension module will be
a built-in part of the interpreter.

<p>

<b>Comment:</b> In practice, you should probably try to avoid static
linking if possible. Some programmers may be inclined
to use static linking in the interest of getting better performance.
However, the performance gained by static linking tends to be rather
minimal in most situations (and quite frankly not worth the extra
hassle in the opinion of this author). 

<p>
<b>Compatibility note:</b> The <tt>embed.i</tt> library file is
deprecated and has not been maintained for several years.  Even though it
appears to "work" with Python 2.1, no future support is guaranteed.
If using static linking, you might want to rely on a different approach
(perhaps using distutils).

<h3> Using your module</h3>

To use your module, simply use the Python <tt>import</tt> statement.  If
all goes well, you will be able to this:

<p>
<blockquote><pre>$ python
&gt;&gt;&gt; import example
&gt;&gt;&gt; example.fact(4)
24
&gt;&gt;&gt;
</pre></blockquote>

A common error received by first-time users is the following:

<blockquote>
<pre>
&gt;&gt;&gt; import example
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ImportError: dynamic module does not define init function (initexample)
&gt;&gt;&gt;                                                               
</pre>
</blockquote>

This error is almost always caused when the name of the shared object file doesn't
match the name of the module supplied using the SWIG <tt>%module</tt> directive.
Double-check the interface to make sure the module name and the shared object
file match.  Another possible cause of this error is forgetting to link the SWIG-generated
wrapper code with the rest of your application when creating the extension module.


<p>
Another common error is something similar to the following:

<blockquote>
<pre>
Traceback (most recent call last):
  File "example.py", line 3, in ?
    import example
ImportError: ./examplemodule.so: undefined symbol: fact
</pre>
</blockquote>

This error usually indicates that you forgot to include some object
files or libraries in the linking of the shared library file.  Make
sure you compile both the SWIG wrapper file and your original program
into a shared library file.  Make sure you pass all of the required libraries
to the linker.  

<p>
Sometimes unresolved symbols occur because a wrapper has been created
for a function that doesn't actually exist in a library.  This usually
occurs when a header file includes a declaration for a function that
was never actually implemented or it was removed from a library
without updating the header file.  To fix this, you can either edit
the SWIG input file to remove the offending declaration or you can use
the <tt>%ignore</tt> directive to ignore the declaration.

<p>
Finally, suppose that your extension module is linked with another library like this:

<blockquote>
<pre>
$ gcc -shared example.o example_wrap.o -L/home/beazley/projects/lib -lfoo \
      -o examplemodule.so
</pre>
</blockquote>

If the <tt>foo</tt> library is compiled as a shared library, you might get the following
problem when you try to use your module:

<blockquote>
<pre>
>>> import example
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
ImportError: libfoo.so: cannot open shared object file: No such file or directory
>>>                 
</pre>
</blockquote>

This error is generated because the dynamic linker can't locate the
<tt>libfoo.so</tt> library.  When shared libraries are loaded, the
system normally only checks a few standard locations such as
<tt>/usr/lib</tt> and <tt>/usr/local/lib</tt>.   To fix this problem,
there are several things you can do.  First, you can recompile your extension
module with extra path information. For example, on Linux you can do this:

<blockquote>
<pre>
$ gcc -shared example.o example_wrap.o -L/home/beazley/projects/lib -lfoo \
      -Xlinker -rpath /home/beazley/projects/lib \
      -o examplemodule.so
</pre>
</blockquote>

Alternatively, you can set the <tt>LD_LIBRARY_PATH</tt> environment variable to
include the directory with your shared libraries. 
If setting <tt>LD_LIBRARY_PATH</tt>, be aware that setting this variable can introduce
a noticeable performance impact on all other applications that you run.
To set it only for Python, you might want to do this instead:

<blockquote>
<pre>
$ env LD_LIBRARY_PATH=/home/beazley/projects/lib python
</pre>
</blockquote>

Finally, you can use a command such as <tt>ldconfig</tt> to add additional search paths
to the default system configuration (this requires root access and you will need to read
the man pages). 

<h3>Compilation of C++ extensions</h3>

Compilation of C++ extensions has traditionally been a tricky problem.
Since the Python interpreter is written in C, you need to take steps to
make sure C++ is properly initialized and that modules are compiled
correctly.

<p>
On most machines, C++ extension modules should be linked using the C++
compiler.  For example:

<p>
<blockquote><pre>% swig -c++ -python example.i
% g++ -c example.cxx
% g++ -c example_wrap.cxx -I/usr/local/include/python2.0
% g++ -shared example.o example_wrap.o -o examplemodule.so
</pre></blockquote>

In addition to this, you may need to include additional library
files to make it work.  For example, if you are using the Sun C++ compiler on
Solaris, you often need to add an extra library <tt>-lCrun</tt> like this:

<p>
<blockquote><pre>% swig -c++ -python example.i
% CC -c example.cxx
% CC -c example_wrap.cxx -I/usr/local/include/python2.0
% CC -G example.o example_wrap.o -L/opt/SUNWspro/lib -o examplemodule.so -lCrun
</pre></blockquote>

Of course, the extra libraries to use are completely non-portable---you will 
probably need to do some experimentation.

<p>
Sometimes people have suggested that it is necessary to relink the
Python interpreter using the C++ compiler to make C++ extension modules work.
In the experience of this author, this has never actually appeared to be
necessary.   Relinking the interpreter with C++ really only includes the 
special run-time libraries described above---as long as you link your extension 
modules with these libraries, it should not be necessary to rebuild Python.

<p>
If you aren't entirely sure about the linking of a C++ extension, you
might look at an existing C++ program.  On many Unix machines, the
<tt>ldd</tt> command will list library dependencies.  This should give
you some clues about what you might have to include when you link your
extension module. For example:

<blockquote>
<pre>
$ ldd swig
        libstdc++-libc6.1-1.so.2 => /usr/lib/libstdc++-libc6.1-1.so.2 (0x40019000)
        libm.so.6 => /lib/libm.so.6 (0x4005b000)
        libc.so.6 => /lib/libc.so.6 (0x40077000)
        /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
$
</pre>
</blockquote>

<p>
As a final complication, a major weakness of C++ is that it does not
define any sort of standard for binary linking of libraries.  This
means that C++ code compiled by different compilers will not link
together properly as libraries nor is the memory layout of classes and
data structures implemented in any kind of portable manner.  In a
monolithic C++ program, this problem may be unnoticed.  However, in Python, it
is possible for different extension modules to be compiled with
different C++ compilers.  As long as these modules are self-contained,
this probably won't matter.  However, if these modules start sharing data,
you will need to take steps to avoid segmentation faults and other
erratic program behavior.   If working with lots of software components, you
might want to investigate using a more formal standard such as COM.

<h3>Compiling for 64-bit platforms</h3>

On platforms that support 64-bit applications (Solaris, Irix, etc.),
special care is required when building extension modules.  On these
machines, 64-bit applications are compiled and linked using a different
set of compiler/linker options.  In addition, it is not generally possible to mix 
32-bit and 64-bit code together in the same application.

<p>
To utilize 64-bits, the Python executable will need to be recompiled
as a 64-bit application.  In addition, all libraries, wrapper code,
and every other part of your application will need to be compiled for
64-bits.  If you plan to use other third-party extension modules, they
will also have to be recompiled as 64-bit extensions.

<p>
If you are wrapping commercial software for which you have no source
code, you will be forced to use the same linking standard as used by
that software.  This may prevent the use of 64-bit extensions.  It may
also introduce problems on platforms that support more than one
linking standard (e.g., -o32 and -n32 on Irix).

<h3> Building Python Extensions under Windows</h3>

Building a SWIG extension to Python under Windows is roughly
similar to the process used with Unix.   You will need to create a
DLL that can be loaded into the interpreter.  This section briefly
describes the use of SWIG with Microsoft Visual C++.   As a starting
point, many of SWIG's examples include project files.  You might want to 
take a quick look at these in addition to reading this section.

<p>
In Developer Studio, SWIG should be invoked as a custom build option.
This is usually done as follows:

<p>
<ul>
<li>Open up a new workspace and use the AppWizard to select a DLL
project.

<li>Add both the SWIG interface file (the .i file), any supporting C
files, and the name of the wrapper file that will be created by SWIG
(ie. <tt>example_wrap.c</tt>).  Note : If using C++, choose a
different suffix for the wrapper file such as
<tt>example_wrap.cxx</tt>. Don't worry if the wrapper file doesn't
exist yet--Developer Studio keeps a reference to it.

<li>Select the SWIG interface file and go to the settings menu.  Under
settings, select the "Custom Build" option.

<li>Enter "SWIG" in the description field.

<li>Enter "<tt>swig -python -o $(ProjDir)\$(InputName)_wrap.c $(InputPath)</tt>" in the "Build command(s) field"

<li>Enter "<tt>$(ProjDir)\$(InputName)_wrap.c</tt>" in the "Output files(s) field".

<li>Next, select the settings for the entire project and go to
"C++:Preprocessor". Add the include directories for your Python
installation under "Additional include directories".

<li>Define the symbol  __WIN32__ under preprocessor options.  

<li>Finally, select the settings for the entire project and go to
"Link Options".  Add the Python library file to your link libraries.
For example "python21.lib".  Also, set the name of the output file to
match the name of your Python module (ie. example.dll).

<li>Build your project.
</ul>
<p>
If all went well, SWIG will be automatically invoked whenever
you build your project.  Any changes made to the interface file will
result in SWIG being automatically executed to produce a new version of
the wrapper file. 

<p>
To run your new Python extension, simply run Python
and use the <tt>import</tt> command as normal. For example :<p>

<p>
<blockquote><pre>
MSDOS &gt; python
&gt;&gt;&gt; import example
&gt;&gt;&gt; print example.fact(4)
24
&gt;&gt;&gt;
</pre></blockquote>

If you get an <tt>ImportError</tt> exception when importing the module, you may
have forgotten to include aditional library files when you built your module.
If you get an access violation or some kind of general protection fault 
immediately upon import, you have a more serious problem.   This 
is often caused by linking your extension module against the wrong 
set of Win32 debug or thread libraries.  You will have to fiddle around with
the build options of project to try and track this down.

<p>
Some users have reported success in building extension modules using Cygwin
and other compilers.  However, the problem of building usable DLLs with these
compilers tends to be rather problematic.  For the latest information,
you may want to consult the <a href="http://swig.cs.uchicago.edu/cgi-bin/wiki.pl">
SWIG Wiki</a>.

<h2>The low-level procedural interface</h2>

At its core, the Python module uses a simple low-level interface
to C function, variables, constants, and classes.  This low-level interface
can be used to control your application.  However, it is also used to
construct more user-friendly proxy classes as described in the next section.

<h3> Modules</h3>

The SWIG <tt>%module</tt> directive specifies the name of the Python
module. If you specify `<tt>%module example</tt>', then everything is
wrapped into a Python '<tt>example</tt>' module.  When choosing a
module name, make sure you don't use the same name as a built-in
Python command or standard module name.  Otherwise, the results may be
unpredictable.

<h3>Functions</h3>

Global functions are wrapped as new Python built-in functions.  For example,

<p>
<blockquote><pre>%module example
int fact(int n);

</pre></blockquote>

creates a built-in function <tt>example.fact(n)</tt> that works like this:<p>

<p>
<blockquote><pre>&gt;&gt;&gt; import example
&gt;&gt;&gt; print example.fact(4)
24
&gt;&gt;&gt;
</pre></blockquote>

<h3>Variable Linking</h3>

C/C++ global variables are fully supported by SWIG.  However, the underlying
mechanism is somewhat different than you might expect due to the way that
Python assignment works.  When you type the following in Python<p>

<p>
<blockquote><pre>a = 3.4

</pre></blockquote>
"a" becomes a name for an object containing the value 3.4. If you later type<p>
<p>
<blockquote><pre>b = a

</pre></blockquote>

then "a" and "b" are both names for the object containing the value
3.4. Thus, there is only one object containing 3.4 and "a"
and "b" are both names that refer to it. This is quite
different than C where a variable name refers to a memory location in which
a value is stored (and assignment copies data into that location). 
Because of this, there is no direct way to map variable 
assignment in C to variable assignment in Python.

<p>
To provide access to C global variables, SWIG creates a special
object called `<tt>cvar</tt>' that is added to each SWIG generated
module. Global variables are then accessed as attributes of this object.
For example, consider this interface

<blockquote><pre>
// SWIG interface file with global variables
%module example
...
extern int My_variable;
extern double density;
...
</pre></blockquote>
<p>
Now look at the Python interface:<p>
<p>
<blockquote><pre>&gt;&gt;&gt; import example
&gt;&gt;&gt; # Print out value of a C global variable
&gt;&gt;&gt; print example.cvar.My_variable
4
&gt;&gt;&gt; # Set the value of a C global variable
&gt;&gt;&gt; example.cvar.density = 0.8442
&gt;&gt;&gt; # Use in a math operation
&gt;&gt;&gt; example.cvar.density = example.cvar.density*1.10
</pre></blockquote>

<p>
If you make an error in variable assignment, you will receive an
error message.  For example:

<blockquote><pre>
&gt;&gt;&gt; example.cvar.density = "Hello"
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: C variable 'density (double )'
&gt;&gt;&gt; 
</pre></blockquote>

<p>
If a variable is declared as <tt>const</tt>, it is wrapped as a
read-only variable.  Attempts to modify its value will result in an
error.

<p>
To make ordinary variables read-only, you can also use the <tt>%immutable</tt> directive. For example:

<blockquote>
<pre>
%immutable;
extern char *path;
%mutable;
</pre>
</blockquote>

The <tt>%immutable</tt> directive stays in effect until it is explicitly disabled using
<tt>%mutable</tt>.

<p>
If you would like to use a name other than "<tt>cvar</tt>", it can be
changed using the <tt>-globals</tt> option :<p>

<p>
<blockquote><pre>% swig -python -globals myvar example.i

</pre></blockquote>

Finally, some care is in order when importing multiple SWIG modules.
If you use the "<tt>from &lt;file&gt; import *</tt>" style of
importing, you will get a name clash on the variable `<tt>cvar</tt>'
and you will only be able to access global variables from the last
module loaded. To prevent this, you might consider renaming
<tt>cvar</tt> or making it private to the module by giving it a name
that starts with a leading underscore. Also, SWIG does not create <tt>cvar</tt>
if there are no global variables in a module.<p>

<h3> Constants</h3>

C/C++ constants are installed as Python objects containing the
appropriate value.  To create a constant, use <tt>#define</tt> or the
<tt>%constant</tt> directive.  For example:

<blockquote>
<pre>
#define PI 3.14159
#define VERSION "1.0"

%constant int FOO = 42;
%constant const char *path = "/usr/local";
</pre>
</blockquote>

Note:  C declarations declared as <tt>const</tt> are wrapped as read-only variables and
will be accessed using the <tt>cvar</tt> object described in the previous section.  They
are not wrapped as constants.

<p>
Constants are not guaranteed to remain constant in Python---the name
of the constant could be accidentally reassigned to refer to some
other object.  Unfortunately, there is no easy way for SWIG to
generate code that prevents this.  You will just have to be careful.

<h3>Pointers</h3>

Pointers to C/C++ objects are represented as encoded character strings such as
the following :<p>

<p>
<blockquote><pre>_800f8e28_p_Vector

</pre></blockquote>

A NULL pointer is represented by the Python <tt>None</tt> object.

<p>
As an alternative to strings, SWIG can also encode pointers as a
Python CObject type.  CObjects are rarely discussed in most Python books
or documentation.  However, this is a special built-in type that can be
used to hold raw C pointer values.   Internally, a CObject is just a container
that holds a raw <tt>void *</tt> along with some additional information such 
as a type-string.

<p>
If you want to use CObjects instead of strings, compile the SWIG wrapper
code with the <tt>-DSWIG_COBJECT_TYPES</tt> option.  For example:

<p>
<blockquote><pre>% swig -python example.i
% gcc -c example.c
% gcc -c -DSWIG_COBJECT_TYPES example_wrap.c -I/usr/local/include/python2.0
% gcc -shared example.o example_wrap.o -o examplemodule.so
</pre></blockquote>

The choice of whether or not to use strings or CObjects is mostly a matter
of personal preference.  There is no significant performance difference between
using one type or the other (strings actually appear to be ever-so-slightly faster
on the author's machine).  Although CObjects feel more natural to some programmers,
a disadvantage of this approach is that it makes debugging more difficult.  For example,
if you are using CObjects, you will get code that works like this:

<blockquote>
<pre>
&gt;&gt;&gt; import example
&gt;&gt;&gt; a = example.new_Circle(10)
&gt;&gt;&gt; b = example.new_Square(20)
&gt;&gt;&gt; a
&lt;PyCObject object at 0x80c5e60&gt;
&gt;&gt;&gt; b
&lt;PyCObject object at 0x8107800&gt;
&gt;&gt;&gt; 
</pre>
</blockquote>

Notice how no clues regarding the type of <tt>a</tt> and <tt>b</tt> is shown. On the other hand,
the string representation produces the following:

<blockquote>
<pre>
&gt;&gt;&gt; a
'_88671008_p_Circle'
&gt;&gt;&gt; b
'_605f0c08_p_Square'
&gt;&gt;&gt; 
</pre>
</blockquote>

As much as you might be inclined to modify a pointer value directly
from Python, don't.  The hexadecimal encoding is not necessarily the
same as the logical memory address of the underlying object.  Instead
it is the raw byte encoding of the pointer value.  The encoding will
vary depending on the native byte-ordering of the platform (i.e.,
big-endian vs. little-endian).  Similarly, don't try to manually cast
a pointer to a new type by simply replacing the type-string.  This
may not work like you expect, it is particularly dangerous when
casting C++ objects, and it won't work if you switch to a new pointer
representation such as CObjects.  If you need to cast a pointer or
change its value, consider writing some helper functions instead.  For
example:

<blockquote>
<pre>
%inline %{
/* C-style cast */
Bar *FooToBar(Foo *f) {
   return (Bar *) f;
}

/* C++-style cast */
Foo *BarToFoo(Bar *b) {
   return dynamic_cast&lt;Foo*&gt;(b);
}

Foo *IncrFoo(Foo *f, int i) {
    return f+i;
}
%}
</pre>
</blockquote>

Also, if working with C++, you should always try
to use the new C++ style casts.  For example, in the above code, the
C-style cast may return a bogus result whereas as the C++-style cast will return
<tt>None</tt> if the conversion can't be performed.

<h3>Structures</h3>

Access to the contents of a structure are provided through a set of low-level
accessor functions as described in the "SWIG Basics" chapter.  For example,
<p>

<p>
<blockquote><pre>struct Vector {
	double x,y,z;
};

</pre></blockquote>

gets mapped into the following collection of accessor functions:

<p>
<blockquote><pre>
struct Vector *new_Vector();
void           delete_Vector(Vector *v);
double         Vector_x_get(Vector *obj)
void           Vector_x_set(Vector *obj, double x)
double         Vector_y_get(Vector *obj)
void           Vector_y_set(Vector *obj, double y)
double         Vector_z_get(Vector *obj)
void           Vector_z_set(Vector *obj, double z)

</pre></blockquote>

These functions are then used to access structure data from Python as follows:

<p>
<blockquote><pre>
&gt;&gt;&gt; v = new_Vector()
&gt;&gt;&gt; Vector_x_get(v)
3.5
&gt;&gt;&gt; Vector_x_set(v,7.8)       # Change x component
&gt;&gt;&gt; print Vector_x_get(v), Vector_y_get(v), Vector_z_get(v)
7.8 -4.5 0.0
&gt;&gt;&gt; 
</pre></blockquote>
<p>

Similar access is provided for unions and the data members of C++ classes.<p>

<p>
<tt>const</tt> members of a structure are read-only. Data members
can also be forced to be read-only using the <tt>%immutable</tt> directive. For example:

<blockquote>
<pre>
struct Foo {
   ...
   %immutable;
   int x;        /* Read-only members */
   char *name;
   %mutable;
   ...
};
</pre>
</blockquote>

<p>
When <tt>char *</tt> members of a structure are wrapped, the contents are assumed to be
dynamically allocated using <tt>malloc</tt> or <tt>new</tt> (depending on whether or not
SWIG is run with the -c++ option).   When the structure member is set, the old contents will be 
released and a new value created.   If this is not the behavior you want, you will have to use
a typemap (described shortly).

<p>
Array members are normally wrapped as read-only.   For example,

<blockquote>
<pre>
struct Foo {
   int  x[50];
};
</pre>
</blockquote>

produces a single accessor function like this:

<blockquote>
<pre>
int *Foo_x_get(Foo *self) {
    return self->x;
};
</pre>
</blockquote>

If you want to set an array member, you will need to supply a "memberin" typemap
described later in this chapter.  As a special case, SWIG does generate
code to set array members of type <tt>char</tt> (allowing you to store a Python
string in the structure).

<p>
When structure members are wrapped, they are handled as pointers.   For example,

<blockquote>
<pre>
struct Foo {
   ...
};

struct Bar {
   Foo f;
};
</pre>
</blockquote>

generates accessor functions such as this:

<blockquote>
<pre>
Foo *Bar_f_get(Bar *b) {
    return &b->f;
}

void Bar_f_set(Bar *b, Foo *val) {
    b->f = *val;
}
</pre>
</blockquote>

<h3>C++ classes</h3>

C++ classes are wrapped by building a set of low level accessor functions. 
Consider the following class :<p>

<p>
<blockquote><pre>class List {
public:
  List();
  ~List();
  int  search(char *item);
  void insert(char *item);
  void remove(char *item);
  char *get(int n);
  int  length;
static void print(List *l);
};
</pre></blockquote>

<p>
When wrapped by SWIG, the following functions are created :<p>

<p>
<blockquote><pre>List    *new_List();
void     delete_List(List *l);
int      List_search(List *l, char *item);
void     List_insert(List *l, char *item);
void     List_remove(List *l, char *item);
char    *List_get(List *l, int n);
int      List_length_get(List *l);
void     List_length_set(List *l, int n);
void     List_print(List *l);

</pre></blockquote>

In Python, these functions are used as follows:

<blockquote><pre>
&gt;&gt;&gt; l = new_List()
&gt;&gt;&gt; List_insert(l,"Ale")
&gt;&gt;&gt; List_insert(l,"Stout")
&gt;&gt;&gt; List_insert(l,"Lager")
&gt;&gt;&gt; List_print(l)
Lager
Stout
Ale
&gt;&gt;&gt; print List_length_get(l)
3
&gt;&gt;&gt; print l
_80085608_p_List
&gt;&gt;&gt;

</pre></blockquote>

At this low level, C++ objects are really just typed pointers.  Member
functions are accessed by calling a C-like wrapper with an instance pointer
as the first argument.   Although this interface is fairly primitive, it
provides direct access to C++ objects.  A higher level interface known as shadow classes
can be built using these low-level accessors.  This is described shortly.

<h3>C++ classes and type-checking</h3>

The SWIG type-checker is fully aware of C++ inheritance.  Therefore, if you have
classes like this

<blockquote>
<pre>
class Foo {
...
};

class Bar : public Foo {
...
};
</pre>
</blockquote>

and a function

<blockquote>
<pre>
void spam(Foo *f);
</pre>
</blockquote>

then the function <tt>spam()</tt> accepts <tt>Foo *</tt> or a pointer to any class derived from <tt>Foo</tt>.
If necesssary, the type-checker also adjusts the value of the pointer (as is necessary when
multiple inheritance is used).

<h3>C++ overloaded functions</h3>

If you have a C++ program with overloaded functions or methods, you will need to disambiguate
those methods using <tt>%rename</tt>.   For example:

<blockquote>
<pre>
/* Forward renaming declarations */
%rename(foo_i) foo(int); 
%rename(foo_d) foo(double);
...
void foo(int);           // Becomes 'foo_i'
void foo(char *c);       // Stays 'foo' (not renamed)

class Spam {
public:
   void foo(int);      // Becomes 'foo_i'
   void foo(double);   // Becomes 'foo_d'
   ...
};
</pre>
</blockquote>

Now, in Python, the methods are accessed as follows:

<blockquote>
<pre>
>>> import example
>>> example.foo_i(3)
>>> s = example.new_Spam()
>>> Spam_foo_i(s,3)
>>> Spam_foo_d(s,3.14)
</pre>
</blockquote>

Please refer to the "SWIG Basics" chapter for more information. 

<h3>Operators</h3>

C++ operators can also be wrapped using the <tt>%rename</tt> directive.  All you need to do is
give the operator the name of a valid Python identifier.  For example:

<blockquote>
<pre>
%rename(add_complex) operator+(Complex &, Complex &);
...
Complex operator+(Complex &, Complex &);
</pre>
</blockquote>

Now, in Python, you can do this:

<blockquote>
<pre>
>>> a = example.new_Complex(2,3)
>>> b = example.new_Complex(4,-1)
>>> c = example.add_complex(a,b)
</pre>
</blockquote>

More details about wrapping C++ operators into Python operators is discussed a little later.

<h2>Input and output parameters</h2>

A common problem in some C programs is handling parameters passed as simple pointers.  For
example:

<blockquote>
<pre>
void add(int x, int y, int *result) {
   *result = x + y;
}
</pre>
</blockquote>

or perhaps

<blockquote>
<pre>
int sub(int *x, int *y) {
   return *x+*y;
}
</pre>
</blockquote>

The easiest way to handle these situations is to use the <tt>typemaps.i</tt> file.  For example:

<blockquote>
<pre>
%module example
%include "typemaps.i"

void add(int, int, int *OUTPUT);
int  sub(int *INPUT, int *INPUT);
</pre>
</blockquote>

In Python, this allows you to pass simple values.  For example:

<blockquote>
<pre>
>>> a = add(3,4)
>>> print a
7
>>> b = sub(7,4)
>>> print b
3
>>>
</pre>
</blockquote>

Notice how the <tt>INPUT</tt> parameters allow integer values to be passed instead of pointers
and how the <tt>OUTPUT</tt> parameter creates a return result.

<p>
If you don't want to use the names <tt>INPUT</tt> or <tt>OUTPUT</tt>, use the <tt>%apply</tt>
directive.  For example:

<blockquote>
<pre>
%module example
%include "typemaps.i"

%apply int *OUTPUT { int *result };
%apply int *INPUT  { int *x, int *y};

void add(int x, int y, int *result);
int  sub(int *x, int *y);
</pre>
</blockquote>

<p>
If a function mutates one of its parameters like this,

<blockquote>
<pre>
void negate(int *x) {
   *x = -(*x);
}
</pre>
</blockquote>

you can use <tt>INOUT</tt> like this:

<blockquote>
<pre>
%include "typemaps.i"
...
void negate(int *INOUT);
</pre>
</blockquote>

In Python, a mutated parameter shows up as a return value.  For example:

<blockquote>
<pre>
>>> a = negate(3)
>>> print a
-3
>>>
</pre>
</blockquote>

Note: Since most primitive Python objects are immutable, it is not possible to
perform in-place modification of a Python object passed as a parameter.

<p>
The most common use of these special typemap rules is to handle functions that
return more than one value.   For example, sometimes a function returns a result
as well as a special error code:

<blockquote>
<pre>
/* send message, return number of bytes sent, along with success code */
int send_message(char *text, int len, int *success);
</pre>
</blockquote>

To wrap such a function, simply use the <tt>OUTPUT</tt> rule above. For example:

<blockquote>
<pre>
%module example
%include "typemaps.i"
%apply int *OUTPUT { int *success };
...
int send_message(char *text, int *success);
</pre>
</blockquote>

When used in Python, the function will return multiple values.  

<blockquote>
<pre>
bytes, success = send_message("Hello World")
if not success:
    print "Whoa!"
else:
    print "Sent", bytes
</pre>
</blockquote>

Another common use of multiple return values are in query functions.  For example:

<blockquote>
<pre>
void get_dimensions(Matrix *m, int *rows, int *columns);
</pre>
</blockquote>

To wrap this, you might use the following:

<blockquote>
<pre>
%module example
%include "typemaps.i"
%apply int *OUTPUT { int *rows, int *columns };
...
void get_dimensions(Matrix *m, int *rows, *columns);
</pre>
</blockquote>

Now, in Python:

<blockquote>
<pre>
>>> r,c = get_dimensions(m)
</pre>
</blockquote>

<h2>Simple exception handling </h2>

The SWIG <tt>%exception</tt> directive can be used to define a
user-definable exception handler that can convert C/C++ errors into Python exceptions.
The chapter on customization features contains more details, but suppose you have a C++ class like
the following :<p>

<blockquote><pre>
class RangeError {};   // Used for an exception

class DoubleArray {
  private:
    int n;
    double *ptr;
  public:
    // Create a new array of fixed size
    DoubleArray(int size) {
      ptr = new double[size];
      n = size;
    }
    // Destroy an array
    ~DoubleArray() {
       delete ptr;
    }
    // Return the length of the array
    int   length() {
      return n;
    }

    // Get an item from the array and perform bounds checking.
    double getitem(int i) {
      if ((i &gt;= 0) &amp;&amp; (i &lt; n))
        return ptr[i];
      else
        throw RangeError();
    }
    // Set an item in the array and perform bounds checking.
    void setitem(int i, double val) {
      if ((i &gt;= 0) &amp;&amp; (i &lt; n))
        ptr[i] = val;
      else {
        throw RangeError();
      }
    }
  };
</pre></blockquote>
<p>

Since several methods in this class can throw an exception
for an out-of-bounds access, you might want to catch
this in the Python extension by writing the following in an
interface file:

<p>
<blockquote><pre>%exception {
  try {
    $action
  }
  catch (RangeError) {
    PyErr_SetString(PyExc_IndexError,"index out-of-bounds");
    return NULL;
  }
}

class DoubleArray {
...
};
</pre></blockquote>

The exception handling code is inserted directly into generated wrapper
functions.  The <tt>$action</tt> variable is replaced with the C/C++
code being executed by the wrapper.  When an exception handler
is defined, errors can be caught and used to gracefully raise a Python
exception instead of forcing the entire program to terminate with an uncaught
error.

<p>
As shown, the exception handling code will be added to every wrapper function.
Since this is somewhat inefficient.  You might consider refining the 
exception handler to only apply to specific methods like this:

<blockquote>
<pre>
%exception getitem {
  try {
    $action
  }
  catch (RangeError) {
    PyErr_SetString(PyExc_IndexError,"index out-of-bounds");
    return NULL;
  }
}

%exception setitem {
  try {
    $action
  }
  catch (RangeError) {
    PyErr_SetString(PyExc_IndexError,"index out-of-bounds");
    return NULL;
  }
}
</pre>
</blockquote>

In this case, the exception handler is only attached to methods and functions
named <tt>getitem</tt> and <tt>setitem</tt>.

<p>
If you had a lot of different methods, you can avoid extra typing by using a macro.
For example:

<blockquote>
<pre>
%define RANGE_ERROR
{
  try {
    $action
  }
  catch (RangeError) {
    PyErr_SetString(PyExc_IndexError,"index out-of-bounds");
    return NULL;
  }
}
%enddef

%exception getitem RANGE_ERROR;
%exception setitem RANGE_ERROR;
</pre>
</blockquote>

Since SWIG's exception handling is user-definable, you are not limited to C++ exception handling.
See the chapter on "<a href="Exceptions.html">Exception Handling</a>" for more examples.

<p>
When raising a Python exception from C, use the <tt>PyErr_SetString()</tt>
function as shown above.  The following exception types can be used as the first argument.

<blockquote>
<pre>
PyExc_ArithmeticError
PyExc_AssertionError
PyExc_AttributeError
PyExc_EnvironmentError
PyExc_EOFError
PyExc_Exception
PyExc_FloatingPointError
PyExc_ImportError
PyExc_IndexError
PyExc_IOError
PyExc_KeyError
PyExc_KeyboardInterrupt
PyExc_LookupError
PyExc_MemoryError
PyExc_NameError
PyExc_NotImplementedError
PyExc_OSError
PyExc_OverflowError
PyExc_RuntimeError
PyExc_StandardError
PyExc_SyntaxError
PyExc_SystemError
PyExc_TypeError
PyExc_UnicodeError
PyExc_ValueError
PyExc_ZeroDivisionError
</pre>
</blockquote>

These exceptions are actually organized into an hierarchy as shown below.  Consult the Python
Essential Reference for more details (shameless plug):

<blockquote>
<pre>
PyExc_Exception
    PyExc_SystemExit
    PyExc_StandardError
       PyExc_ArithmeticError
           PyExc_FloatingPointError
           PyExc_OverflowError
           PyExc_ZeroDivisionError
       PyExc_AssertionError
       PyExc_AttributeError
       PyExc_EnvironmentError
           PyExc_IOError  
           PyExc_OSError
       PyExc_EOFError
       PyExc_ImportError
       PyExc_KeyboardInterrupt
       PyExc_LookupError
           PyExc_IndexError
           PyExc_KeyError
       PyExc_MemoryError
       PyExc_NameError
       PyExc_RuntimeError
           PyExc_NotImplementedError
       PyExc_SyntaxError
       PyExc_SystemError
       PyExc_TypeError
       PyExc_ValueError
           PyExc_UnicodeError
</pre>
</blockquote>

<p>
<b>Compatibility note:</b> In SWIG1.1, exceptions were defined using the older <tt>%except</tt> directive:
<blockquote>
<pre>
%except(python) {
  try {
    $action
  }
  catch (RangeError) {
    PyErr_SetString(PyExc_IndexError,"index out-of-bounds");
    return NULL;
  }
}
</pre>
</blockquote>

This is still supported, but it is deprecated.  The newer <tt>%exception</tt> directive provides the same
functionality, but it has additional capabilities that make it more powerful.

<h2>Typemaps</h2>

This section describes how you can modify SWIG's default wrapping behavior
for various C/C++ datatypes using the <tt>%typemap</tt> directive.   This
is an advanced topic that assumes familiarity with the Python C API as well
as the material in the "<a href="Typemaps.html">Typemaps</a>" chapter.

<p>
Before proceeding, it should be stressed that typemaps are not a required 
part of using SWIG---the default wrapping behavior is enough in most cases.
Typemaps are only used if you want to change some aspect of the primitive
C-Python interface.

<h3> What is a typemap?</h3>

A typemap is nothing more than a code generation rule that is attached to 
a specific C datatype.   For example, to convert integers from Python to C,
you might define a typemap like this:

<p>
<blockquote><pre>%module example

%typemap(in) int {
	$1 = (int) PyLong_AsLong($input);
	printf("Received an integer : %d\n",$1);
}
extern int fact(int n);
</pre></blockquote>

<p>
Typemaps are always associated with some specific aspect of code generation.
In this case, the "in" method refers to the conversion of input arguments
to C/C++.  The datatype <tt>int</tt> is the datatype to which the typemap
will be applied.  The supplied C code is used to convert values.  In this
code a number of special variable prefaced by a <tt>$</tt> are used.  The
<tt>$1</tt> variable is placeholder for a local variable of type <tt>int</tt>.
The <tt>$input</tt> variable is the input object of type <tt>PyObject *</tt>.

<p>
When this example is compiled into a Python module, it operates as follows:

<p>
<blockquote><pre>&gt;&gt;&gt; from example import *
&gt;&gt;&gt; fact(6)
Received an integer : 6
720
</pre></blockquote>
<p>

In this example, the typemap is applied to all occurrences of the <tt>int</tt> datatype.
You can refine this by supplying an optional parameter name.  For example:

<blockquote><pre>%module example

%typemap(in) int n {
	$1 = (int) PyLong_AsLong($input);
	printf("n = %d\n",$1);
}
extern int fact(int n);
</pre></blockquote>

In this case, the typemap code is only attached to arguments that exactly match <tt>int n</tt>.

<p>
The application of a typemap to specific datatypes and argument names involves
more than simple text-matching--typemaps are fully integrated into the
SWIG type-system.   When you define a typemap for <tt>int</tt>, that typemap
applies to <tt>int</tt> and qualified variations such as <tt>const int</tt>.  In addition,
the typemap system follows <tt>typedef</tt> declarations.  For example:

<blockquote>
<pre>
%typemap(in) int n {
	$1 = (int) PyLong_AsLong($input);
	printf("n = %d\n",$1);
}
typedef int Integer;
extern int fact(Integer n);    // Above typemap is applied
</pre>
</blockquote>

However, the matching of <tt>typedef</tt> only occurs in one direction.  If you
defined a typemap for <tt>Integer</tt>, it is not applied to arguments of
type <tt>int</tt>.

<p>
Typemaps can also be defined for groups of consecutive arguments.  For example:

<blockquote>
<pre>
%typemap(in) (char *str, int len) {
    $1 = PyString_AsString($input);
    $2 = PyString_Size($input);
};

int count(char c, char *str, int len);
</pre>
</blockquote>

When a multi-argument typemap is defined, the arguments are always handled as a single
Python object.  This allows the function to be used like this (notice how the length
parameter is ommitted):

<blockquote>
<pre>
>>> example.count('e','Hello World')
1
>>>
</pre>
</blockquote>

<h3>Python typemaps</h3>

The previous section illustrated an "in" typemap for converting Python objects to C.
A variety of different typemap methods are defined by the Python module.  For example,
to convert a C integer back into a Python object, you might define an "out" typemap
like this:

<blockquote>
<pre>
%typemap(out) int {
    $result = PyInt_FromLong((long) $1);
}
</pre>
</blockquote>

The following list details all of the typemap methods that can be used by the Python module:
<p>
<tt>%typemap(in)	</tt>
<blockquote>
Converts Python objects to input function arguments<p>
</blockquote>

<tt>%typemap(out)</tt>
<blockquote>
Converts return value of a C function to a Python object<p>
</blockquote>

<tt>%typemap(varin)</tt>
<blockquote>
Assigns a C global variable from a Python object<p>
</blockquote>

<tt>%typemap(varout)</tt>
<blockquote>
Returns a C global variable as a Python object<p>
</blockquote>

<tt>%typemap(freearg)</tt>
<blockquote>
Cleans up a function argument (if necessary)<p>
</blockquote>

<tt>%typemap(argout)</tt>
<blockquote>
Output argument processing<p>
</blockquote>

<tt>%typemap(ret)</tt>
<blockquote>
Cleanup of function return values<p>
</blockquote>

<tt>%typemap(consttab)</tt>
<blockquote>
Creation of Python constants (constant table)<p>
</blockquote>

<tt>%typemap(constcode)</tt> 
<blockquote>
Creation of Python constants (init function)
</blockquote>

<tt>%typemap(memberin)</tt>
<blockquote>
Setting of structure/class member data<p>
</blockquote>

<tt>%typemap(globalin)</tt>
<blockquote>
Setting of C global variables<p>
</blockquote>

<tt>%typemap(check)</tt>
<blockquote>
Checks function input values.<p>
</blockquote>

<tt>%typemap(default)</tt>
<blockquote>
Set a default value for an argument (making it optional).
</blockquote>

<tt>%typemap(ignore)</tt>
<blockquote>
Ignore an argument, but initialize its value.
</blockquote>

<tt>%typemap(arginit)</tt>
<blockquote>
Initialize an argument to a value before any conversions occur.
</blockquote>

Examples of these methods will appear shortly.

<h3> Typemap variables</h3>

Within typemap code, a number of special variables prefaced with a <tt>$</tt> may appear.
A full list of variables can be found in the "<a href="Typemaps.html">Typemaps</a>" chapter.
This is a list of the most common variables:

<p>
<tt>$1</tt>
<blockquote>
A C local variable corresponding to the actual type specified in the
<tt>%typemap</tt> directive.  For input values, this is a C local variable
that's supposed to hold an argument value.  For output values, this is
the raw result that's supposed to be returned to Python.
</blockquote>

<p>
<tt>$input</tt>
<blockquote>
 A <tt>PyObject *</tt> holding a raw Python object with an argument or variable value.
</blockquote>

<p>
<tt>$result</tt>
<blockquote>
A <tt>PyObject *</tt> that holds the result to be returned to Python.
</blockquote>
<p>

<tt>$1_name</tt>
<blockquote>
The parameter name that was matched. 
</blockquote>
<p>

<tt>$1_type</tt>
<blockquote>
The actual C datatype matched by the typemap.
</blockquote>
<p>

<tt>$1_ltype</tt>
<blockquote>
An assignable version of the datatype matched by the typemap (a type that can appear on the left-hand-side of
a C assignment operation).  This type is stripped of qualifiers and may be an altered version of <tt>$1_type</tt>.
All arguments and local variables in wrapper functions are declared using this type so that their values can be
properly assigned.
</blockquote>

<tt>$symname</tt>
<blockquote>
The Python name of the wrapper function being created.
</blockquote>

<h3> Useful Functions</h3>

When you write a typemap, you usually have to work directly with Python objects.
The following functions may prove to be useful.

<p>
<b>Python Integer Functions</b>

<blockquote>
<pre>
PyObject *PyInt_FromLong(long l);
long      PyInt_AsLong(PyObject *);
int       PyInt_Check(PyObject *);
</pre>
</blockquote>

<b>Python Floating Point Functions</b>

<blockquote>
<pre>
PyObject *PyFloat_FromDouble(double);
double    PyFloat_AsDouble(PyObject *);
int       PyFloat_Check(PyObject *);
</pre>
</blockquote>

<b>Python String Functions</b>

<blockquote>
<pre>
PyObject *PyString_FromString(char *);
PyObject *PyString_FromStringAndSize(char *, lint len);
int       PyString_Size(PyObject *);
char     *PyString_AsString(PyObject *);
int       PyString_Check(PyObject *);
</pre>
</blockquote>

<b>Python List Functions</b>

<blockquote>
<pre>
PyObject *PyList_New(int size);
int       PyList_Size(PyObject *list);
PyObject *PyList_GetItem(PyObject *list, int i);
int       PyList_SetItem(PyObject *list, int i, PyObject *item);
int       PyList_Insert(PyObject *list, int i, PyObject *item);
int       PyList_Append(PyObject *list, PyObject *item);
PyObject *PyList_GetSlice(PyObject *list, int i, int j);
int       PyList_SetSlice(PyObject *list, int i, int , PyObject *list2);
int       PyList_Sort(PyObject *list);
int       PyList_Reverse(PyObject *list);
PyObject *PyList_AsTuple(PyObject *list);
int       PyList_Check(PyObject *);
</pre>
</blockquote>

<b>Python Tuple Functions</b>

<blockquote>
<pre>
PyObject *PyTuple_New(int size);
int       PyTuple_Size(PyObject *);
PyObject *PyTuple_GetItem(PyObject *, int i);
int       PyTuple_SetItem(PyObject *, int i, pyObject *item);
PyObject *PyTuple_GetSlice(PyObject *t, int i, int j);
int       PyTuple_Check(PyObject *);
</pre>
</blockquote>

<b>Python Dictionary Functions</b>

<blockquote>
<pre>
write me
</pre>
</blockquote>

<b>Python File Conversion Functions</b>

<blockquote>
<pre>
PyObject *PyFile_FromFile(FILE *f);
FILE     *PyFile_AsFile(PyObject *);
int       PyFile_Check(PyObject *);
</pre>
</blockquote>

<b>Abstract Object Interface</b>

<blockquote>
<pre>
write me
</pre>
</blockquote>

<h2>Typemap Examples</h2>

This section includes a few examples of typemaps.  For more examples, you
might look at the files "<tt>python.swg</tt>" and "<tt>typemaps.i</tt>" in
the SWIG library.

<h3>Converting  Python list to a char ** </h3>

A common problem in many C programs is the processing of command line
arguments, which are usually passed in an array of NULL terminated
strings.  The following SWIG interface file allows a Python list
object to be used as a <tt>char **</tt> object.<p>

<p>
<blockquote><pre>%module argv

// This tells SWIG to treat char ** as a special case
%typemap(in) char ** {
  /* Check if is a list */
  if (PyList_Check($input)) {
    int size = PyList_Size($input);
    int i = 0;
    $1 = (char **) malloc((size+1)*sizeof(char *));
    for (i = 0; i &lt; size; i++) {
      PyObject *o = PyList_GetItem($input,i);
      if (PyString_Check(o))
	$1[i] = PyString_AsString(PyList_GetItem($input,i));
      else {
	PyErr_SetString(PyExc_TypeError,"list must contain strings");
	free($1);
	return NULL;
      }
    }
    $1[i] = 0;
  } else {
    PyErr_SetString(PyExc_TypeError,"not a list");
    return NULL;
  }
}

// This cleans up the char ** array we malloc'd before the function call
%typemap(freearg) char ** {
  free((char *) $1);
}

// Now a test function
%inline %{
int print_args(char **argv) {
    int i = 0;
    while (argv[i]) {
         printf("argv[%d] = %s\n", i,argv[i]);
         i++;
    }
    return i;
}
%}

</pre></blockquote>
When this module is compiled, the wrapped C function now operates as
follows :<p>

<p>
<blockquote><pre>&gt;&gt;&gt; from argv import *
&gt;&gt;&gt; print_args(["Dave","Mike","Mary","Jane","John"])
argv[0] = Dave
argv[1] = Mike
argv[2] = Mary
argv[3] = Jane
argv[4] = John
5
</pre></blockquote>

In the example, two different typemaps are used.  The "in" typemap is
used to receive an input argument and convert it to a C array.  Since dynamic
memory allocation is used to allocate memory for the array, the
"freearg" typemap is used to later release this memory after the execution of
the C function. 

<h3>Expanding a Python object to multiple arguments</h3>

Suppose that you had a collection of C functions with arguments
such as the following:

<blockquote>
<pre>
int foo(int argc, char **argv);
</pre>
</blockquote>

In the previous example, a typemap was written to pass a Python list as the <tt>char **argv</tt>.  This
allows the function to be used from Python as follows:

<blockquote>
<pre>
>>> foo(4, ["foo","bar","spam","1"])
</pre>
</blockquote>

Although this works, it's a little awkward to specify the argument count.  To fix this, a multi-argument
typemap can be defined.  This is not very difficult--you only have to make slight modifications to the
previous example:

<blockquote>
<pre>
%typemap(in) (int argc, char **argv) {
  /* Check if is a list */
  if (PyList_Check($input)) {
    int i;
    $1 = PyList_Size($input);
    $2 = (char **) malloc((size+1)*sizeof(char *));
    for (i = 0; i &lt; $1; i++) {
      PyObject *o = PyList_GetItem($input,i);
      if (PyString_Check(o))
	$2[i] = PyString_AsString(PyList_GetItem($input,i));
      else {
	PyErr_SetString(PyExc_TypeError,"list must contain strings");
	free($2);
	return NULL;
      }
    }
    $2[i] = 0;
  } else {
    PyErr_SetString(PyExc_TypeError,"not a list");
    return NULL;
  }
}

%typemap(freearg) (int argc, char **argv) {
  free((char *) $2);
}
</pre>
</blockquote>

When writing a multiple-argument typemap, each of the types is referenced by a variable such 
as <tt>$1</tt> or <tt>$2</tt>.   The typemap code simply fills in the appropriate values from
the supplied Python object.

<p>
With the above typemap in place, you will find it no longer necessary
to supply the argument count.  This is automatically set by the typemap code.  For example:

<blockquote>
<pre>
>>> foo(["foo","bar","spam","1"])
</pre>
</blockquote>

<h3> Using typemaps to return arguments</h3>

A common problem in some C programs is that values may be returned in
arguments rather than in the return value of a function.  For example
:<p>
<p>
<blockquote><pre>/* Returns a status value and two values in out1 and out2 */
int spam(double a, double b, double *out1, double *out2) {
	... Do a bunch of stuff ...
	*out1 = result1;
	*out2 = result2;
	return status;
};

</pre></blockquote>
A typemap can be used to handle this case as follows :<p>
<p>
<blockquote><pre>%module outarg

// This tells SWIG to treat an double * argument with name 'OutValue' as
// an output value.  We'll append the value to the current result which 
// is guaranteed to be a List object by SWIG.

%typemap(argout) double *OutValue {
    PyObject *o, *o2, *o3;
    o = PyFloat_FromDouble(*$1);
    if ((!$result) || ($result == Py_None)) {
        $result = o;
    } else {
        if (!PyTuple_Check($result)) {
            PyObject *o2 = $result;
            $result = PyTuple_New(1);
            PyTuple_SetItem(target,0,o2);
        }
        o3 = PyTuple_New(1);
        PyTuple_SetItem(o3,0,o);
        o2 = $result;
        $result = PySequence_Concat(o2,o3);
        Py_DECREF(o2);
        Py_DECREF(o3);
    }
}

int spam(double a, double b, double *OutValue, double *OutValue);

</pre></blockquote>

The typemap works as follows.  First, a check is made to see if any previous result
exists.  If so, it is turned into a tuple and the new output value is concatenated to it.
Otherwise, the result is returned normally.   For the sample function <tt>spam()</tt>, there
are three output values--meaning that the function will return a 3-tuple of the results.

<p>
As written, the function must accept 4 arguments as input values,
last two being pointers to doubles.  If these arguments are only used to hold output values (and have
no meaningful input value), an additional typemap can be written.  For example:

<blockquote><pre>
%typemap(ignore) double *OutValue(double temp) {
    $1 = &amp;temp;
}

</pre></blockquote>

The ignore typemap forces the input value to be ignored.  However, since the argument still has to be set to
some meaningful value before calling C, it is set to point to a local variable <tt>temp</tt>.  When the function
stores its output value, it will simply be placed in this local variable.  As a result, the
function can now be used as follows:

<p>
<blockquote><pre>&gt;&gt;&gt; a = spam(4,5)
&gt;&gt;&gt; print a
(0, 2.45, 5.0)
&gt;&gt;&gt; x,y,z = spam(4,5)
&gt;&gt;&gt;
</pre></blockquote>

<h3> Mapping Python tuples into small arrays</h3>

In some applications, it is sometimes desirable to pass small arrays
of numbers as arguments. For example :<p>

<p>
<blockquote><pre>extern void set_direction(double a[4]);       // Set direction vector
</pre></blockquote>
<p>
This too, can be handled used typemaps as follows :<p>
<p>
<blockquote><pre>// Grab a 4 element array as a Python 4-tuple
%typemap(in) double[4](double temp[4]) {   // temp[4] becomes a local variable
  int i;
  if (PyTuple_Check($input)) {
    if (!PyArg_ParseTuple($input,"dddd",temp,temp+1,temp+2,temp+3)) {
      PyErr_SetString(PyExc_TypeError,"tuple must have 4 elements");
      return NULL;
    }
    $1 = &amp;temp[0];
  } else {
    PyErr_SetString(PyExc_TypeError,"expected a tuple.");
    return NULL;
  }
}

</pre></blockquote>

This allows our <tt>set_direction</tt> function to be called from
Python as follows :<p>

<p>
<blockquote><pre>&gt;&gt;&gt; set_direction((0.5,0.0,1.0,-0.25))

</pre></blockquote>

Since our mapping copies the contents of a Python tuple into a C
array, such an approach would not be recommended for huge arrays, but
for small structures, this approach works fine.<p>

<h3>Mapping sequences to C arrays</h3>

Suppose that you wanted to generalize the previous example to handle C
arrays of different sizes.  To do this, you might write a typemap as follows:

<blockquote><pre>
// Map a Python sequence into any sized C double array
%typemap(in) double[ANY](double temp[$1_dim0]) {
  int i;
  if (!PySequence_Check($input)) {
      PyErr_SetString(PyExc_TypeError,"Expecting a sequence");
      return NULL;
  }
  if (PyObject_Length($input) != $1_dim0) {
      PyErr_SetString(PyExc_ValueError,"Expecting a sequence with $1_dim0 elements");
      return NULL;
  }
  for (i =0; i < $1_dim0; i++) {
      PyObject *o = PySequence_GetItem($input,i);
      if (!PyFloat_Check(o)) {
         PyErr_SetString(PyExc_ValueError,"Expecting a sequence of floats");
         return NULL;
      }
      temp[i] = PyFloat_AsDouble(o);
  }
  $1 = &temp[0];
}
</pre>
</blockquote>

In this case, the variable <tt>$1_dim0</tt> is expanded to match the
array dimensions actually used in the C code. This allows the typemap
to be applied to types such as:

<blockquote>
<pre>
void foo(double x[10]);
void bar(double a[4], double b[8]);
</pre>
</blockquote>

Since the above typemap code gets inserted into every wrapper function where used, it might make sense
to use a helper function instead.  This will greatly reduce the amount of wrapper code.  For example:

<blockquote>
<pre>
%{
static int convert_darray(PyObject *input, double *ptr, int size) {
  int i;
  if (!PySequence_Check(input)) {
      PyErr_SetString(PyExc_TypeError,"Expecting a sequence");
      return 0;
  }
  if (PyObject_Length(input) != size) {
      PyErr_SetString(PyExc_ValueError,"Sequence size mismatch");
      return 0;
  }
  for (i =0; i < size; i++) {
      PyObject *o = PySequence_GetItem(input,i);
      if (!PyFloat_Check(o)) {
         PyErr_SetString(PyExc_ValueError,"Expecting a sequence of floats");
         return 0;
      }
      ptr[i] = PyFloat_AsDouble(o);
  }
  return 1;
}
%}

%typemap(in) double [ANY](double temp[$1_dim0]) {
   if (!convert_darray($input,temp,$1_dim0))) {
      return NULL;
   }
   $1 = &temp[0];
}
</pre>
</blockquote>

<h3>Accessing array structure members</h3>

Consider the following data structure :<p>
<p>
<blockquote><pre>#define SIZE  8
typedef struct {
    int   values[SIZE];
    ...
} Foo;

</pre></blockquote>

By default, SWIG doesn't know how to the handle the values structure
member it's an array, not a pointer.  In this case, SWIG makes the array member
read-only.   Reading will simply return a pointer to the first item in the array.
To make the member writable, a "memberin" typemap can be used.

<p>
<blockquote><pre>%typemap(memberin) int [SIZE] {
    int i;
    for (i = 0; i < SIZE; i++) {
        $1[i] = $input[i];
    }
}

</pre></blockquote>

Whenever a <tt>int [SIZE]</tt> member is encountered in a structure
or class, this typemap provides a safe mechanism for setting its
value.  

<p>
As in the previous example, the typemap can be generalized for any dimension.
For example:

<blockquote><pre>%typemap(memberin) int [ANY] {
   int i;
   for (i = 0; i < $1_dim0; i++) {
      $1[i] = $input[i];
   }
}
</pre></blockquote>

When setting structure members, the input object is always assumed to
be a C array of values that have already been converted from the
target language.  Because of this, the <tt>memberin</tt> typemap is
almost always combined with the use of an "in" typemap.  For example,
the "in" typemap in the previous section would be used to convert an
<tt>int[]</tt> array to C whereas the "memberin" typemap would be used
to copy the converted array into a C data structure.

<h3> Pointer handling</h3>

Occasionally, it might be necessary to convert pointer values that have
been stored using the SWIG typed-pointer representation.  Since there are
several ways in which pointers can be represented, the following two
functions are used to safely perform this conversion:

<p>
<tt>
int SWIG_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags)</tt>

<p>
<blockquote>
Converts a Python object <tt>obj</tt> to a C pointer.  The result of the conversion is placed
into the pointer located at <tt>ptr</tt>.  <tt>ty</tt> is a SWIG type descriptor structure.
<tt>flags</tt> is used to handle error checking and other aspects of conversion.  If set, 
the function converts type-errors into a Python <tt>TypeError</tt> exception.  If set to zero, no Python exception
is raised.  Returns 0 on success and -1 on error.
</blockquote>

<p>
<tt>
PyObject *Swig_NewPointerObj(void *ptr, swig_type_info *ty, int own)</tt>
<p>

<blockquote>
Creates a new Python pointer object.  <tt>ptr</tt> is the pointer to convert, <tt>ty</tt> is the SWIG type descriptor structure that
describes the type, and <tt>own</tt> is a flag that indicates whether or not Python should take ownership of the
pointer.
</blockquote>

Both of these functions require the use of a special SWIG
type-descriptor structure.  This structure contains information about
the mangled name of the datatype, type-equivalence information, as
well as information about converting pointer values under C++
inheritance.   For a type of <tt>Foo *</tt>, the type descriptor structure
is usually accessed as follows:

<blockquote>
<pre>
Foo *f;
if (SWIG_ConvertPtr($input, (void **) &f, SWIGTYPE_p_Foo, 1) == -1) return NULL;

PyObject *obj;
obj = SWIG_NewPointerObj(f, SWIGTYPE_p_Foo, 0);
</pre>
</blockquote>

In a typemap, the type descriptor should always be accessed using the special typemap
variable <tt>$1_descriptor</tt>.  For example:

<blockquote>
<pre>
%typemap(in) Foo * {
   if ((SWIG_ConvertPtr($input,(void **) &$1, $1_descriptor,1)) == -1) return NULL;
}
</pre>
</blockquote>

<p>
If necessary, the descriptor for any type can be obtained using the <tt>$descriptor()</tt> macro in a typemap.
For example:

<blockquote>
<pre>
%typemap(in) Foo * {
   if ((SWIG_ConvertPtr($input,(void **) &$1, $descriptor(Foo *), 1)) == -1) return NULL;
}
</pre>
</blockquote>

Although the pointer handling functions are primarily intended for
manipulating low-level pointers, both functions are fully aware of
Python shadow classes (described shortly).  Specifically,
<tt>SWIG_ConvertPtr()</tt> will retrieve a pointer from any object
that has a <tt>this</tt> attribute.  In addition,
<tt>SWIG_NewPointerObj()</tt> can automatically generate a shadow
class object (if applicable).

<h2> Other odds and ends</h2>

<h3> Adding native Python functions to a SWIG module</h3>

Sometimes it is desirable to add a native Python method to a SWIG
wrapper file.  Suppose you have the following Python/C function :<p>

<p>
<blockquote><pre>PyObject *spam_system(PyObject *self, PyObject *args) {
	char *command;
	int sts;
	if (!PyArg_ParseTuple(args,"s",&amp;command))
		return NULL;
	sts = system(command);
	return Py_BuildValue("i",sts);
}

</pre></blockquote>

This function can be added to a SWIG module using the following
declaration :<p>

<p>
<blockquote><pre>%native(system) spam_system;        // Create a command called `system'

</pre></blockquote>
Alternatively, you can use the full function declaration like this <p>
<p>
<blockquote><pre>%native(system) PyObject *spam_system(PyObject *self, PyObject *args);
</pre></blockquote>
<p>
or<p>
<p>
<blockquote><pre>%native(system) extern PyObject *spam_system(PyObject *self, PyObject *args);
</pre></blockquote>

<h2>Python shadow classes</h2>

Using the low-level C interface, it is possible to create a Python
class that works like the original C++ class.  In this case, the
Python class is said to shadow the original C++ class.  It's really
just a wrapper around the C++ original class.

<h3> A simple example</h3>

One way to illustrate a shadow class is to write one by hand.  For example:

<p>
<blockquote><pre>
class List:
    def __init__(self):
        self.this = new_List()
    def __del__(self):
        delete_List(self.this)
    def search(self,item):
        return List_search(self.this,item)
    def insert(self,item):
        List_insert(self.this,item)
    def remove(self,item):
        List_remove(self.this,item)
    def get(self,n):
        return List_get(self.this,n)
    def __getattr__(self,name):
        if name == "length" : return List_length_get(self.this))
        else : return self.__dict__[name]
    def __setattr__(self,name,value):
        if name == "length": List_length_set(self.this,value)
        else : self.__dict__[name] = value
</pre></blockquote>
<p>
In the shadow class, a reference to the underlying C++ object is kept in the
<tt>.this</tt> attribute.  Methods are then written so that they pass the
<tt>.this</tt> attribute along with the other arguments to the low-level accessor
function created by SWIG.  This, in turn, allows the class to be used like this:
<blockquote><pre>

&gt;&gt;&gt; l = List()
&gt;&gt;&gt; l.insert("Ale")
&gt;&gt;&gt; l.insert("Stout")
&gt;&gt;&gt; l.insert("Lager")
&gt;&gt;&gt; List_print(l.this)
Lager
Stout
Ale
&gt;&gt;&gt; l.length
3
</pre></blockquote>
<p>

Clearly, this is a much nicer interface than before--and it only required a
small amount of Python coding.

<h3>Why shadow classes?</h3>

Shadow classes are not the only approach to wrapping C++ classes.  An alternative
approach would be to wrap classes as new Python types in C.  However, this requires
a substantial amount of complicated C wrapper code.  Furthermore, this approach makes
it difficult to correctly handle inheritance and other advanced language features.
Another more serious problem is that until recently, Python types created in C could
not be subclassed or used in the same way as you would use a real Python class.
As a result, C++ classes wrapped in this manner are crippled versions
of what you would obtain by writing a real class in Python.

<p>
Shadow classes allow C++ objects to be easily wrapped by a real Python
class.  This means that all of the normal features such as inheritance
work like you would expect.  The fact that such classes are written in
Python also simplifies coding since it is much easier to write a class
interface in Python than it is in C.   Such classes are also much
easier to modify since changes can be made without having to recompile
any of the low-level C extension code.   The main downside to this
approach is worse performance--a concern for some users.  

<h3> Automatic shadow class generation</h3>

SWIG can automatically generate shadow classes if you use the
<tt>-shadow</tt> option :<p>

<p>
<blockquote><pre>swig -python -shadow interface.i

</pre></blockquote>
This generates the usual wrapper file along with an extra file 
<tt>module.py</tt> that contains the Python shadow-class code.  The
name of this file is the same as specified by the <tt>%module</tt> directive.

<p>
Since the shadow class code needs to be placed in a different module
than the low-level C wrappers, the primitive interface is placed into
a Python extension module named <tt>modulec</tt> (a 'c' is appended to 
the module name).   When a user imports the module, the <tt>module.py</tt>
is loaded.   This file, in turn, imports the low-level C wrapper module
to gain access to the accessor functions.  For example, in the list example,
the shadow file might look roughly like this:

<blockquote>
<pre>
# example
import examplec

class List:
    def __init__(self):
        self.this = examplec.new_List()
    def __del__(self):
        examplec.delete_List(self.this)
    def search(self,item):
        return examplec.List_search(self.this,item)
    def insert(self,item):
        examplec.List_insert(self.this,item)
    def remove(self,item):
        examplec.List_remove(self.this,item)
    def get(self,n):
        return examplec.List_get(self.this,n)
    def __getattr__(self,name):
        if name == "length" : return examplec.List_length_get(self.this))
        else : return self.__dict__[name]
    def __setattr__(self,name,value):
        if name == "length": examplec.List_length_set(self.this,value)
        else : self.__dict__[name] = value
</blockquote>
</pre>

The choice of appending a 'c' to the module name is somewhat non-standard and may cause
a module name conflict in certain cases.  To fix this, you can run SWIG with the
<tt>-interface</tt> option to change the name of the C module file.  For example, this
places the low-level C interface into a module named <tt>_example</tt>:

<blockquote>
<pre>
$ swig -python -shadow -c++ -interface _example example.i
</pre>
</blockquote>

When shadow classes are used, most users don't notice the existence of the low-level
C accessors.  In fact, there is very little reason to use the low-level functions directly as shadow
classes provide all of the needed access.

<h3> Compiling modules with shadow classes</h3>

To compile a module involving shadow classes, you can use the same
procedure as before except that the module name now has an extra
`<tt>c</tt>' appended to the name. Thus, an interface file like this

<p>
<p>
<blockquote><pre>%module example
... a bunch of declarations ...

</pre></blockquote>
might be compiled as follows :<p>
<p>
<blockquote><pre>% swig -python -shadow example.i
% gcc -c example.c example_wrap.c -I/usr/local/include/python1.4 \
	-I/usr/local/lib/python1.4/config -DHAVE_CONFIG_H
% ld -shared example.o example_wrap.o -o examplecmodule.so

</pre></blockquote>

Notice the naming of `<tt>examplecmodule.so</tt>' as opposed to
`<tt>examplemodule.so</tt>' that would have been created without
shadow classes.<p>

<h3>Shadow classes and type-checking</h3>

Because shadow classes are used so frequently, the SWIG type-checker is
programmed to accept a raw-pointer or any object that contains a <tt>this</tt> attribute
(which is assumed to be a raw-pointer).   Thus, the earlier example can be simplified
as follows:

<blockquote>
<pre>
class List:
    def __init__(self):
        self.this = new_List()
    def __del__(self):
        delete_List(self)                  # Notice how self is passed instead of
    def search(self,item):                 # self.this
        return List_search(self,item)
    def insert(self,item):
        List_insert(self,item)
    def remove(self,item):
        List_remove(self,item)
    def get(self,n):
        return List_get(self,n)
    def __getattr__(self,name):
        if name == "length" : return List_length_get(self))
        else : return self.__dict__[name]
    def __setattr__(self,name,value):
        if name == "length": List_length_set(self,value)
        else : self.__dict__[name] = value
</pre>
</blockquote>

You can also observe this behavior of the type checker with a little experimentation. For example:

<blockquote>
<pre>
>>> import example
>>> a = example.new_List()
>>> a
'_90651008_p_List'
>>> example.List_insert(a,"Ale")
>>> class Blah: pass
...
>>> b = Blah()
>>> b.this = a
>>> example.List_insert(b,"Lager")
>>>                        
</pre>
</blockquote>

Further details of type-checking and shadow classes will be described later. Stay tuned.

<h3>A preview</h3>

Shadow classes are one of SWIG's most powerful features.  However, to better understand some of the
finer points, some other SWIG features need to first be described.  Therefore, we return to the
topic of shadow classes a little later in this chapter.

<h2> The gory details of shadow classes</h2>

This section describes the process by which SWIG creates shadow
classes and some of the more subtle aspects of using them.<p>

<h3> A simple shadow class</h3>

Consider the following declaration from our previous example :<p>

<p>
<blockquote><pre>%module pde
struct Grid2d {
  Grid2d(int ni, int nj);
  ~Grid2d();
  double **data;
  int      xpoints;
  int      ypoints;
};
</pre></blockquote>
<p>

The SWIG generated class for this structure looks like the following:<p>
<p>

<blockquote><pre># This file was created automatically by SWIG.
import pdec
class Grid2dPtr :
    def __init__(self,this):
        self.this = this
        self.thisown = 0
    def __del__(self):
        if self.thisown == 1 :
            pdec.delete_Grid2d(self.this)
    def __setattr__(self,name,value):
        if name == "data" :
            pdec.Grid2d_data_set(self.this,value)
            return
        if name == "xpoints" :
            pdec.Grid2d_xpoints_set(self.this,value)
            return
        if name == "ypoints" :
            pdec.Grid2d_ypoints_set(self.this,value)
            return
        self.__dict__[name] = value
    def __getattr__(self,name):
        if name == "data" : 
            return pdec.Grid2d_data_get(self.this)
        if name == "xpoints" : 
            return pdec.Grid2d_xpoints_get(self.this)
        if name == "ypoints" : 
            return pdec.Grid2d_ypoints_get(self.this)
        return self.__dict__[name]
    def __repr__(self):
        return "&lt;C Grid2d instance&gt;"
class Grid2d(Grid2dPtr):
    def __init__(self,arg0,arg1) :
        self.this = pdec.new_Grid2d(arg0,arg1)
        self.thisown = 1

</pre></blockquote>

<h3> Module names</h3>

Shadow classes are built using the low-level SWIG generated C
interface.  This interface is named "modulec" where "module" is the
name of the module specified in a SWIG interface file.  The Python
code for the shadow classes is created in a file "module.py".  This is
the file that should be loaded when a user wants to use the module.<p>

<h3> Two classes</h3>

For each structure or class found in an interface file, SWIG creates
two Python classes.  If a class is named "<tt>Grid2d</tt>", one of
these classes will be named "<tt>Grid2dPtr</tt>" and the other named
"<tt>Grid2d</tt>".  The <tt>Grid2dPtr</tt> class is used to turn wrap
a Python class around an already preexisting <tt>Grid2d</tt> pointer.
For example :<p>

<p>
<blockquote><pre>&gt;&gt;&gt; gptr = create_grid2d()         # Returns a Grid2d from somewhere
&gt;&gt;&gt; g = Grid2dPtr(gptr)            # Turn it into a Python class
&gt;&gt;&gt; g.xpoints
50
&gt;&gt;&gt;

</pre></blockquote>

The <tt>Grid2d</tt> class, on the other hand, is used when you want to
create a new <tt>Grid2d</tt> object from Python.  In reality, it
inherits all of the attributes of a <tt>Grid2dPtr</tt>, except that
its constructor calls the corresponding C++ constructor to create a
new object.  Thus, in Python, this would look something like the
following :<p>

<p>
<blockquote><pre>&gt;&gt;&gt; g = Grid2d(50,50)           # Create a new Grid2d
&gt;&gt;&gt; g.xpoints
50
&gt;&gt;&gt;

</pre></blockquote>

This two class model is a tradeoff.  In order to support C/C++
properly, it is necessary to be able to create Python objects from
both pre-existing C++ objects and to create entirely new C++ objects
in Python.  While this might be accomplished using a single class, it
would complicate the handling of constructors considerably.  The two
class model, on the other hand, works, is consistent, and is
relatively easy to use.  In practice, you probably won't even be aware
that there are two classes working behind the scenes.<p>

<h3> The this pointer</h3>

Within each shadow class, the member "<tt>this</tt>" contains the
actual C/C++ pointer to the object.  You can check this out yourself
by typing something like this :<p>

<p>
<blockquote><pre>&gt;&gt;&gt; g = Grid2d(50,50)
&gt;&gt;&gt; print g.this
_1008fe8_Grid2d_p
&gt;&gt;&gt;
</pre></blockquote>

<p>
Direct manipulation of the "<tt>this</tt>" pointer is generally
discouraged. In fact forget that you read this.<p>

<h3> Object ownership</h3>

Ownership is a critical issue when mixing C++ and Python.  For
example, suppose I create a new object in C++, but later use it to
create a Python object.  If that object is being used elsewhere in the
C++ code, we clearly don't want Python to delete the C++ object when
the Python object is deleted.  Similarly, what if I create a new
object in Python, but C++ saves a pointer to it and starts using it
repeatedly.  Clearly, we need some notion of who owns what.  Since
sorting out all of the possibilities is probably impossible, SWIG
shadow classes always have an attribute "<tt>thisown</tt>" that
indicates whether or not Python owns an object.  Whenever an object is
created in Python, Python will be given ownership by setting
<tt>thisown </tt> to <tt> 1</tt>.  When a Python class is created from
a pre-existing C/C++ pointer, ownership is assumed to belong to the
C/C++ code and <tt>thisown</tt> will be set to 0.<p>

<p>
Ownership of an object can be changed as necessary by changing the
value of <tt>thisown</tt>.  When set, Python will call the C/C++
destructor when the object is deleted.  If it is zero, Python will
never call the C/C++ destructor.<p>

<h3> Constructors and Destructors</h3>

C++ constructors and destructors will be mapped into Python's
<tt>__init__</tt> and <tt>__del__</tt> methods respectively.  Shadow
classes always contain these methods even if no constructors or
destructors were available in the SWIG interface file.  The Python
destructor will only call a C/C++ destructor if <tt>self.thisown</tt>
is set.<p>

<h3>Member data</h3>

Member data of an object is accessed through Python's
<tt>__getattr__</tt> and <tt>__setattr__</tt> methods.<p>

<h3> Printing</h3>

SWIG automatically creates a Python<tt> __repr__</tt> method for each
class.  This forces the class to be relatively well-behaved when
printing or being used interactively in the Python interpreter.<p>

<h3> Shadow Functions</h3>

Suppose you have the following declarations in an interface file :<p>
<p>
<blockquote><pre>%module vector
struct Vector {
	Vector();
	~Vector();
	double x,y,z;
};

Vector addv(Vector a, Vector b);

</pre></blockquote>
By default, the function <tt>addv</tt> will operate on <tt>Vector</tt>
pointers, not Python classes.  However, the SWIG Python module is
smart enough to know that <tt>Vector</tt> has been wrapped into a
Python class so it will create the following replacement for the
<tt>addv()</tt> function.<p>

<p>
<blockquote><pre>def addv(a,b):
	result = VectorPtr(vectorc.addv(a.this,b.this))
	result.thisown = 1
	return result

</pre></blockquote>
Function arguments are modified to use the "this" pointer of a Python
Vector object.  The result is a pointer to the result which has been
allocated by malloc or new (this behavior is described in the chapter
on SWIG basics), so we simply create a new VectorPtr with the return
value.  Since the result involved an implicit malloc, we set the
ownership to 1 indicating that the result is to be owned by Python and
that it should be deleted when the Python object is deleted.  As a
result, operations like this are perfectly legal and result in no
memory leaks :<p>

<p>
<blockquote><pre>&gt;&gt;&gt; v = add(add(add(add(a,b),c),d),e)

</pre></blockquote>
Substitution of complex datatypes occurs for all functions and member
functions involving structure or class definitions.  It is rarely
necessary to use the low-level C interface when working with shadow
classes.<p>

<h3> Nested objects</h3>

SWIG shadow classes support nesting of complex objects.  For example,
suppose you had the following interface file :<p>
<p>
<blockquote><pre>%module particle

typedef struct {
  Vector();
  double x,y,z;
} Vector;

typedef struct {
  Particle();
 ~Particle();
  Vector r;
  Vector v;
  Vector f;
  int    type;
} Particle;

</pre></blockquote>
<p>
In this case you will be able to access members as follows :<p>
<p>
<blockquote><pre>&gt;&gt;&gt; p = Particle()
&gt;&gt;&gt; p.r.x = 0.0
&gt;&gt;&gt; p.r.y = -1.5
&gt;&gt;&gt; p.r.z = 2.0
&gt;&gt;&gt; p.v = addv(v1,v2)
&gt;&gt;&gt; ...

</pre></blockquote>
Nesting of objects is implemented using Python's<tt> __setattr__</tt>
and <tt>__getattr__</tt> functions. In this case, they would look like
this :<p>
<p>
<blockquote><pre>class ParticlePtr:
	...
	def __getattr__(self,name):
		if name == "r":
			return particlec.VectorPtr(Particle_r_get(self.this))
		elif name == "v":
			return particlec.VectorPtr(Particle_v_get(self.this))
		...
	
	def __setattr__(self,name,value):
		if name == "r":
			particlec.Particle_r_set(self.this,value.this)
		elif name == "v":
			particlec.Particle_v_set(self.this,value.this)
		...

</pre></blockquote>
The attributes of any given object are only converted into a Python
object when referenced. This approach is more memory efficient, faster
if you have a large collection of objects that aren't examined very
often, and works with recursive structure definitions such as :<p>
<p>
<blockquote><pre>struct Node {
	char *name;
	struct Node *next;
};
</pre></blockquote>
<p>
Nested structures such as the following are also supported by
SWIG. These types of structures tend to arise frequently in database
and information processing applications.<p>
<p>
<blockquote><pre>typedef struct {  
	unsigned int dataType;
	union {
		int       intval;
		double    doubleval;
		char     *charval;
		void     *ptrvalue;
		long      longval;
		struct {
			int    i;
			double f;
			void   *v;
			char name[32];
              } v;
	} u;
} ValueStruct;

</pre></blockquote>
Access is provided in an entirely natural manner,<p>
<p>
<blockquote><pre>&gt;&gt;&gt; v = new_ValueStruct()       # Create a ValueStruct somehow
&gt;&gt;&gt; v.dataType
1
&gt;&gt;&gt; v.u.intval
45
&gt;&gt;&gt; v.u.longval
45
&gt;&gt;&gt; v.u.v.v = _0_void_p
&gt;&gt;&gt;

</pre></blockquote>
To support the embedded structure definitions, SWIG has to extract the
internal structure definitions and use them to create new Python
classes.  In this example, the following shadow classes are created
:<p>
<p>
<blockquote><pre># Class corresponding to union u member
class ValueStruct_u :
	...
# Class corresponding to struct v member of union u
class ValueStruct_u_v :
	...
</pre></blockquote>
<p>
The names of the new classes are formed by appending the member names
of each embedded structure.<p>

<h3> Inheritance and shadow classes</h3>

Since shadow classes are implemented in Python, you can use any of the
automatically generated classes as a base class for more Python
classes.  However, you need to be extremely careful when using
multiple inheritance.  When multiple inheritance is used, at most ONE
SWIG generated shadow class can be involved.  If multiple SWIG
generated classes are used in a multiple inheritance hierarchy, you
will get name clashes on the <tt>this</tt> pointer, the
<tt>__getattr__</tt> and <tt>__setattr__</tt> functions won't work
properly and the whole thing will probably crash and burn. Perhaps
it's best to think of multiple inheritance as a big hammer that can be
used to solve alot of problems, but it hurts quite alot if you
accidently drop it on your foot.... <p>

<h3> Methods that return new objects</h3>

By default SWIG assumes that constructors are the only functions
returning new objects to Python.  However, you may have other
functions that return new objects as well.  For example :<p>

<blockquote><pre>
Vector *cross_product(Vector *v1, Vector *v2) {
	Vector *result = new Vector();
	result = ... compute cross product ...
	return result;
}

</pre></blockquote>
When the value is returned to Python, we want Python to assume
ownership.  The brute force way to do this is to simply change the
value of thisown.  For example :<p>
<p>
<blockquote><pre>&gt;&gt;&gt; v = cross_product(a,b)
&gt;&gt;&gt; v.thisown = 1                        # Now Python owns it

</pre></blockquote>
Unfortunately, this is ugly and it doesn't work if we use the result
as a temporary value :<p>
<p>
<blockquote><pre>w = vector_add(cross_product(a,b),c)     # Results in a memory leak
</pre></blockquote>
<p>
However, you can provide a hint to SWIG when working with such a
function as shown :<p>
<p>
<blockquote><pre>// C Function returning a new object
%new Vector *cross_product(Vector *v1, Vector *v2);

</pre></blockquote>

The <tt>%new</tt> directive only provides a hint that the function is
returning a new object.  The Python module will assign proper
ownership of the object when this is used.<p>

<h3> Performance concerns and hints</h3>

Shadow classing is primarily intended to be a convenient way of
accessing C/C++ objects from Python.  However, if you're directly
manipulating huge arrays of complex objects from Python, performance
may suffer greatly.  In these cases, you should consider implementing
the functions in C or thinking of ways to optimize the problem.<p>
<p>
There are a number of ways to optimize programs that use shadow
classes.  Consider the following two code fragments involving the
<tt>Particle</tt> data structure in a previous example :<p>
<p>
<blockquote><pre>def force1(p1,p2):
	dx = p2.r.x - p1.r.x
	dy = p2.r.y - p1.r.y
	dz = p2.r.z - p1.r.z
	r2 = dx*dx + dy*dy + dz*dz
	f = 1.0/(r2*math.sqrt(r2))
	p1.f.x = p1.f.x + f*dx
	p2.f.x = p2.f.x - f*dx
	p1.f.y = p1.f.y + f*dy
	p2.f.y = p2.f.y - f*dy
	p1.f.z = p1.f.z + f*dz
	p2.f.z = p2.f.z - f*dz

def force2(p1,p2):
	r1 = p1.r
	r2 = p2.r
	dx = r2.x - r1.x
	dy = r2.y - r1.y
	dz = r2.z - r1.z
	r2 = dx*dx + dy*dy + dz*dz
	f = 1.0/(r2*math.sqrt(r2))
	f1 = p1.f
	f2 = p2.f
	f1.x = f1.x + f*dx
	f2.x = f2.x - f*dx
	f1.y = f1.y + f*dy
	f2.y = f2.y - f*dy
	f1.z = f1.z + f*dz
	f2.z = f2.z - f*dz

</pre></blockquote>
The first calculation simply works with each Particle structure
directly.  Unfortunately, it performs alot of dereferencing of
objects.  If the calculation is restructured to use temporary
variables as shown in force2, it will run significantly faster--in
fact, on my machine, the second code fragment runs more than twice as
fast as the first one.<p>
<p>
If performance is even more critical you can use the low-level C
interface which eliminates all of the overhead of going through
Python's class mechanism (at the expense of coding simplicity). When
Python shadow classes are used, the low level C interface can still be
used by importing the `modulec' module where `module' is the name of
the module you used in the SWIG interface file.<p>

<p><hr>

<address>SWIG 1.3 - Last Modified : January 27, 2002</address>
</body>
</html>
