<html>
<head>
<title>SWIG Library</title>
</head>

<body bgcolor="#ffffff">
<a name="n1"></a><H1>11 SWIG library</H1>

<!-- INDEX -->
<ul>
<li><a href="#n2">The %include directive and library search path</a>
<li><a href="#n3">C Arrays and Pointers</a>
<ul>
<li><a href="#n4">cpointer.i</a>
<li><a href="#n5">carrays.i</a>
<li><a href="#n6">cmalloc.i</a>
<li><a href="#n7">cdata.i</a>
</ul>
</ul>
<!-- INDEX -->








To help build extension modules, SWIG is packaged with a library of
support files that you can include in your own interfaces.  These
files often define new SWIG directives or provide utility
functions that can be used to access parts of the standard C and C++ libraries.
This chapter provides a reference to the current set of supported library files.

<p>
<b>Compatibility note:</b> Older versions of SWIG included a number of
library files for manipulating pointers, arrays, and other structures.  Most
these files are now deprecated and have been removed from the distribution.
Alternative libraries provide similar functionality.  Please read this chapter
carefully if you used the old libraries.

<a name="n2"></a><H2>11.1 The %include directive and library search path</H2>





Library files are included using the <tt>%include</tt> directive.
When searching for files, directories are searched in the following order:

<p>
<ul>
<li>The current directory
<li>Directories specified with the <tt>-I</tt> command line option
<li>.<tt>/swig_lib</tt>
<li><tt>/usr/local/lib/swig_lib</tt> (or wherever you installed SWIG)
<li>On Windows, SWIG also looks for the library relative to the location of <tt>swig.exe</tt>.
</ul>
<p>

Within each directory, SWIG first looks for a subdirectory corresponding to a target language (e.g., <tt>python</tt>,
<tt>tcl</tt>, etc.).   If found, SWIG will search the language specific directory first.  This allows 
for language-specific implementations of library files.
<p>
You can override the location of the SWIG library by setting the
<tt>SWIG_LIB</tt> environment variable.<p>

<a name="n3"></a><H2>11.2 C Arrays and Pointers</H2>





This section describes library modules for manipulating low-level C arrays and pointers. 
The primary use of these modules is in supporting C declarations that manipulate bare
pointers such as <tt>int *</tt>, <tt>double *</tt>, or <tt>void *</tt>.  The modules can be
used to allocate memory, manufacture pointers, dereference memory, and wrap
pointers as class-like objects.   Since these functions provide direct access to
memory, their use is potentially unsafe and you should exercise caution.

<a name="n4"></a><H3>11.2.1 cpointer.i</H3>





The <tt>cpointer.i</tt> module defines macros that can be used to used
to generate wrappers around simple C pointers.  The primary use of
this module is in generating pointers to primitive datatypes such as
<tt>int</tt> and <tt>double</tt>.

<p>
<b><tt>%pointer_functions(type,name)</tt></b>
<blockquote>
Generates a collection of four functions for manipulating a pointer <tt>type *</tt>:

<p>
<tt>type *new_name()</tt>
<blockquote>
Creates a new object of type <tt>type</tt> and returns a pointer to it.  In C, the
object is created using <tt>calloc()</tt>. In C++, <tt>new</tt> is used.
</blockquote>

<p>
<tt>type *delete_name(type *obj)</tt>
<blockquote>
Deletes an object type <tt>type</tt>.
</blockquote>

<p>
<tt>void name_assign(type *obj, type value)</tt>
<blockquote>
Assigns <tt>*obj = value</tt>.
</blockquote>

<p>
<tt>type name_value(type *obj)</tt>
<blockquote>
Returns the value of <tt>*obj</tt>.
</blockquote>
When using this macro, <tt>type</tt> may be any type and <tt>name</tt> must be a legal identifier in the target
language.  <tt>name</tt> should not correspond to any other name used in the interface file.
</blockquote>

Here is a simple example of using <tt>%pointer_functions()</tt>:

<blockquote>
<pre>
%module example
%include "cpointer.i"

/* Create some functions for working with "int *" */
%pointer_functions(int, intp);

/* A function that uses an "int *" */
void add(int x, int y, int *result);
</pre>
</blockquote>

Now, in Python:

<blockquote>
<pre>
>>> import example
>>> c = example.new_intp()     # Create an "int" for storing result
>>> example.add(3,4,c)         # Call function   
>>> example.intp_value(c)      # Dereference
7
>>> example.delete_intp(c)     # Delete
</pre>
</blockquote>

<p>
<p>
<b><tt>%pointer_class(type,name)</tt></b>
<blockquote>
Wraps a pointer of <tt>type *</tt> inside a class-based interface.  This
interface is as follows:

<blockquote>
<pre>
struct name {
   name();                            // Create pointer object
  ~name();                            // Delete pointer object
   void assign(type value);           // Assign value
   type value();                      // Get value
   type *cast();                      // Cast the pointer to original type.
   static name *frompointer(type *);  // Create class wrapper from existing pointer
};
</pre>
</blockquote>

When using this macro, <tt>type</tt> is restricted to a simple type
name like <tt>int</tt>, <tt>float</tt>, or <tt>Foo</tt>.  Pointers and
other complicated types are not allowed.  <tt>name</tt> must be a
valid identifier not already in use.  When a pointer is wrapped as a class,
the "class"  may be transparently passed to any function that expects the pointer.

<p>
If the target language does not support proxy classes, the use of this macro will produce the example
same functions as <tt>%pointer_functions()</tt> macro.

<p>
It should be noted that the class interface does introduce a new object or wrap a pointer inside a special
structure.  Instead, the raw pointer is used directly.

</blockquote>

Here is the same example using a class instead:

<blockquote>
<pre>
%module example
%include "cpointer.i"

/* Wrap a class interface around an "int *" */
%pointer_class(int, intp);

/* A function that uses an "int *" */
void add(int x, int y, int *result);
</pre>
</blockquote>

Now, in Python (using proxy classes)

<blockquote>
<pre>
>>> import example
>>> c = example.intp()         # Create an "int" for storing result
>>> example.add(3,4,c)         # Call function   
>>> c.value()                  # Dereference
7
</pre>
</blockquote>

Of the two macros, <tt>%pointer_class</tt> is probably the most convenient when working with simple
pointers.  This is because the pointers are access like objects and they can be easily garbage collected
(destruction of the pointer object destroys the underlying object).

<p>
<p>
<b><tt>%pointer_cast(type1, type2, name)</tt></b>
<blockquote>
Creates a casting function that converts <tt>type1</tt> to <tt>type2</tt>.  The name of the function is <tt>name</tt>.
For example:

<blockquote>
<pre>
%pointer_cast(int *, unsigned int *, int_to_uint);
</pre>
</blockquote>

In this example,  the function <tt>int_to_uint()</tt> would be used to cast types in the target language.

</blockquote>

<p>
<b>Note:</b> None of these macros can be used to safely work with strings (<tt>char *</tt> or <tt>char **</tt>).

<P>
<b>Note:</b> When working with simple pointers, typemaps can often be used to provide more seamless operation.

<a name="n5"></a><H3>11.2.2 carrays.i</H3>





This module defines macros that assist in wrapping ordinary C pointers as arrays.
The module does not provide any safety or an extra layer of wrapping--it merely
provides functionality for creating, destroying, and modifying the contents of
raw C array data.

<p>
<b><tt>%array_functions(type,name)</tt></b>
<blockquote>
Creates four functions.

<p>
<tt>type *new_name(int nelements)</tt>
<blockquote>
Creates a new array of objects of type <tt>type</tt>.   In C, the array is allocated using
<tt>calloc()</tt>.  In C++, <tt>new []</tt> is used.
</blockquote>

<p>
<tt>type *delete_name(type *ary)</tt>
<blockquote>
Deletes an array. In C, <tt>free()</tt> is used.  In C++, <tt>delete []</tt> is used.
</blockquote>

<p>
<tt>type name_getitem(type *ary, int index)</tt>
<blockquote>
Returns the value <tt>ary[index]</tt>.
</blockquote>

<p>
<tt>void name_setitem(type *ary, int index, type value)</tt>
<blockquote>
Assigns <tt>ary[index] = value</tt>.
</blockquote>
When using this macro, <tt>type</tt> may be any type and <tt>name</tt>
must be a legal identifier in the target language.  <tt>name</tt>
should not correspond to any other name used in the interface file.
</blockquote>

<p>
Here is an example of <tt>%array_functions()</tt>.  Suppose you had a 
function like this:

<blockquote>
<pre>
void print_array(double x[10]) {
   int i;
   for (i = 0; i < 10; i++) {
      printf("[%d] = %g\n", i, x[i]);
   }
}
</pre>
</blockquote>

To wrap it, you might write this:

<blockquote>
<pre>
%module example

%include "carrays.i"
%array_functions(double, doubleArray);

void print_array(double x[10]);
</pre>
</blockquote>

Now, in a scripting language, you might write this:

<blockquote>
<pre>
a = new_doubleArray(10)           # Create an array
for i in range(0,10):
    doubleArray_setitem(a,i,2*i)  # Set a value
print_array(a)                    # Pass to C
delete_doubleArray(a)             # Destroy array
</pre>
</blockquote>

<p>
<p>
<b><tt>%array_class(type,name)</tt></b>
<blockquote>
Wraps a pointer of <tt>type *</tt> inside a class-based interface.  This
interface is as follows:

<blockquote>
<pre>
struct name {
   name(int nelements);               // Create an array
  ~name();                            // Delete array
   type getitem(int index);           // Return item
   void setitem(index, type value);   // Set item
   type *cast();                      // Cast to original type
   static name *frompointer(type *);  // Create class wrapper from existing pointer
};
</pre>
</blockquote>

When using this macro, <tt>type</tt> is restricted to a simple type
name like <tt>int</tt> or <tt>float</tt>. Pointers and
other complicated types are not allowed.  <tt>name</tt> must be a
valid identifier not already in use.  When a pointer is wrapped as a class,
it can be transparently passed to any function that expects the pointer.

</blockquote>

<p>
When combined with proxy classes, the <tt>%array_class()</tt> macro can be especially useful. 
For example:

<blockquote>
<pre>
%module example
%include "carrays.i"
%array_class(double, doubleArray);

void print_array(double x[10]);
</pre>
</blockquote>

Allows you to do this:

<blockquote>
<pre>
import example
c = example.doubleArray(10)  # Create double[10]
for i in range(0,10):
    c[i] = 2*i               # Assign values
example.print_array(c)       # Pass to C
</pre>
</blockquote>

<p>
<b>Note:</b> These macros do not encapsulate C arrays inside a special data structure
or proxy. There is no bounds checking or safety of any kind.   If you want this,
you should consider using a special array object rather than a bare pointer.

<p>
<b>Note:</b> <tt>%array_functions()</tt> and <tt>%array_class()</tt> should not be
used with types of <tt>char</tt> or <tt>char *</tt>.

<a name="n6"></a><H3>11.2.3 cmalloc.i</H3>





This module defines macros for wrapping the low-level C memory allocation functions
<tt>malloc()</tt>, <tt>calloc()</tt>, <tt>realloc()</tt>, and <tt>free()</tt>.

<p>
<b><tt>%malloc(type [,name=type])</tt></b>
<blockquote>
Creates a wrapper around <tt>malloc()</tt> with the following prototype:
<blockquote><pre>
<em>type</em> *malloc_<em>name</em>(int nbytes = sizeof(<em>type</em>));
</pre>
</blockquote>
If <tt>type</tt> is <tt>void</tt>, then the size parameter <tt>nbytes</tt> is required.
The <tt>name</tt> parameter only needs to be specified when wrapping a type that
is not a valid identifier (e.g., "<tt>int *</tt>", "<tt>double **</tt>", etc.).
</blockquote>

<p>
<b><tt>%calloc(type [,name=type])</tt></b>
<blockquote>
Creates a wrapper around <tt>calloc()</tt> with the following prototype:
<blockquote><pre>
<em>type</em> *calloc_<em>name</em>(int nobj =1, int sz = sizeof(<em>type</em>));
</pre>
</blockquote>
If <tt>type</tt> is <tt>void</tt>, then the size parameter <tt>sz</tt> is required.
</blockquote>

<p>
<b><tt>%realloc(type [,name=type])</tt></b>
<blockquote>
Creates a wrapper around <tt>realloc()</tt> with the following prototype:
<blockquote><pre>
<em>type</em> *realloc_<em>name</em>(<em>type</em> *ptr, int nitems);
</pre>
</blockquote>
Note: unlike the C <tt>realloc()</tt>, the wrapper generated by this macro implicitly includes the
size of the corresponding type.   For example, <tt>realloc_int(p, 100)</tt> reallocates <tt>p</tt> so that
it holds 100 integers.
</blockquote>

<p>
<b><tt>%free(type [,name=type])</tt></b>
<blockquote>
Creates a wrapper around <tt>free()</tt> with the following prototype:
<blockquote><pre>
void free_<em>name</em>(<em>type</em> *ptr);
</pre>
</blockquote>
</blockquote>

<p>
<b><tt>%sizeof(type [,name=type])</tt></b>
<blockquote>
Creates the constant:
<blockquote><pre>
%constant int sizeof_<em>name</em> = sizeof(<em>type</em>);
</pre>
</blockquote>
</blockquote>

<p>
<b><tt>%allocators(type [,name=type])</tt></b>
<blockquote>
Generates wrappers for all five of the above operations.
</blockquote>

<p>
Here is a simple example that illustrates the use of these macros:

<blockquote>
<pre>
// SWIG interface
%module example
%include "cmalloc.i"

%malloc(int);
%free(int);

%malloc(int *, intp);
%free(int *, intp);

%allocators(double);
</pre>
</blockquote>

Now, in a script:

<blockquote>
<pre>
>>> from example import *
>>> a = malloc_int()
>>> a
'_000efa70_p_int'
>>> free_int(a)    
>>> b = malloc_intp()
>>> b
'_000efb20_p_p_int'
>>> free_intp(b)
>>> c = calloc_double(50)
>>> c
'_000fab98_p_double'
>>> c = realloc_double(100000)
>>> free_double(c)
>>> print sizeof_double
8
>>>
</pre>
</blockquote>

<a name="n7"></a><H3>11.2.4 cdata.i</H3>





The <tt>cdata.i</tt> module defines functions for converting raw C data to and from strings
in the target language.  The primary applications of this module would be packing/unpacking of 
binary data structures---for instance, if you needed to extract data from a buffer.
The target language must support strings with embedded binary data
in order for this to work.

<p>
<b><tt>char *cdata(void *ptr, int nbytes)</tt></b>
<blockquote>
Converts <tt>nbytes</tt> of data at <tt>ptr</tt> into a string.   <tt>ptr</tt> can be any 
pointer.
</blockquote>

<p>
<b><tt>void memmove(void *ptr, char *s)</tt></b>
<blockquote>
Copies all of the string data in <tt>s</tt> into the memory pointed to by 
<tt>ptr</tt>.  The string may contain embedded NULL bytes.  The length of 
the string is implicitly determined in the underlying wrapper code.
</blockquote>

One use of these functions is packing and unpacking data from memory. 
Here is a short example:

<blockquote>
<pre>
// SWIG interface
%module example
%include "carrays.i"
%include "cdata.i"

%array_class(int, intArray);
</pre>
</blockquote>

Python example:

<blockquote>
<pre>
>>> a = intArray(10)
>>> for i in range(0,10):
...    a[i] = i
>>> b = cdata(a,40)
>>> b
'\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x07\x00\x00\x00\x08\x00\x00\x00\t'
>>> c = intArray(10)
>>> memmove(c,b)
>>> print c[4]
4
>>> 
</pre>
</blockquote>

Since the size of data is not always known, the following macro is also defined:

<p>
<b><tt>%cdata(type [,name=type])</tt></b>
<blockquote>
Generates the following function for extracting C data for a given type.
<blockquote>
<pre>
char *cdata_<em>name</em>(int nitems)
</pre>
</blockquote>
<tt>nitems</tt> is the number of items of the given type to extract.
</blockquote>

<b>Note:</b> These functions provide direct access to memory and can be used to overwrite data.
Clearly they are unsafe.

<p><hr>
<address>SWIG 1.3 - Last Modified : May 22, 2002</address>
</body>
</html>