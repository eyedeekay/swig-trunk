<html>
<head>
<title>SWIG Library</title>
</head>

<body bgcolor="#ffffff">
<h1>SWIG library</h1>

To help build extension modules, SWIG is packaged with a library of
support files that you can include in your own interfaces.  These
support files often define new SWIG directives or provide utility
functions that can be used to access parts of the standard C and C++ libraries.
This chapter provides a reference to the current set of supported library files.

<h2>The %include directive and library search path</h2>

Library files are included using the <tt>%include</tt> directive.
When searching for files, directories are searched in the following order:

<p>
<ul>
<li>The current directory
<li>Directories specified with the -I command line option
<li>.<tt>/swig_lib</tt>
<li><tt>/usr/local/lib/swig_lib</tt> (or wherever you installed SWIG)
</ul>
<p>

Within each directory, SWIG first looks for a subdirectory corresponding to a target language (e.g., <tt>python</tt>,
<tt>tcl</tt>, etc.).   If found, SWIG will search the language specific directory first.  This allows 
for language-specific implementations of library files.
<p>
You can override the location of the SWIG library by setting the
<tt>SWIG_LIB</tt> environment variable.<p>

<h2>Arrays and Pointers</h2>

This section describes library modules for manipulating simple C arrays and pointers. 
<h3>cpointer.i</h3>

The <tt>cpointer.i</tt> module defines macros that can be used to used
to generate wrappers around simple C pointers.  The primary use of
this module is in generating pointers to primitive datatypes such as
<tt>int</tt> and <tt>double</tt>.

<p>
<b><tt>%pointer_functions(type,name)</tt></b>
<blockquote>
Generates a collection of four functions for manipulating a pointer <tt>type *</tt>:

<p>
<tt>type *new_name(type value = 0)</tt>
<blockquote>
Creates a new object of type <tt>type</tt>.   <tt>value</tt> is an optional default value.
</blockquote>

<p>
<tt>type *delete_name(type *obj)</tt>
<blockquote>
Deletes an object type <tt>type</tt>.
</blockquote>

<p>
<tt>void name_assign(type *obj, type value)</tt>
<blockquote>
Assigns <tt>*obj = value</tt>.
</blockquote>

<p>
<tt>type name_value(type *obj)</tt>
<blockquote>
Returns the value of <tt>*obj</tt>.
</blockquote>
When using this macro, <tt>type</tt> may be any type and <tt>name</tt> must be a legal identifier in the target
language.  <tt>name</tt> should not correspond to any other name used in the interface file.
</blockquote>

Here is a simple example of using <tt>%pointer_functions()</tt>:

<blockquote>
<pre>
%module example
%include "cpointer.i"

/* Create some functions for working with "int *" */
%pointer_functions(int, intp);

/* A function that uses an "int *" */
void add(int x, int y, int *result);
</pre>
</blockquote>

Now, in Python:

<blockquote>
<pre>
>>> import example
>>> c = example.new_intp()     # Create an "int" for storing result
>>> example.add(3,4,c)         # Call function   
>>> example.intp_value(c)      # Dereference
7
>>> example.delete_intp(c)     # Delete
</pre>
</blockquote>

<p>
<p>
<b><tt>%pointer_class(type,name)</tt></b>
<blockquote>
Encapsulates a pointer of <tt>type *</tt> inside a class-based interface.  This
interface is as follows:

<blockquote>
<pre>
struct name {
   name(type value = 0);         // Create pointer object
  ~name();                       // Delete pointer object
   void assign(type value);      // Assign value
   type value();                 // Get value
   type *cast();                 // Cast the pointer to original type.
};
</pre>
</blockquote>

When using this macro, <tt>type</tt> is restricted to a simple type
name like <tt>int</tt>, <tt>float</tt>, or <tt>Foo</tt>.  Pointers and
other complicated types are not allowed.  <tt>name</tt> must be a
valid identifier not already in use.  When a pointer is wrapped as a class,
the "class"  may be transparently passed to any functions that expects the pointer.

<p>
If the target language does not support proxy classes, the use of this macro will produce the example
same functions as <tt>%pointer_functions()</tt> macro.

<p>
It should be noted that the class interface does introduce a new object or wrap a pointer inside a special
structure.  Instead, the raw pointer is used directly.

</blockquote>

Here is the same example using a class instead:

<blockquote>
<pre>
%module example
%include "cpointer.i"

/* Wrap a class interface around an "int *" */
%pointer_class(int, intp);

/* A function that uses an "int *" */
void add(int x, int y, int *result);
</pre>
</blockquote>

Now, in Python (using proxy classes)

<blockquote>
<pre>
>>> import example
>>> c = example.intp()         # Create an "int" for storing result
>>> example.add(3,4,c)         # Call function   
>>> c.value()                  # Dereference
7
</pre>
</blockquote>

Of the two macros, <tt>%pointer_class</tt> is probably the most convenient when working with simple
pointers.  This is because the pointers are access like objects and they can be easily garbage collected
(destruction of the pointer object destroys the underlying object).

<p>
<p>
<b><tt>%pointer_cast(type1, type2, name)</tt></b>
<blockquote>
Creates a casting function that converts <tt>type1</tt> to <tt>type2</tt>.  The name of the function is <tt>name</tt>.
For example:

<blockquote>
<pre>
%pointer_cast(int *, unsigned int *, int_to_uint);
</pre>
</blockquote>

In this example,  the function <tt>int_to_uint()</tt> would be used to cast types in the target language.

</blockquote>

<p>
<b>Note:</b> None of these macros can be used to safely work with strings (<tt>char *</tt> or <tt>char **</tt>).

<P>
<b>Note:</b> When working with simple pointers, typemaps can often be used to provide more seamless operation.
<p><hr>
<address>SWIG 1.3 - Last Modified : May 22, 2002</address>
</body>
</html>


