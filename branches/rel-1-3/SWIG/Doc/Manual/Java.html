<html>
<head>
<title>SWIG and Java</title>
</head>
<body bgcolor="#FFFFFF">
<a name="n0"></a><h1>SWIG and Java</h1><p><ul>
<li> <a href="#n1">Introduction</a>
<li> <a href="#n2">Usage</a>
<li> <a href="#n3">Quick Introduction</a>
<li> <a href="#n4">Argument mapping</a>
<li> <a href="#n5">Typemaps</a>
<li> <a href="#n6">Pragmas</a>
<li> <a href="#n7">Shadow Classes and Garbage Collection</a>
<li> <a href="#n8">Dynamic Linking Problems</a>
<li> <a href="#n9">Tips</a>
<li> <a href="#n10">Caveats</a>
<li> <a href="#n11">Bugs</a>
</ul>

This chapter describes SWIG's support of Java. Java is one of the latest modules to be added to SWIG. The other SWIG modules are primarily scripting languages. Using Java has the advantage over scripting languages of being type safe.  The 100% Pure Java effort is a commendable concept however, in the real world programmers either need to re-use their existing code or in some situations want to take advantage of Java but are forced into using some native (C/C++) code.  With this Java extension to SWIG it is very easy to plumb in existing C/C++ code for access from Java, as SWIG writes the Java Native Interface (JNI) code for you. It is different to using the 'javah' tool as SWIG will wrap existing C/C++ code, whereas javah takes java functions and creates C/C++ function prototypes.

<a name="n1"></a><h2> Preliminaries</h2>
SWIG 1.1 works with JDK 1.1 and higher. Given the choice, you should use the latest version of Sun's JDK. The Java module requires your system to support shared libraries and dynamic loading. This is the commonly used method to load JNI code so your system is more than likely to support this.<p>
<a name="n14"></a><h3> Running SWIG</h3>
The basics of getting a SWIG Java module up and running is described and is loosely based on the example called simple that is shipped with SWIG. To build a Java module, run SWIG using the <tt>-java</tt> option. Enabling shadow classes <tt>-shadow</tt> is also recommended:<p>
<p>
<blockquote><pre>%swig -java -shadow example.i
</pre></blockquote>
<p>
This will produce 2 files. The file <tt>example_wrap.c</tt> contains all of the C code needed to build a Java module. To build a Java module, you will need to compile the file <tt>example_wrap.c</tt> to create a shared library. When shadow classes are enabled, SWIG may also produce many <tt>.java</tt> files, but this is described later.<p>

<a name="n2"></a><h3>Additional Commandline Options</h3>
The following table list the additional commandline options available for the Java module. They can also be seen by using: 
<blockquote><pre>swig -java -help 
</pre></blockquote>

<table>
<tr>
<th>Java specific options</th>
</tr>

<tr>
<td>-jnic</td>
<td> use c syntax for JNI calls (default depends on -c++ flag)</td>
</tr>

<tr>
<td>-jnicpp</td>
<td> use C++ syntax for JNI calls (default depends on -c++ flag)</td>
</tr>

<tr>
<td>-module &lt;module&gt;</td>
<td>set name of module</td>
</tr>

<tr>
<td>-package &lt;java package&gt;</td>
<td>set the name of the package for the generated classes</td>
</tr>

<tr>
<td>-shadow</td>
<td>generate shadow classes</td>
</tr>

<tr>
<td>-nofinalize</td>
<td>do not generate finalizer methods in shadow classes</td>
</tr>

</table>
<br>
Their use will become clearer by the time you have finished reading this section on SWIG and Java.

<a name="n15"></a><h3> Getting the right header files</h3>
In order to compile, you need to locate the "jni.h" and "md.h" header files which are part of the JDK. They are usually in directories like this:<p>
<p>
<blockquote><pre>
/usr/java/include
/usr/java/include/&lt;operating_system&gt;
</pre></blockquote>
<p>

The exact location may vary on your machine, but the above locations are typical. <p>
<a name="n16"></a><h3> Compiling a dynamic module</h3>
The JNI code exists in a dynamic module or shared object and gets loaded by the JVM. To build a shared object file, you need to compile your module in a manner similar to the following (shown for Solaris):<p>
<p>
<blockquote><pre>
$ swig -java -shadow example.i
$ gcc -c example_wrap.c  -I/usr/java/include -I/usr/java/include/solaris
$ ld -G example_wrap.o  -o libexample.so

</pre></blockquote>
Unfortunately, the process of building a shared object file varies on every single machine so you may need to read up on the man pages for your C compiler and linker.<p>
<p>
When building a dynamic module, the name of the output file is important. If the name of your SWIG module is "<tt>example</tt>", the name of the corresponding object file should be "<tt>libexample.so</tt>" (or equivalent depending on your machine, see <a href="#n8">Dynamic Linking Problems</a> for more information). The name of the module is specified using the <tt>%module</tt> directive or<tt> -module</tt> command line option.<p>
<p>

<a name="n18"></a><h3> Using your module</h3>
To use your module in Java, simply use Java's <tt>import</tt> command and <tt>System.loadLibrary</tt> method in a java class:<p>
<p>
<blockquote><pre>
// main.java
import example;

public class main {
  static {
    System.loadLibrary("example");
  }

  public static void main(String argv[]) {
    System.out.println(example.fact(4));
  }
}
</pre></blockquote>
Compile all the java files and run:

<blockquote><pre>
$ javac *.java
$ java main
24
$
</pre></blockquote>

<a name="n19"></a><h3> Compilation problems and compiling with C++</h3>
For the most part, compiling a Java module is straightforward, but there are a number of potential problems :<p>
<p>
<ul>
<li>In order to build C++ modules, you may need to link with the C++ compile using a command like `<tt>c++ -shared example_wrap.o example.o -o libexample.so</tt>'
<li>If building a dynamic C++ module using g++, you may also need to link against <tt>libgcc.a</tt>, <tt>libg++.a</tt>, and <tt>libstc++.a</tt> libraries.
<li>Make sure you are using the version of JDK header files matches the version of java that you are running.
</ul>

<a name="n2"></a><h2> Building Java Extensions under Windows 95/NT</h2>
Building a SWIG extension to Java under Windows 95/NT is roughly similar to the process used with Unix.  You will want to produce a DLL that can be loaded by the Java Virtual Machine.  This section covers the process of using SWIG with Microsoft Visual C++ 6 although the procedure may be similar with other compilers.  In order to build extensions, you will need to have a JDK installed on your machine in order to read the JNI header files.<p>
<a name="n20"></a><h3> Running SWIG from Developer Studio</h3>
If you are developing your application within Microsoft developer studio, SWIG can be invoked as a custom build option. The process roughly follows these steps:<p>
<p>
<ul>
<li>Open up a new workspace and use the AppWizard to select a DLL project.
<li>Add both the SWIG interface file (the .i file), any supporting C files, and the name of the wrapper file that will be created by SWIG (ie. <tt>example_wrap.c</tt>).   Note: If using C++, choose a different suffix for the wrapper file <tt>example_wrap.cxx</tt>. Don't worry if the wrapper file doesn't exist yet--Developer Studio will keep a reference to it.
<li>Select the SWIG interface file and go to the settings menu. Under settings, select the "Custom Build" option.
<li>Enter "SWIG" in the description field.
<li>Enter "<tt>swig -java -shadow -o $(ProjDir)\$(InputName)_wrap.c $(InputPath)</tt>" in the "Build command(s) field"
<li>Enter "<tt>$(ProjDir)\$(InputName)_wrap.c</tt>" in the "Output files(s) field".
<li>Next, select the settings for the entire project and go to C/C++ tab and select the Preprocessor category . Add the include directories to the JNI header files under "Additional include directories", eg "C:\jdk1.3\include,C:\jdk1.3\include\win32".
<li>Next, select the settings for the entire project and go to Link tab and select the General category. Set the name of the output file to match the name of your Java module (ie. example.dll).
<li>Next, select the example.c and example_wrap.c files and go to the C/C++ tab and select the Precompiled Headers tab in the project settings. Disabling precompiled headers for these files will overcome any precompiled header errors while building.
<li>Finally, add the java compilation as a post build rule in the Post-build step tab in project settings, eg, "c:\jdk1.3\bin\javac *.java" 
<li>Build your project.
</ul>
<p>
Now, assuming all went well, SWIG will be automatically invoked when you build your project.  When doing a build, any changes made to the interface file will result in SWIG being automatically invoked to produce a new version of the wrapper file.  The Java classes that SWIG output should also be compiled into .class files. To run the native code in the DLL (example.dll), make sure that it is in your path then run your java program which uses it, as described in the previous section. If the library fails to load have a look at <a href="#n8">Dynamic Linking Problems</a>.
<p>

<a name="n21"></a><h3> Using NMAKE</h3>
Alternatively, SWIG extensions can be built by writing a Makefile for NMAKE.   Make sure the environment variables for MSVC++ are available and the MSVC++ tools are in your path.   Now, just write a short Makefile like this :<p>
<p>
<blockquote><pre>
# Makefile for building a Java extension

SRCS          = example.c
IFILE         = example
INTERFACE     = $(IFILE).i
WRAPFILE      = $(IFILE)_wrap.c

# Location of the Visual C++ tools (32 bit assumed)

TOOLS         = c:\msdev
TARGET        = example.dll
CC            = $(TOOLS)\bin\cl.exe
LINK          = $(TOOLS)\bin\link.exe
INCLUDE32     = -I$(TOOLS)\include
MACHINE       = IX86

# C Library needed to build a DLL

DLLIBC        = msvcrt.lib oldnames.lib  

# Windows libraries that are apparently needed
WINLIB        = kernel32.lib advapi32.lib user32.lib gdi32.lib comdlg32.lib winspool.lib

# Libraries common to all DLLs
LIBS          = $(DLLIBC) $(WINLIB) 

# Linker options
LOPT      = -debug:full -debugtype:cv /NODEFAULTLIB /RELEASE /NOLOGO \
             /MACHINE:$(MACHINE) -entry:_DllMainCRTStartup@12 -dll

# C compiler flags

CFLAGS        = /Z7 /Od /c /nologo
JAVA_INCLUDE    = -ID:\jdk1.3\include -ID:\jdk1.3\include\win32

java::
	swig -java -shadow -o $(WRAPFILE) $(INTERFACE)
	$(CC) $(CFLAGS) $(JAVA_INCLUDE) $(SRCS) $(WRAPFILE)
	set LIB=$(TOOLS)\lib
	$(LINK) $(LOPT) -out:example.dll $(LIBS) example.obj example_wrap.obj
	javac *.java
</pre></blockquote>
<p>
To build the extension, run NMAKE (you may need to run <tt>vcvars32</tt> first). This is a pretty simplistic Makefile, but hopefully its enough to get you started.   <p>

<a name="n3"></a><h2> The low-level Java/C interface</h2>
The SWIG Java module is based upon a basic low-level interface that provides access to C functions, variables, constants, and C++ classes. This low-level interface is not the recommended way to use SWIG with Java; shadow classes are the recommended way. This low-level interface is used by the shadow class interface so it is used behind the scenes.<p>
<p>
<a name="n22"></a><h3> Modules</h3>
The SWIG <tt>%module</tt> directive specifies the name of the Java module. If you specified `<tt>%module example</tt>', then everything found in a SWIG interface file will be contained within the Java `<tt>example</tt>' module.  Make sure you don't use the same name as a Java keyword else the Java output will not compile.<p>
<a name="n23"></a><h3> Functions</h3>
C/C++ functions are mapped directly into a matching method in a Java class named after the module name. For example :<p>
<p>

<blockquote><pre>
%module example
extern int fact(int n);
</pre></blockquote>
Will produce the following JNI c function:
<blockquote><pre>
JNIEXPORT jint JNICALL Java_example_fact(JNIEnv *jenv, jclass jcls, jint jarg0) {
</pre></blockquote>
This will in turn call the desired <tt>fact</tt> function. The JNI naming mangling isn't pretty, but you can see from the above that the native function call is expecting a class 'example'. SWIG outputs the JNI Java code into the example class:
<blockquote><pre>
public class example  {
  public final static native int fact(int jarg0);
}
</pre></blockquote>

It can be used as follows from Java:<p>

<blockquote><pre>
System.out.println(example.fact(4));
</pre></blockquote>

<a name="n24"></a><h3> Variable Linking</h3>
SWIG provides access to C/C++ global variables through the class named after the module name, in other words all global variables are wrapped into the module class. Java does not allow the overriding of the dot operator so all variables are accessed through getters and setters. For example: <p>
<blockquote><pre>
/* SWIG interface file with global variables */
%module example
...
extern int My_variable;
...
</pre></blockquote>
<p>
Now in Java :<p>
<p>
<blockquote><pre>
// Print out the value of a c global variable
System.out.println("My Variable = " + example.get_My_variable());

//Set the value of a C global variable
example.set_My_variable(100);
</pre></blockquote>
The value returned by the getter will always be up to date even if the value is changed in c. The setter will not be generated if the variable is a c 'const'.<p>

<a name="n25"></a><h3> Constants</h3>
C/C++ constants (from a #define) are wrapped by public final static Java variables. These constants are given the same name as the corresponding C constant. For example, the following c:<p>
<blockquote><pre>
#define    ICONST      42
#define    FCONST      2.1828
#define    CCONST      'x'
#define    SCONST      "Hello World"
</pre></blockquote>
will be wrapped with the following Java:
<blockquote><pre>
public final static int ICONST = 42;
public final static double FCONST = 2.1828;
public final static String CCONST = "x";
public final static String SCONST = "Hello World";
</pre></blockquote>

<a name="n26"></a><h3> Pointers</h3>
All c pointers are treated as Java longs in the low-level interface. For example:<p>
<blockquote><pre>
int* pointer_fn(short* a, int* b, long* c);
</pre></blockquote>
will produce the following Java function:
<blockquote><pre>
public final static native long pointer_fn(long jarg0, long jarg1, long jarg2);
</pre></blockquote>
Unlike other language modules, no SWIG pointer library exists yet for the Java module. Until this is written it does restrict the functions that can be usefully used from Java. In the above <tt>pointer_fn</tt>, any long representing a c pointer can be passed to other c functions, but the value cannot be accessed from Java without writing some accessor functions and using them, for example:<p>
<blockquote><pre>
/* c accessor function for reading return values that are int pointers */
int getIntValue(int *ptr) {return *ptr;};

int* pointer_fn();
</pre></blockquote>
The return value can then be read from Java, for example:
<blockquote><pre>
long integerPtr = example.pointer_fn();
System.out.println("return value=" + example.getIntValue(integerPtr));
</pre></blockquote>

Pointers that are returned in one of the parameter arguments are more difficult and other workarounds are necessary. One method is to write a c function which returns the desired value after calling the appropriate function. However, as the section on shadow classes demonstrates, the situation is a lot better when using shadow classes.

<p>
<a name="n27"></a><h3> Structures </h3>
The low-level SWIG interface only provides a simple interface to C structures. For example :<p>
<p>
<blockquote><pre>struct Vector {
	double x,y,z;
};

</pre></blockquote>
This will be wrapped using native Java functions, where the first argument holds the pointer to an instance of the Vector struct. Example assuming the module name is 'example':
<blockquote><pre>
public class example  {
  public final static native void   set_Vector_x(long jarg0, double jarg1);
  public final static native double get_Vector_x(long jarg0);
  public final static native void   set_Vector_y(long jarg0, double jarg1);
  public final static native double get_Vector_y(long jarg0);
  public final static native void   set_Vector_z(long jarg0, double jarg1);
  public final static native double get_Vector_z(long jarg0);
}
</pre></blockquote>
These functions are then used in the resulting Java interface. For example:<p>
<p>
<blockquote><pre>
// v is a long holding the c pointer to a Vector that got created somehow
example.set_Vector_x(v, 7.8);
System.out.println("x=" + example.get_Vector_x(v));
</pre></blockquote>
When executed will display:<br>
<tt>x=7.8</tt>
<p>
Similar access is provided for unions and the data members of C++ classes.<p>
<a name="n28"></a><h3> C++ Classes</h3>
C++ classes are handled by building a set of low level accessor functions. Consider the following class :<p>
<p>
<blockquote><pre>class List {
public:
  List();
  ~List();
  int  search(char *item);
  void insert(char *item);
  void remove(char *item);
  char *get(int n);
  int  length;
  static void print(List *l);
};
</pre></blockquote>
<p>
When wrapped by SWIG, will produce the following JNI c code to access the class (assuming the module is set to 'example'):<p>
<p>
<blockquote><pre>
JNIEXPORT jlong JNICALL Java_example_new_1List(JNIEnv *jenv, jclass jcls);
JNIEXPORT void JNICALL Java_example_delete_1List(JNIEnv *jenv, jclass jcls, jlong jarg0);
JNIEXPORT jint JNICALL Java_example_List_1search(JNIEnv *jenv, jclass jcls, jlong jarg0, jstring jarg1);
JNIEXPORT void JNICALL Java_example_List_1insert(JNIEnv *jenv, jclass jcls, jlong jarg0, jstring jarg1);
JNIEXPORT void JNICALL Java_example_List_1remove(JNIEnv *jenv, jclass jcls, jlong jarg0, jstring jarg1);
JNIEXPORT jstring JNICALL Java_example_List_1get(JNIEnv *jenv, jclass jcls, jlong jarg0, jint jarg1);
JNIEXPORT void JNICALL Java_example_set_1List_1length(JNIEnv *jenv, jclass jcls, jlong jarg0, jint jarg1);
JNIEXPORT jint JNICALL Java_example_get_1List_1length(JNIEnv *jenv, jclass jcls, jlong jarg0);
JNIEXPORT void JNICALL Java_example_List_1print(JNIEnv *jenv, jclass jcls, jlong jarg0);
</pre></blockquote>
where jarg0 is the 'this' pointer in non-static functions. The JNI specification requires a c interface.

The following JNI Java functions are also produced for access from Java:
<blockquote><pre>
public class example  {
  public final static native long new_List();
  public final static native void delete_List(long jarg0);
  public final static native int List_search(long jarg0, String jarg1);
  public final static native void List_insert(long jarg0, String jarg1);
  public final static native void List_remove(long jarg0, String jarg1);
  public final static native String List_get(long jarg0, int jarg1);
  public final static native void List_length_set(long jarg0, int jarg1);
  public final static native int List_length_get(long jarg0);
  public final static native void List_print(long jarg0);
}
</pre></blockquote>

From Java, these functions can be used to access the C++ class:<p>
<blockquote><pre>
long l = example.new_List();
example.List_insert(l,"Ale");
example.List_insert(l,"Stout");
example.List_insert(l,"Lager");
example.List_print(l);
int len = example.get_List_length(l);
System.out.println(len);
</pre></blockquote>
When executed might display:<br><tt>
Lager<br>
Stout<br>
Ale<br>
3<br>
</tt>

</pre></blockquote>
While somewhat primitive, the low-level SWIG interface provides direct and flexible access to C++ objects. As it turns out, a more elegant method of accessing structures and classes is available using shadow classes.<p>

<a name="n4"></a><h2> Java shadow classes</h2>
The low-level interface generated by SWIG provides access to C structures and C++ classes, but it doesn't look much like a class that might be created in Java. However, it is possible to indirectly use the low-level C interface to write a Java class that looks like the original C++ class. In this case, the Java class is said to "shadow" the C++ class.  That is, it behaves like the original class, but is really just a wrapper around a C++ class. The Java class is sometimes called a proxy class.<p>
<a name="n29"></a><h3> A simple example</h3>
For our earlier List class, a Java shadow class could be written by hand like this :<p>
<p>
<blockquote><pre>
public class List {
  protected long _cPtr;
  protected boolean _cMemOwn;

  public long getCPtr() {
    return _cPtr;
  }

  public List() {
    _cPtr = example.new_List();
    _cMemOwn = true;
  }

  protected void finalize() {
    _delete();
  }

  public void _delete() {
    if(_cPtr!=0 && _cMemOwn) {
      example.delete_List(_cPtr);
      _cPtr = 0;
    }
  }

  public int search(String item) {
    return example.List_search(_cPtr, item);
  }

  public void insert(String item) {
    example.List_insert(_cPtr, item);
  }

  public void remove(String item) {
    example.List_remove(_cPtr, item);
  }

  public String get(int n) {
    return example.List_get(_cPtr, n);
  }

  public void setLength(int value) {
    example.set_List_length(_cPtr, value);
  }

  public int getLength() {
    return example.get_List_length(_cPtr);
  }

  public static void print(List l) {
    example.List_print(l.getCPtr());
  }

}
</pre></blockquote>
Which is roughly what SWIG outputs.
When used in Java, we can use the class as follows:<p>

<blockquote><pre>
List l = new List();
l.insert("Ale");
l.insert("Stout");
l.insert("Lager");
List.print(l);
int len = l.getLength();
System.out.println(len);
</pre></blockquote>

Obviously, this is a much nicer interface than before, it only required a small amount of Java coding, it is type-safe and fits in with the Java programming paradigm.<p>

<a name="n30"></a><h3> Why write shadow classes in Java?</h3>
While one could wrap C/C++ objects directly into Java as new Java types, this approach has a number of problems. First, as the C/C++ code gets complicated, the resulting wrapper code starts to become extremely ugly.<p>
<p>
By writing shadow classes in Java instead of C, the classes become real Java classes that can be used as base-classes in an inheritance hierarchy or for other applications. Writing the shadow classes in Java also greatly simplies coding complexity as writing in Java is much easier than trying to accomplish the same thing in C. Finally, by writing shadow classes in Java, they are easy to modify and can be changed without ever recompiling any of the C code. The downside to using shadow classes over the simple interface is a slight performance degradation--a concern for some users.<p>
<p>
<a name="n31"></a><h3> Automated shadow class generation</h3>
SWIG automatically generates shadow classes when you use the <tt>-shadow</tt> option:<p>
<p>
<blockquote><pre>swig -java -shadow interface.i

</pre></blockquote>
This will create the following files:<p>
<p>
<blockquote><pre>
interface_wrap.c
interface.java
<i>
plus other .java files corresponding to each shadow class
</i>
</pre></blockquote>

The file <tt>interface_wrap.c</tt> contains the normal SWIG C JNI wrappers. The file <tt>interface.java</tt> contains the Java code corresponding to the Java native functions. The name of this file will be the same as specified by the <tt>%module</tt> directive in the SWIG interface file. These two files are produced whether or not the -shadow option is passed to SWIG. There will then be a <tt>.java</tt> file for each shadow class when -shadow is used. Note that if -c++ is passed to SWIG for wrapping C++ code, then a <tt>interface_wrap.cxx</tt> file replaces the <tt>interface_wrap.c</tt> file.
<p>
<a name="n33"></a><h3> Shadow class limitations</h3>

<a name="n32"></a><h3> Compiling modules with shadow classes</h3>
No changes need to be made to the compilation process when using shadow classes.<p>

<a name="n33"></a><h3> Where to go for more information</h3>
Shadow classes turn out to be so useful that they are used almost all of the time with SWIG. All of the examples presented here will assume that shadow classes have been enabled. The precise implementation of shadow classes is described at the end of this chapter and is not necessary  to effectively use SWIG.<p>

<a name="n3"></a><h2>Examples</h2>

The directory Examples/java has a number of examples which is a good way to learn how the SWIG Java extension works. The Examples/index.html in the parent direcory constains the SWIG Examples Documentation and is a useful starting point.




<a name="n9"></a><h2> Exception handling </h2>
The SWIG <tt>%except</tt> directive can be used to create a user-definable exception handler which can be used to convert errors in your C/C++ program into Java exceptions.  The chapter on exception handling contains more details, but suppose you have a C++ class like the following:<p>
<blockquote><pre>
class RangeError {};   // Used for an exception

class DoubleArray {
  private:
    int n;
    double *ptr;
  public:
    // Create a new array of fixed size
    DoubleArray(int size) {
      ptr = new double[size];
      n = size;
    }
    // Destroy an array
    ~DoubleArray() {
       delete ptr;
    }
    // Return the length of the array
    int   length() {
      return n;
    }

    // Get an item from the array and perform bounds checking.
    double getitem(int i) {
      if ((i &gt;= 0) &amp;&amp; (i &lt; n))
        return ptr[i];
      else
        throw RangeError();
    }

    // Set an item in the array and perform bounds checking.
    void setitem(int i, double val) {
      if ((i &gt;= 0) &amp;&amp; (i &lt; n))
        ptr[i] = val;
      else {
        throw RangeError();
      }
    }
  };
</pre></blockquote>
<p>
The functions associated with this class can throw a C++ range exception for an out-of-bounds array access.   We can catch the C++ exception and rethrow it as a Java exception by specifying the following in an interface file :<p>
<p>
<blockquote><pre>
// Exception handler (intended for JNI calls that have a non void return)
%except(java) {
  try {
    $function
  }
  catch (RangeError) {
    jclass clazz = jenv-&gt;FindClass("java/lang/Exception");
    jenv-&gt;ThrowNew(clazz, "Range error");
    return NULL;
  }
}

// This overrides anything in the %except(java) typemap
// Used for JNI calls that return void
%typemap(java,except) void {
  try {
    $function
  }
  catch (RangeError) {
    jclass clazz = jenv-&gt;FindClass("java/lang/Exception");
    jenv-&gt;ThrowNew(clazz, "Range error");
    return;
  }
}
</pre></blockquote>

What the above does is define swig exception handlers for two types of functions; namely those that are have a void return and those that do not. Both are needed to cover all types of JNI functions. The code excerpts above are inserted into all the JNI functions. The $function call is expanded into the actual function call, for example the <tt>setitem</tt> call. Note that the above uses the C++ JNI calling syntax as opposed to the C calling syntax and so will not compile as C; the JCALL macro in java.swg could be used as a means to write for both C and C++ compilation. The ThrowNew() JNI function must take a class derived from java.lang.Exception. The %except typemap above could be tailored to individual needs.
<p>
When the C++ class throws a RangeError exception, our wrapper functions will catch it, turn it into a Java exception, and allow a graceful death as opposed to having some sort of mysterious JVM crash. Since SWIG's exception handling is user-definable, we are not limited to C++ exception handling. Please see the chapter on exception handling for more details and using the <tt>exception.i</tt> library for writing language-independent exception handlers.<p>
<p>
If we use the following code:

<blockquote><pre>
final int SIZE=5;
DoubleArray arr = new DoubleArray(SIZE);
for (int i=0; i&lt;SIZE; i++)
  arr.setitem(i, (double)i);
for (int i=0; i&lt;SIZE+1; i++) //Note the array over bounds
  System.out.println(i + " " + arr.getitem(i));
</pre></blockquote>

Something similar to the following will be output when it is run:
<blockquote><pre>
0 0.0
1 1.0
2 2.0
3 3.0
4 4.0
Exception in thread "main" java.lang.Exception: Range error
        at example.DoubleArray_getitem(Native Method)
        at example.DoubleArray_getitem(Compiled Code)
        at DoubleArray.getitem(Compiled Code)
        at main.main(Compiled Code)
</pre></blockquote>

<a name="n10"></a><h2> Remapping C datatypes with typemaps</h2>
This section describes how SWIG's treatment of various C/C++ datatypes can be remapped using the SWIG <tt>%typemap</tt> directive.   While not required, this section assumes some familiarity with the JNI. The reader is advised to consult JNI documentation online at <a href=http://java.sun.com>Sun's Java web site</a> or a book on the JNI. A glance at the chapter on SWIG typemaps will also be useful.  <p>
<a name="n54"></a><h3> What is a typemap?</h3>
A typemap is mechanism by which SWIG's processing of a particular C datatype can be overridden.   A simple typemap might look like this :<p>
<p>
<blockquote><pre>%module example

%typemap(java,in) int {
	$target = (int) PyLong_AsLong($source);
	printf("Received an integer : %d\n",$target);
}
extern int fact(int n);
</pre></blockquote>
<p>
Typemaps require a language  name,  method name, datatype, and conversion code.  For Java, "java" should be used as the language name. The "in" method in this example refers to an input argument of a function. The datatype `int' tells SWIG that we are remapping integers.  The supplied code is used to convert from a <tt>PyObject *</tt> to the corresponding C datatype.  Within the supporting C code, the variable <tt>$source</tt> contains the source data (the <tt>PyObject</tt> in this case) and <tt>$target</tt> contains the destination of a conversion.  <p>
<p>
When this example is compiled into a Java module, it will operate as follows :<p>
<p>
<blockquote><pre>&gt;&gt;&gt; from example import *
&gt;&gt;&gt; fact(6)
Received an integer : 6
720
</pre></blockquote>
<p>
A full discussion of typemaps can be found in the main SWIG users reference.  We will primarily be concerned with Java typemaps here.<p>
<a name="n55"></a><h3> Java typemaps</h3>
The following typemap methods are available to Java modules :<p>
<p>
<tt>%typemap(java,in)	</tt>Converts Java objects to input function arguments<p>
<tt>%typemap(java,out)</tt>	Converts return value of a C function to a Java object<p>
<tt>%typemap(java,varin)	</tt>Assigns a global variable from a Java object<p>
<tt>%typemap(java,varout)</tt>	Returns a global variable as a Java object<p>
<tt>%typemap(java,freearg)</tt>	Cleans up a function argument (if necessary)<p>
<tt>%typemap(java,argout)</tt>	Output argument processing<p>
<tt>%typemap(java,ret)</tt>	Cleanup of function return values<p>
<tt>%typemap(java,const)</tt>	Creation of Java constants<p>
<tt>%typemap(memberin)</tt>	Setting of C++ member data<p>
<tt>%typemap(memberout)</tt>	Return of C++ member data<p>
<tt>%typemap(java,check)</tt>	Checks function input values.<p>
<a name="n56"></a><h3> Typemap variables</h3>
The following variables may be used within the C code used in a typemap:<p>
<p>
<tt>$source</tt>	Source value of a conversion<p>
<tt>$target</tt>	Target of conversion (where the result should be stored)<p>
<tt>$type</tt>	C datatype being remapped<p>
<tt>$mangle</tt>	Mangled version of data (used for pointer type-checking)<p>
<tt>$value</tt>	Value of a constant (const typemap only)<p>
<a name="n57"></a><h3> Name based type conversion</h3>
Typemaps are based both on the datatype and an optional name attached to a datatype.   For example :<p>
<p>
<blockquote><pre>%module foo

// This typemap will be applied to all char ** function arguments
%typemap(java,in) char ** { ... }

// This typemap is applied only to char ** arguments named `argv'
%typemap(java,in) char **argv { ... }

</pre></blockquote>
In this example, two typemaps are applied to the <tt>char **</tt> datatype.  However, the second typemap will only be applied to arguments named `<tt>argv</tt>'.  A named typemap will always override an unnamed typemap.<p>
<p>
Due to the name-based nature of typemaps, it is important to note that typemaps are independent of typedef declarations.  For example :<p>
<p>
<blockquote><pre>%typemap(java, in) double {
	... get a double ...
}
void foo(double);            // Uses the above typemap
typedef double Real;
void bar(Real);              // Does not use the above typemap (double != Real)

</pre></blockquote>
To get around this problem, the <tt>%apply</tt> directive can be used as follows :<p>
<blockquote><pre>
%typemap(java,in) double {
	... get a double ...
}
void foo(double);

typedef double Real;         // Uses typemap
%apply double { Real };      // Applies all "double" typemaps to Real.
void bar(Real);              // Now uses the same typemap.
</pre></blockquote>
<a name="n58"></a><h3> Converting  Java list to a char ** </h3>
A common problem in many C programs is the processing of command line arguments, which are usually passed in an array of NULL terminated strings.   The following SWIG interface file allows a Java list object to be used as a <tt>char **</tt> object.<p>
<p>
<blockquote><pre>%module argv

// This tells SWIG to treat char ** as a special case
%typemap(java,in) char ** {
  /* Check if is a list */
  if (PyList_Check($source)) {
    int size = PyList_Size($source);
    int i = 0;
    $target = (char **) malloc((size+1)*sizeof(char *));
    for (i = 0; i &lt; size; i++) {
      PyObject *o = PyList_GetItem($source,i);
      if (PyString_Check(o))
	$target[i] = PyString_AsString(PyList_GetItem($source,i));
      else {
	PyErr_SetString(PyExc_TypeError,"list must contain strings");
	free($target);
	return NULL;
      }
    }
    $target[i] = 0;
  } else {
    PyErr_SetString(PyExc_TypeError,"not a list");
    return NULL;
  }
}

// This cleans up the char ** array we malloc'd before the function call
%typemap(java,freearg) char ** {
  free((char *) $source);
}

// This allows a C function to return a char ** as a Java list
%typemap(java,out) char ** {
  int len,i;
  len = 0;
  while ($source[len]) len++;
  $target = PyList_New(len);
  for (i = 0; i &lt; len; i++) {
    PyList_SetItem($target,i,PyString_FromString($source[i]));
  }
}

// Now a few test functions
%inline %{
int print_args(char **argv) {
    int i = 0;
    while (argv[i]) {
         printf("argv[%d] = %s\n", i,argv[i]);
         i++;
    }
    return i;
}

// Returns a char ** list 

char **get_args() {
    static char *values[] = { "Dave", "Mike", "Susan", "John", "Michelle", 0};
    return &amp;values[0];
}
%}

</pre></blockquote>
When this module is compiled, our wrapped C functions now operate as follows :<p>
<p>
<blockquote><pre>&gt;&gt;&gt; from argv import *
&gt;&gt;&gt; print_args(["Dave","Mike","Mary","Jane","John"])
argv[0] = Dave
argv[1] = Mike
argv[2] = Mary
argv[3] = Jane
argv[4] = John
5
&gt;&gt;&gt; get_args()
[`Dave', `Mike', `Susan', `John', `Michelle']
&gt;&gt;&gt;

</pre></blockquote>
Our type-mapping makes the Java interface to these functions more natural and easy to use.     <p>
<a name="n59"></a><h3> Converting a Java file object to a FILE *</h3>
In our previous example involving gd-1.2, we had to write wrappers around <tt>fopen()</tt> and <tt>fclose()</tt> so that we could provide gd with a <tt>FILE *</tt> pointer.  However, we could have used a typemap like this instead :<p>
<p>
<blockquote><pre>// Type mapping for grabbing a FILE * from Java

%typemap(java,in) FILE * {
  if (!PyFile_Check($source)) {
      PyErr_SetString(PyExc_TypeError, "Need a file!");
      return NULL;
  }
  $target = PyFile_AsFile($source);
}
</pre></blockquote>
<p>
Now, we can rewrite one of our earlier examples like this :<p>
<p>
<blockquote><pre># Simple gd program

from gd import *

im = gdImageCreate(64,64)
black = gdImageColorAllocate(im,0,0,0)
white = gdImageColorAllocate(im,255,255,255)
gdImageLine(im,0,0,63,63,white)
f = open("test.gif","w")               # Create a Java file object
gdImageGif(im,f)                       # Pass to a C function as FILE *
f.close()
gdImageDestroy(im)
</pre></blockquote>
<a name="n60"></a><h3> Using typemaps to return arguments</h3>
A common problem in some C programs is that values may be returned in arguments rather than in the return value of a function.  For example :<p>
<p>
<blockquote><pre>/* Returns a status value and two values in out1 and out2 */
int spam(double a, double b, double *out1, double *out2) {
	... Do a bunch of stuff ...
	*out1 = result1;
	*out2 = result2;
	return status;
};

</pre></blockquote>
A named typemap can be used to handle this case as follows :<p>
<p>
<blockquote><pre>%module outarg

// This tells SWIG to treat an double * argument with name 'OutValue' as
// an output value.  We'll append the value to the current result which 
// is guaranteed to be a List object by SWIG.

%typemap(java,argout) double *OutValue {
	PyObject *o;
	o = PyFloat_FromDouble(*$source);
	if ((!$target) || ($target == Py_None)) {
		$target = o;
	} else {
		if (!PyList_Check($target)) {
			PyObject *o2 = $target;
			$target = PyList_New(0);
			PyList_Append($target,o2);
			Py_XDECREF(o2);
		}
		PyList_Append($target,o);
		Py_XDECREF(o);
	}
}
int spam(double a, double b, double *OutValue, double *OutValue);

</pre></blockquote>
With this typemap, we first check to see if any result exists.  If so, we turn it into a list and append our new output value to it.   If this is the only result, we simply return it normally. For our sample function, there are three output values so the function will return a list of 3 elements.   As written, our function needs to take 4 arguments, the last two being pointers to doubles.   We may not want to pass anything into these arguments if they are only used to hold output values so we could change this as follows :<p>
<blockquote><pre>
%typemap(java,ignore) double *OutValue(double temp) {
	$target = &amp;temp;       /* Assign the pointer to a local variable */
}

</pre></blockquote>
Now, in a Java script,  we could do this :<p>
<p>
<blockquote><pre>&gt;&gt;&gt; a = spam(4,5)
&gt;&gt;&gt; print a
[0, 2.45, 5.0]
&gt;&gt;&gt;
</pre></blockquote>
<a name="n61"></a><h3> Mapping Java tuples into small arrays</h3>
In some applications, it is sometimes desirable to pass small arrays of numbers as arguments. For example :<p>
<p>
<blockquote><pre>extern void set_direction(double a[4]);       // Set direction vector
</pre></blockquote>
<p>
This too, can be handled used typemaps as follows :<p>
<p>
<blockquote><pre>// Grab a 4 element array as a Java 4-tuple
%typemap(java,in) double[4](double temp[4]) {   // temp[4] becomes a local variable
  int i;
  if (PyTuple_Check($source)) {
    if (!PyArg_ParseTuple($source,"dddd",temp,temp+1,temp+2,temp+3)) {
      PyErr_SetString(PyExc_TypeError,"tuple must have 4 elements");
      return NULL;
    }
    $target = &amp;temp[0];
  } else {
    PyErr_SetString(PyExc_TypeError,"expected a tuple.");
    return NULL;
  }
}

</pre></blockquote>
This allows our <tt>set_direction</tt> function to be called from Java as follows :<p>
<p>
<blockquote><pre>&gt;&gt;&gt; set_direction((0.5,0.0,1.0,-0.25))

</pre></blockquote>
Since our mapping copies the contents of a Java tuple into a C array, such an approach would not be recommended for huge arrays, but for small structures, this kind of scheme works fine.<p>
<a name="n62"></a><h3> Accessing array structure members</h3>
Consider the following data structure :<p>
<p>
<blockquote><pre>#define NAMELEN   32
typedef struct {
	char   name[NAMELEN];
	...
} Person;

</pre></blockquote>
By default, SWIG doesn't know how to the handle the name structure since it's an array, not a pointer.  In this case, SWIG will make the array member readonly.    However, member typemaps can be used to make this member writable from Java as follows :<p>
<p>
<blockquote><pre>%typemap(memberin) char[NAMELEN] {
	/* Copy at most NAMELEN characters into $target */
	strncpy($target,$source,NAMELEN);
}

</pre></blockquote>
Whenever a <tt>char[NAMELEN]</tt> type is encountered in a structure or class, this typemap provides a safe mechanism for setting its value.   An alternative implementation might choose to print an error message if the name was too long to fit into the field.<p>
<p>
It should be noted that the <tt>[NAMELEN]</tt> array size is attached to the typemap. A datatype involving some other kind of array would not be affected.   However, you can write a typemap to match any sized array using the <tt>ANY</tt> keyword as follows :<p>
<p>
<blockquote><pre>%typemap(memberin) char [ANY] {
	strncpy($target,$source,$dim0);
}
</pre></blockquote>
<p>
During code generation, <tt>$dim0</tt> will be filled in with the real array dimension.  <p>
<a name="n63"></a><h3> Useful Functions</h3>
When writing typemaps, it is often necessary to work directly with Java objects instead of using the conventional <tt>PyArg_ParseTuple()</tt> function that is usually used when writing Java extensions.   However, there are a number of useful Java functions available for you to use.<p>
<center>
<img src="ch9.table.2.png"><br>
<img src="ch9.table.3.png"><br>
<img src="ch9.table.4.png"><br>
<img src="ch9.table.5.png"><br>
<img src="ch9.table.6.png"><br>
<img src="ch9.table.7.png"><br>
</center><p>
<p>
<a name="n64"></a><h3> Standard  typemaps</h3>
The following typemaps show how to convert a few common kinds of objects between Java and C (and to give a better idea of how typemaps work)<p>
<center>
<img src="ch9.table.8.png"><br>
<img src="ch9.table.9.png"><br>
</center><p>
<p>
<a name="n65"></a><h3> Pointer handling</h3>
SWIG pointers are mapped into Java strings containing the hexadecimal value and type.  The following functions can be used to create and read pointer values.<p>
<center>
<img src="ch9.table.10.png">
</center><p>
<p>
These functions can be used in typemaps. For example, the following typemap makes an argument of "<tt>char *buffer</tt>" accept a pointer instead of a NULL-terminated ASCII string.<p>
<p>
<blockquote><pre>%typemap(java,in) char *buffer {
	PyObject *o;
	char     *str;
	if (!PyString_Check(o)) {
		PyErr_SetString(PyExc_TypeError,"not a string");
		return NULL;
	}
	str = PyString_AsString(o);
	if (SWIG_GetPtr(str, (void **) &amp;$target, "$mangle")) {
		PyErr_SetString(PyExc_TypeError,"not a pointer");
		return NULL;
	}
}

</pre></blockquote>
Note that the <tt>$mangle</tt> variable generates the type string associated with the datatype used in the typemap.<p>
<p>
By now you hopefully have the idea that typemaps are a powerful mechanism for building more specialized applications.  While writing typemaps can be technical, many have already been written for you.  See the Typemaps chapter for more information about using library files.<p>





<a name="n4"></a><h2>Argument mapping</h2>
&nbsp;
<table BORDER>
<tr>
<td><b>c type</b></td>
<td><b>Java type</b></td>
<td><b>JNI type</b></td>
</tr>

<tr>
<td>char</td>
<td>byte</td>
<td>jbyte</td>
</tr>

<tr>
<td>unsigned char</td>
<td>short</td>
<td>jshort</td>
</tr>

<tr>
<td>short</td>
<td>short</td>
<td>jshort</td>
</tr>

<tr>
<td>unsigned short</td>
<td>int</td>
<td>jint</td>
</tr>

<tr>
<td>int</td>
<td>int</td>
<td>jint</td>
</tr>

<tr>
<td>unsigned int</td>
<td>long</td>
<td>jlong</td>
</tr>

<tr>
<td>long</td>
<td>long</td>
<td>jlong</td>
</tr>

<tr>
<td>long</td>
<td>long</td>
<td>jlong</td>
</tr>

<tr>
<td>float</td>
<td>float</td>
<td>jfloat</td>
</tr>

<tr>
<td>double</td>
<td>double</td>
<td>jdouble</td>
</tr>

<tr>
<td>bool</td>
<td>int</td>
<td>jint</td>
</tr>

<tr>
<td>void</td>
<td>void</td>
<td>void</td>
</tr>

</table>
<br>
Arrays are implemented using the same mappings, for example a c array, char[size], is mapped to a Java array, byte[size].
<br><br>
When SWIG is being used without shadow classes, longs are used for all pointers. All complex types (C/C++ structs and classes) are accessible using a Java long which contains a pointer to the underlying C/C++ object. Arrays of complex types are mapped as arrays of pointers to the type, that is a Java long[].
<br><br>
The output is different when SWIG is being used to generate shadow classes. Primitive types and pointers to these types remain the same; so a Java long is used for pointers to primitive types. However, for complex types, the shadow classes use a Java class which wraps the struct/class instead of a Java long. This applies to both argument parameters and return types that are complex types or pointers to complex types. Arrays of complex types turn into arrays of Java classes rather than arrays of longs.
<br><br>
For example, given the following C++ function call:
<blockquote> <pre>
void AClass::func(int a, int* b, SomeClass c, SomeClass* d, SomeClass& e, SomeClass f[10]);
</blockquote> </pre>
The non shadow access from Java is shown below, where the first parameter, ptr, is a long containing the pointer to an object of type AClass:
<blockquote> <pre>
public final static native void AClass_func(long ptr, int a, long b, long c, long d, long e, long[] f);
</blockquote> </pre>
The Java shadow class, AClass, will contain the following function:
<blockquote> <pre>
public void func(int a, long b, SomeClass c, SomeClass d, SomeClass e, SomeClass f[]) {...}
</blockquote> </pre>

Also note that SWIG converts C/C++ enums into integers.
<br>
<a name="n5"></a><h2>Typemaps</h2>
With typemaps, you can change the default conversion (input, output and
return value) for a specific type.
<p>The following typemaps are supported.
<br>&nbsp;
<table BORDER>
<tr>
<td><b>typemap</b></td>

<td><b>description</b></td>
</tr>

<tr>
<td>typemap(java,in)</td>

<td>Converts function arguments from the java representation to a C representation.</td>
</tr>

<tr>
<td>typemap(java,argout)</td>

<td>Return values through function arguments</td>
</tr>

<tr>
<td>typemap(java,out)</td>

<td>Converts the result of a C function to a java representation.</td>
</tr>

<tr>
<td>typemap(java,jtype)</td>
<td>Override the default mapping of basic types from C to Java. Always provide jni, in, argout and out typemaps if you use this typemap.</td>
</tr>

<tr>
<td>typemap(java,jni)</td>
<td>Override the default mapping of basic types from C to jni. Always provide jtype, in, argout and out typemaps if you use this typemap.</td>
</tr>
</table>

Other typemaps might work (check, freearg, newfree, ret), but are not tested.

<br>&nbsp;
<p>The following typemaps are predefined, but user defined typemaps can
be included in the interface file.
<br>&nbsp;
<table BORDER>
<tr VALIGN=TOP>
<td><b>C Type</b></td>
<td><b>Typemap</b></td>
<td><b>Kind</b></td>
<td><b>Java Type</b></td>
<td><b>Function</b></td>
</tr>

<tr>
<td>char *</td>
<td>STRING</td>
<td>input
<br>output
<br>return</td>

<td>String</td>
<td VALIGN=TOP>\0 terminated string&nbsp;
<br>Java string is converted to c string, which is released afterwards</td>
</tr>

<tr VALIGN=TOP>
<td></td>
<td>BYTE</td>
<td>input
<br>output</td>
<td>byte[]</td>

<td VALIGN=TOP>Java byte array is converted to char array which
is release afterwards</td>
</tr>

<tr>
<td>char **</td>
<td>STRING_IN</td>
<td>input</td>
<td>String[]</td>
<td>\0 terminated array of \0 terminated strings
<br>the array is malloc-ed and released afterwards</td>
</tr>

<tr>
<td></td>
<td>STRING_OUT</td>
<td>output</td>
<td>String[]</td>
<td>&amp;char*
<br>the argument is the address of an '\0' terminated string</td>
</tr>

<tr>
<td></td>
<td>STRING_RET</td>
<td>return</td>
<td>String[]</td>
<td>\0 terminated array of \0 terminated strings
<br>the array is not free-ed.</td>
</tr>

<tr>
<td>int *</td>
<td>INT_OUT</td>
<td>output</td>
<td>int[]</td>
<td>&amp;int

<br>value is returned in an int, which is stored in the Java int[0]</td>
</tr>
</table>

<br>&nbsp;
<a name="n6"></a><h2>Pragmas</h2>
There are two groups of pragmas in the Java module. The first group modify the Java module output file and the second modify the Java shadow output file. The pragmas beginning with <b>module</b> apply to the module output file. The pragmas beginning with <b>allshadow</b> apply to all shadow output classes. The pragmas beginning with <b>shadow</b> apply to the currently active shadow class so these pragmas can only be specified within the definition of a class or struct. For example:
<blockquote><pre>
/* TestStruct.i */
#ifdef SWIG
%pragma(java) modulecode="/*This code gets added to the module class*/"
%pragma(java) allshadowcode="/*This code gets added to every shadow class*/"
#endif
typedef struct TestStruct {
#ifdef SWIG
%pragma(java) shadowcode="/*This code gets added to the TestStruct shadow class only*/"
#endif
  int    myInt;
} TestStruct;
</pre></blockquote>
<br>
A complete list of pragmas follows:
<br><br>
<table BORDER>
<tr VALIGN=TOP>
<td><b>Pragma</b></td>
<td><b>Description</b></td>
<td><b>Example</b></td>
</tr>
<tr>
<td>modulebase</td>
<td>Specifies a base class for the Java module class.</td>
<td>%pragma(java) modulebase="BaseClass"</td>
</tr>
<tr>
<td>shadowbase</td>
<td>Specifies a base class for the Java shadow class.</td>
<td>%pragma(java) shadowbase="BaseClass"</td>
</tr>
<tr>
<td>allshadowbase</td>
<td>Specifies a base class for all Java shadow classes.</td>
<td>%pragma(java) allshadowbase="BaseClass"</td>
</tr>
<tr>
<td>modulecode</td>
<td>Adds code to the Java module class.</td>
<td>%pragma(java) modulecode="/*module code*/"</td>
</tr>
<tr>
<td>shadowcode</td>
<td>Adds code to the Java shadow class.</td>
<td>%pragma(java) shadowcode="/*shadow code*/"</td>
</tr>
<tr>
<td>allshadowcode</td>
<td>Adds code to all Java classes.</td>
<td>%pragma(java) allshadowcode="/*all shadow code*/"</td>
</tr>
<tr>
<td>moduleclassmodifiers</td>
<td>Overrides the default Java module class modifiers. The default is public.</td>
<td>%pragma(java) moduleclassmodifiers="public final"</td>
</tr>
<tr>
<td>shadowclassmodifiers</td>
<td>Overrides the default Java shadow class modifiers. The default is public. Also overrides allshadowclassmodifiers if present.</td>
<td>%pragma(java) shadowclassmodifiers="public final"</td>
</tr>
<tr>
<td>allshadowclassmodifiers</td>
<td>Overrides the default modifiers for all Java classes. The default is public.</td>
<td>%pragma(java) allshadowclassmodifiers="public final"</td>
</tr>
<tr>
<td>moduleimport</td>
<td>Adds an import statement to the Java module class file.</td>
<td>%pragma(java) moduleimport="java.lang.*"</td>
</tr>
<tr>
<td>shadowimport</td>
<td>Adds an import statement to the Java shadow class file. Adds to any imports specified in allshadowimport.</td>
<td>%pragma(java) shadowimport="java.lang.*"</td>
</tr>
<tr>
<td>allshadowimport</td>
<td>Adds an import statement to all Java shadow class files.</td>
<td>%pragma(java) allshadowimport="java.lang.*"</td>
</tr>
<tr>
<td>moduleinterface</td>
<td>Specifies an interface which the Java module output class implements. Can be used multiple times as Java supports multiple interfaces.</td>
<td>%pragma(java) moduleinterface="SomeInterface"</td>
</tr>
<tr>
<td>shadowinterface</td>
<td>Specifies an interface which the Java shadow class implements. Can be used multiple times as Java supports multiple interfaces. Adds to any interfaces specified in allshadowinterface.</td>
<td>%pragma(java) shadowinterface="SomeInterface"</td>
</tr>
<tr>
<td>allshadowinterface</td>
<td>Specifies an interface which all Java shadow classes implement. Can be used multiple times as Java supports multiple interfaces.</td>
<td>%pragma(java) allshadowinterface="SomeInterface"</td>
</tr>
<tr>
<td>modulemethodmodifiers</td>
<td>Overrides the native default method modifiers for the module class. The default is public final static.</td>
<td>%pragma(java) modulemethodmodifiers="protected final static synchronized"</td>
</tr>
</table>

</dl>

<h3> Deprecated pragmas</h3>
The following pragmas were in Swig 1.3a3 and have been deprecated:<br>
<b>import</b>: Please replace with <b>moduleimport</b>, <b>shadowimport</b> and/or <b>allshadowimport</b> pragmas.<br>
<b>module</b>: Please replace with the <b>modulecode</b> pragma.<br>
<b>shadow</b>: Please replace with the <b>allshadowcode</b> pragma.<br>
<b>modifiers</b>: Please replace with the <b>modulemethodmodifiers</b> pragma.<br>

<h3> Pragma uses</h3>
The pragmas are used primarily to modify the default Java output code. They provide flexibility as to how Java and C++ interact. In the pragma notation below, <b>xxxcode</b> for example would be used to denote the 3 similar 'code' pragmas, that is <b>modulecode</b>, <b>shadowcode</b> and <b>allshadowcode</b>. 

<h4> Derive C++ from Java and visa-versa</h4>
It is possible to derive a Java class from a shadow class (i.e. a C++ class) with the Java module. However, with the pragmas it is also possible to derive the SWIG produced Java shadow classes (i.e. C++ class) from your own Java class by using the <b>xxxbase</b> pragma with the <b>xxximport</b>, <b>xxxcode</b> and <b>xxxclassmodifiers</b> pragmas. It is also possible for the SWIG produced Java classes to implement interfaces using the <b>xxxinterface</b> pragmas.

<!--
<h3> JavaDoc </h3>
The SWIG documentation system that was shipped with SWIG 1.1 is currently disabled and will be replaced in the future. If you require some documentation in the meantime in your Java module class or shadow class, it can be added using the <b>xxxcode</b> pragmas. JavaDoc comments can be inserted instead of Java code. Although you can insert as many of these code pragmas as you like scattered throughout the C/C++ code, they are all output together in the Java class. Thus you can have a block of JavaDoc comments per class, but it is not flexible enough to have a JavaDoc comment above each member function. <b> Does not work! The documenation only gets added to one method!!</b>
-->

<a name="n7"></a><h2>Shadow Classes and Garbage Collection</h2>
If you get SWIG to produce shadow classes, you will notice the generated <code>_delete()</code> and <code>finalize()</code> methods. The <code>finalize()</code> method calls <code>_delete()</code> which frees any SWIG malloced c memory for wrapped structs or deletes any SWIG wrapped classes created on the heap, which in turn calls the class' destructor. The idea is for <code>_delete()</code> to be called when you have finished with the C/C++ object. Ideally you need not call <code>_delete()</code>, but rather leave it to the garbage collector to call it from the finalizer. The unfortunate thing is that Sun, in their wisdom, do not guarantee that the finalizers will be called. When a program exits, the garbage collector does not always call the finalizers. Depending on what the finalizers do and which operating system you use, this may or may not be a problem. 
<br><br>

If the <code>_delete()</code> call into JNI code is just for memory handling, there is not a problem when run on Windows and Unix. Say your JNI code creates memory on the heap which your finalizers will clean up, the finalizers may or may not be called before the program exits. In Windows and Unix all memory that a process uses is returned to the system, so this isn't a problem. This is not the case in some operating systems like vxWorks. If however, your finalizers call into JNI code invokes a C++ destructor which in turn releases a socket for example, there is no guarantee that it will be released. Note that the garbage collector will eventually run, so long running programs will have their finalizers called periodically.
<br><br>

Some not so ideal solutions are:
<ol>
<li start=1>
Call the <code>System.runFinalizersOnExit(true)</code> or <code>Runtime.getRuntime().runFinalizersOnExit(true)</code> to ensure the finalizers are called before the program exits. The catch is that this is a deprecated function call as the documenation says: 
<blockquote><i>
This method is inherently unsafe. It may result in finalizers being called on live objects while other threads are concurrently manipulating those objects, resulting in erratic behavior or deadlock.
</i></blockquote> 
In many cases you will be lucky and find that it works, but it is not to be advocated. Have a look at <a href=http://java.sun.com>Sun's Java web site</a> and search for <code>runFinalizersOnExit</code>.
</li>
<p>
<li>
From jdk1.3 onwards a new function, <code>addShutdownHook()</code>, was introduced which is guaranteed to be called when your program exits. You can encourage the garbage collector to call the finalizers, for example, add this static block to the class that has the <code>main()</code> function: 
<blockquote><pre>
  static {
    Runtime.getRuntime().addShutdownHook( 
      new Thread() {
        public void run() { System.gc(); System.runFinalization(); }
      }
    );
  }
</pre></blockquote>
Although this usually works, the documentation doesn't guarantee that <code>runFinalization()</code> will actually call the finalizers. As the the shutdown hook is guaranteed you could also make a JNI call to clean up any resources that are being tracked in the C/C++ code.
</li>
<p>
<li>
Call the <code>_delete()</code> function manually. As a suggestion it may be a good idea to set the object to null so that should the object be inadvertantly used again a Java null pointer exception is thrown, the alternative would crash the JVM by using a null c pointer. For example given a SWIG generated class A:
<blockquote><pre>
A myA = new A();
// use myA ...
myA._delete();
// any use of myA here would crash the JVM 
myA=null;
// any use of myA here would cause a java null pointer exception to be thrown
</pre></blockquote>
The SWIG generated code ensures that the memory is not deleted twice, in the event the finalizers get called in addition to the manual <code>_delete()</code> call.
</li>

<p>
<li>
Write your own object manager in Java. You could derive all SWIG classes from a single base class which could track which objects have had their finalizers run, then call the rest of them on program termination. Currently you cannot tell SWIG to derive a SWIG shadow class from any named Java class, but this is planned in the near future. An alternative is to add the object handling code to all generated shadow classes using the shadow pragma.
</li>
</ol>

<a name="n8"></a><h2>Dynamic Linking Problems</h2>
The code to load a native library is <code>System.loadLibrary("name")</code>. This can fail and it can be due to a number of reasons. 
<br><br>
The most common is an incorrect naming of the native library for the name passed to the <code>loadLibrary</code> function. The text passed to the <code>loadLibrary</code> function must not include the the extension name in the text, that is <i>.dll</i> or <i>.so</i>. The text must be <i>name</i> and not <i>libname</i> for all platforms. On Windows the native library must then be called <i>name.dll</i> and on Unix it must be called <i>libname.so</i>. If you are debugging using <code> java -debug</code>, then the native library must be called <i>name_g.dll</i> on Windows and <i>libname_g.so</i> on Unix.
<br><br>
Another common reason for the native library not loading is because it is not in your path. On Unix make sure that your <i>LD_LIBRARY_PATH</i> contains the path to the native library. On Windows make sure the <i>path</i> environment variable contains the path to the native library. SWIG code usually works if you have <i>LD_LIBRARY_PATH</i> set to '.' (or no modification to <i>path</i> in Windows).
<br><br>
The native library will also not load if there are any unresolved symbols in the compiled C/C++ code. 
<br><br>
Ensure that you are using the correct C/C++ compiler and linker combination and options for successful native library loading. The Examples/Makefile must have these set up correctly for your system. The SWIG installation package makes a best attempt at getting these correct but does not get it right 100% of the time.
<br><br>
Linking problems used to occur when there were underscores in the module name or package name. This was fixed in SWIG 1.3.7.

<a name="n9"></a><h2>Tips</h2>

<ul>
<li>
Use %name to rename the shadow classes.</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %name(JPasswd) struct passwd {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ....
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</pre>
<li>
The %native directive can be used to mix hand written JNI functions with the auto generated functions.
<li>
The %except directive can be used to handle exceptions. If there is an exception a <code>return NULL</code> is often used. As some JNI function return types are void, a <code>return</code> is needed instead of a <code>return NULL</code>. This can be solved by using %typemap(java, except) which will use the return type as the basis for overriding the %except directive.
</ul>

<a name="n10"></a><h2>Caveats</h2>

<ul>
<li>
Pointers are stored in a Java long, which is represented as a c long long
on most machines. The pointer address is stored in the high order long
of the long long, and cannot be manipulated directly from Java.</li>

<li>
If a typemap(java,in) is specified, the typemap(java,argout) must also
be specified, because the default 'argout' code depends on the default
'in' code.</li>
</ul>

<a name="n11"></a><h2>Bugs</h2>
<ul>
<li>Global arrays do not work.</li>
</ul>

</body>
</html>
