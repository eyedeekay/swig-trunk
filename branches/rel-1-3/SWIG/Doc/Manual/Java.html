<html>
<head>
<title>SWIG and Java</title>
</head>
<body bgcolor="#FFFFFF">
<a name="n1"></a><H1>14 SWIG and Java</H1>
<!-- INDEX -->
<ul>
<li><a href="#n2">Preliminaries</a>
<ul>
<li><a href="#n3">Running SWIG</a>
<li><a href="#n4">Additional Commandline Options</a>
<li><a href="#n5">Getting the right header files</a>
<li><a href="#n6">Compiling a dynamic module</a>
<li><a href="#n7">Using your module</a>
<li><a href="#n8">Compilation problems and compiling with C++</a>
</ul>
<li><a href="#n9">Building Java Extensions under Windows</a>
<ul>
<li><a href="#n10">Running SWIG from Developer Studio</a>
<li><a href="#n11">Using NMAKE</a>
</ul>
<li><a href="#n12">A tour of basic C/C++ wrapping</a>
<ul>
<li><a href="#n13">Modules, packages and generated Java classes</a>
<li><a href="#n14">Functions</a>
<li><a href="#n15">Global variables</a>
<li><a href="#n16">Constants</a>
<li><a href="#n17">Enumerations</a>
<li><a href="#n18">Pointers</a>
<li><a href="#n19">Arrays</a>
<li><a href="#n20">Structures</a>
<li><a href="#n21">C++ classes</a>
<li><a href="#n22">C++ inheritance</a>
<li><a href="#n23">Pointers, references and pass by value</a>
<li><a href="#n24">C++ overloaded functions</a>
<li><a href="#n25">C++ namespaces</a>
<li><a href="#n26">C++ templates</a>
</ul>
<li><a href="#n27">Further details on the generated Java classes</a>
<ul>
<li><a href="#n28">The JNI class</a>
<ul>
<li><a href="#n29">The JNI class pragmas</a>
</ul>
<li><a href="#n30">The Java module class</a>
<ul>
<li><a href="#n31">The Java module class pragmas</a>
</ul>
<li><a href="#n32">Java proxy classes</a>
<ul>
<li><a href="#n33">Memory management</a>
<li><a href="#n34">Inheritance</a>
<li><a href="#n35">Proxy classes and garbage collection</a>
</ul>
<li><a href="#n36">Type wrapper classes</a>
</ul>
<li><a href="#n37">Common customization features</a>
<ul>
<li><a href="#n38">C/C++ helper functions</a>
<li><a href="#n39">Class extension with %extend</a>
<li><a href="#n40">Exception handling with %exception</a>
</ul>
<li><a href="#n41">Tips and techniques</a>
<ul>
<li><a href="#n42">Input and output parameters</a>
<li><a href="#n43">Simple pointers</a>
<li><a href="#n44">Unbounded C Arrays</a>
</ul>
<li><a href="#n45">Java typemaps</a>
<ul>
<li><a href="#n46">Default primitive type mappings</a>
<li><a href="#n47">bit JVMs</a>
<li><a href="#n48">What is a typemap?</a>
<li><a href="#n49">Typemaps for mapping C/C++ types to Java types</a>
<li><a href="#n50">Typemap variables</a>
<li><a href="#n51">Typemaps for both C and C++ compilation</a>
<li><a href="#n52">Java code typemaps</a>
</ul>
<li><a href="#n53">Typemap Examples</a>
<ul>
<li><a href="#n54">Converting Java String arrays to char ** </a>
<li><a href="#n55">Expanding a Java object to multiple arguments</a>
<li><a href="#n56">Using typemaps to return arguments</a>
<li><a href="#n57">Accessing array structure members</a>
<li><a href="#n58">Pointer handling</a>
</ul>
<li><a href="#n59">Odds and ends</a>
<ul>
<li><a href="#n60">Functional interface without proxy classes</a>
<li><a href="#n61">Dynamic linking problems</a>
<li><a href="#n62">Using your own JNI methods</a>
<li><a href="#n63">Performance concerns and hints</a>
<li><a href="#n64">Known bugs</a>
</ul>
<li><a href="#n65">Examples</a>
</ul>
<!-- INDEX -->



This chapter describes SWIG's support of Java. 
Java is one of the few non-scripting language modules in SWIG.
Using Java has the advantage over scripting languages of being type safe.  
The 100% Pure Java effort is a commendable concept however, in the real world programmers either need to re-use their existing code or in some situations 
want to take advantage of Java but are forced into using some native (C/C++) code.
<p>

The Java extension to SWIG makes it very easy to plumb in existing C/C++ code for access from Java, as SWIG writes the Java Native Interface (JNI) code for you. 
It is different to using the 'javah' tool as SWIG will wrap existing C/C++ code, whereas javah takes Java functions and creates C/C++ function prototypes.
SWIG wraps C/C++ code using Java proxy classes and is very useful if you want to have access to large amounts of C/C++ code from Java.
If only one or two JNI functions are needed then using SWIG may be overkill.
An important point to note is that SWIG enables a Java program to easily call into C/C++ code and not visa-versa.
If you primarily want calls from C/C++ into Java then SWIG isn't particularly useful as the appropriate JNI code will have to be written by hand. 
<p>

<a name="n2"></a><H2>14.1 Preliminaries</H2>


SWIG 1.1 works with JDKs from JDK 1.1 to JDK1.4 (Java 2 SDK1.4) and should also work with any later versions.
Given the choice, you should probably use the latest version of Sun's JDK. 
The SWIG Java module is known to work using Sun's JVM on Solaris, Linux and the various flavours of Microsoft Windows including Cygwin. 
The Kaffe JVM is known to give a few problems and at the time of writing was not a fully fledged JVM with full JNI support. 
The generated code is also known to work on vxWorks using WindRiver's PJava 3.1. 
The best way to determine whether your combination of operating system and JDK will work is to test the examples and test-suite that comes with SWIG. 
Run <tt>make -k check</tt> from the SWIG root directory after installing SWIG on Unix systems. <p>

The Java module requires your system to support shared libraries and dynamic loading. This is the commonly used method to load JNI code so your system is more than likely to support this.<p>

<a name="n3"></a><H3>14.1.1 Running SWIG</H3>


The basics of getting a SWIG Java module up and running can be seen from one of SWIG's example Makefiles, but is also described here. 
To build a Java module, run SWIG using the <tt>-java</tt> option. Note that proxy classes are enabled by default.<p>
<p>
<blockquote><pre>%swig -java example.i
</pre></blockquote>
<p>
This will produce 2 files. 
The file <tt>example_wrap.c</tt> contains all of the C code needed to build a Java module. 
To build a Java module, you will need to compile the file <tt>example_wrap.c</tt> to create a shared library. 
When proxy classes are enabled, SWIG may also produce many <tt>.java</tt> files, but this is described later.<p>

<a name="n4"></a><H3>14.1.2 Additional Commandline Options</H3>


The following table list the additional commandline options available for the Java module. They can also be seen by using: 
<blockquote><pre>swig -java -help 
</pre></blockquote>

<table>
<tr>
<th>Java specific options</th>
</tr>

<tr>
<td>-package &lt;java package&gt;</td>
<td>set the name of the package for the generated classes</td>
</tr>

<tr>
<td>-noproxy</td>
<td>Use the low-level functional interface, that is, do not generate proxy classes a.k.a. shadow classes</td>
</tr>

</table>
<br>
Their use will become clearer by the time you have finished reading this section on SWIG and Java.

<a name="n5"></a><H3>14.1.3 Getting the right header files</H3>


In order to compile, you need to locate the "jni.h" and "md.h" header files which are part of the JDK. 
They are usually in directories like this:<p>
<p>
<blockquote><pre>
/usr/java/include
/usr/java/include/&lt;operating_system&gt;
</pre></blockquote>
<p>

The exact location may vary on your machine, but the above locations are typical. <p>
<a name="n6"></a><H3>14.1.4 Compiling a dynamic module</H3>


The JNI code exists in a dynamic module or shared object and gets loaded by the JVM. 
To build a shared object file, you need to compile your module in a manner similar to the following (shown for Solaris):<p>
<p>
<blockquote><pre>
$ swig -java example.i
$ gcc -c example_wrap.c  -I/usr/java/include -I/usr/java/include/solaris
$ ld -G example_wrap.o  -o libexample.so

</pre></blockquote>
Unfortunately, the process of building a shared object file varies on every single machine so you may need to read up on the man pages for your C compiler and linker.<p>
<p>
When building a dynamic module, the name of the output file is important. 
If the name of your SWIG module is "<tt>example</tt>", the name of the corresponding object file should be "<tt>libexample.so</tt>" (or equivalent depending on your machine, see <a href="#n61">Dynamic linking problems</a> for more information). 
The name of the module is specified using the <tt>%module</tt> directive or<tt> -module</tt> command line option.<p>
<p>

<a name="n7"></a><H3>14.1.5 Using your module</H3>


To use your module in Java, simply use Java's <tt>System.loadLibrary</tt> method in a Java class:<p>
<p>
<blockquote><pre>
// main.java

public class main {
  static {
    System.loadLibrary("example");
  }

  public static void main(String argv[]) {
    System.out.println(example.fact(4));
  }
}
</pre></blockquote>
Compile all the Java files and run:

<blockquote><pre>
$ javac *.java
$ java main
24
$
</pre></blockquote>

<a name="n8"></a><H3>14.1.6 Compilation problems and compiling with C++</H3>


For the most part, compiling a Java module is straightforward, but there are a number of potential problems :<p>
<p>
<ul>
<li>In order to build C++ modules, you may need to link with the C++ compile using a command like `<tt>c++ -shared example_wrap.o example.o -o libexample.so</tt>'
<li>If building a dynamic C++ module using g++, you may also need to link against <tt>libgcc.a</tt>, <tt>libg++.a</tt>, and <tt>libstc++.a</tt> libraries.
<li>Make sure you are using the version of JDK header files matches the version of Java that you are running.
</ul>

<a name="n9"></a><H2>14.2 Building Java Extensions under Windows</H2>


Building a SWIG extension to Java under Windows is roughly similar to the process used with Unix.  
You will want to produce a DLL that can be loaded by the Java Virtual Machine.  
This section covers the process of using SWIG with Microsoft Visual C++ 6 although the procedure may be similar with other compilers.  
In order to build extensions, you will need to have a JDK installed on your machine in order to read the JNI header files.<p>

<a name="n10"></a><H3>14.2.1 Running SWIG from Developer Studio</H3>


If you are developing your application within Microsoft developer studio, SWIG can be invoked as a custom build option. 
The process roughly follows these steps:<p>
<p>
<ul>
<li>Open up a new workspace and use the AppWizard to select a DLL project.
<li>Add both the SWIG interface file (the .i file), any supporting C files, and the name of the wrapper file that will be created by SWIG (ie. <tt>example_wrap.c</tt>).   Note: If using C++, choose a different suffix for the wrapper file <tt>example_wrap.cxx</tt>. Don't worry if the wrapper file doesn't exist yet--Developer Studio will keep a reference to it.
<li>Select the SWIG interface file and go to the settings menu. Under settings, select the "Custom Build" option.
<li>Enter "SWIG" in the description field.
<li>Enter "<tt>swig -java -o $(ProjDir)\$(InputName)_wrap.c $(InputPath)</tt>" in the "Build command(s) field"
<li>Enter "<tt>$(ProjDir)\$(InputName)_wrap.c</tt>" in the "Output files(s) field".
<li>Next, select the settings for the entire project and go to C/C++ tab and select the Preprocessor category . Add the include directories to the JNI header files under "Additional include directories", eg "C:\jdk1.3\include,C:\jdk1.3\include\win32".
<li>Next, select the settings for the entire project and go to Link tab and select the General category. Set the name of the output file to match the name of your Java module (ie. example.dll).
<li>Next, select the example.c and example_wrap.c files and go to the C/C++ tab and select the Precompiled Headers tab in the project settings. Disabling precompiled headers for these files will overcome any precompiled header errors while building.
<li>Finally, add the java compilation as a post build rule in the Post-build step tab in project settings, eg, "c:\jdk1.3\bin\javac *.java" 
<li>Build your project.
</ul>
<p>
Now, assuming all went well, SWIG will be automatically invoked when you build your project.  
When doing a build, any changes made to the interface file will result in SWIG being automatically invoked to produce a new version of the wrapper file.  
The Java classes that SWIG output should also be compiled into .class files. 
To run the native code in the DLL (example.dll), make sure that it is in your path then run your Java program which uses it, as described in the previous section. 
If the library fails to load have a look at <a href="#n61">Dynamic linking problems</a>.
<p>

<a name="n11"></a><H3>14.2.2 Using NMAKE</H3>


Alternatively, SWIG extensions can be built by writing a Makefile for NMAKE.   
Make sure the environment variables for MSVC++ are available and the MSVC++ tools are in your path.   
Now, just write a short Makefile like this :<p>
<p>
<blockquote><pre>
# Makefile for building a Java extension

SRCS          = example.c
IFILE         = example
INTERFACE     = $(IFILE).i
WRAPFILE      = $(IFILE)_wrap.c

# Location of the Visual C++ tools (32 bit assumed)

TOOLS         = c:\msdev
TARGET        = example.dll
CC            = $(TOOLS)\bin\cl.exe
LINK          = $(TOOLS)\bin\link.exe
INCLUDE32     = -I$(TOOLS)\include
MACHINE       = IX86

# C Library needed to build a DLL

DLLIBC        = msvcrt.lib oldnames.lib  

# Windows libraries that are apparently needed
WINLIB        = kernel32.lib advapi32.lib user32.lib gdi32.lib comdlg32.lib winspool.lib

# Libraries common to all DLLs
LIBS          = $(DLLIBC) $(WINLIB) 

# Linker options
LOPT      = -debug:full -debugtype:cv /NODEFAULTLIB /RELEASE /NOLOGO \
             /MACHINE:$(MACHINE) -entry:_DllMainCRTStartup@12 -dll

# C compiler flags

CFLAGS        = /Z7 /Od /c /nologo
JAVA_INCLUDE    = -ID:\jdk1.3\include -ID:\jdk1.3\include\win32

java::
	swig -java -o $(WRAPFILE) $(INTERFACE)
	$(CC) $(CFLAGS) $(JAVA_INCLUDE) $(SRCS) $(WRAPFILE)
	set LIB=$(TOOLS)\lib
	$(LINK) $(LOPT) -out:example.dll $(LIBS) example.obj example_wrap.obj
	javac *.java
</pre></blockquote>
<p>
To build the extension, run NMAKE (you may need to run <tt>vcvars32</tt> first). 
This is a pretty simplistic Makefile, but hopefully its enough to get you started.   <p>


<a name="n12"></a><H2>14.3 A tour of basic C/C++ wrapping</H2>


By default, SWIG attempts to build a natural Java interface
to your C/C++ code.  Functions are wrapped as functions, classes are wrapped as classes, 
variables are wrapped with JavaBean type getters and setters and so forth.
This section briefly covers the essential aspects of this wrapping.

<a name="n13"></a><H3>14.3.1 Modules, packages and generated Java classes</H3>


The SWIG <tt>%module</tt> directive specifies the name of the Java
module. When you specify `<tt>%module example</tt>', the <i>module name</i>
determines the name of some of the generated files in the module.
The generated code consists of a <i>module class</i> file <tt>example.java</tt>, a
<i>JNI class</i> file, <tt>exampleJNI.java</tt> as well as numerous other Java <i>proxy class</i> files.
Each proxy class is named after the structs, unions and classes you are wrapping.
When choosing a module name, make sure you don't use the same name as one of the generated
proxy class files nor a Java keyword. Sometimes a C/C++ type cannot be wrapped by a proxy class, for 
example a pointer to a primitive type. In these situations a <i>type wrapper class</i> is generated.
Details of all these generated classes will unfold as you read this section.
<p>

The JNI (C/C++) code is generated into a file also with the module name, for example <tt>example_wrap.cxx</tt>
or </tt>example_wrap.c</tt>. These C or C++ files complete the contents of the module.
<p>

The generated Java classes can be placed into a Java package by using the -package commandline option.

<a name="n14"></a><H3>14.3.2 Functions</H3>


There is no such thing as a global Java function so global functions are wrapped as static methods in 
the module class. For example,

<p>
<blockquote><pre>%module example
int fact(int n);

</pre></blockquote>

creates a static function that works exactly like you think it might:<p>

<blockquote><pre>
public class example {
  public static int fact(int n) {
    // makes call using JNI to the C function
  }
}
</pre></blockquote>


<p>
It can be used as follows from Java:<p>

<blockquote><pre>
System.out.println(example.fact(4));
</pre></blockquote>


<a name="n15"></a><H3>14.3.3 Global variables</H3>


C/C++ global variables are fully supported by SWIG.  
Java does not allow the overriding of the dot operator so all variables are accessed through getters and setters. 
Again because there is no such thing as a
Java global variable, access to C/C++ global variables is done through static getter and setter functions in the module class.

<blockquote><pre>
// SWIG interface file with global variables
%module example
...
extern int My_variable;
extern double density;
...
</pre></blockquote>

<p>

Now in Java :<p>
<p>

<blockquote><pre>
// Print out value of a C global variable
System.out.println("My_variable = " + example.getMy_variable());
// Set the value of a C global variable
example.setDensity(0.8442);
</pre></blockquote>

The value returned by the getter will always be up to date even if the value is changed in C. 
Note that the getters and setters produced follow the JavaBean property design pattern. 
That is the first letter of the variable name is capitalized and preceded with set or get.
If you have the misfortune of wrapping two variables that differ only in the capitalization of their first letters,
use %rename to change one of the variable names. For example:

<blockquote><pre>
%rename Clash RenamedClash;
float Clash;
int clash;
</pre></blockquote>

<p>
If a variable is declared as <tt>const</tt>, it is wrapped as a read-only variable.  
That is only a getter is produced.

<p>
To make ordinary variables read-only, you can use the <tt>%immutable</tt> directive. For example:

<blockquote>
<pre>
%immutable;
extern char *path;
%mutable;
</pre>
</blockquote>

The <tt>%immutable</tt> directive stays in effect until it is explicitly disabled using
<tt>%mutable</tt>.

<p>
If you just want to make a specific variable immutable, supply a declaration name.  For example:

<blockquote>
<pre>
%immutable path;
...
extern char *path;      // Read-only (due to %immutable)
</pre>
</blockquote>


<a name="n16"></a><H3>14.3.4 Constants</H3>


C/C++ constants are wrapped as Java static final variables.
To create a constant, use <tt>#define</tt> or the
<tt>%constant</tt> directive.  For example:

<blockquote>
<pre>
#define PI 3.14159
#define VERSION "1.0"
%constant int FOO = 42;
%constant const char *path = "/usr/local";
</pre>
</blockquote>

By default the generated static final variables are initialised by making a JNI call to get their value.
The generated code looks like this:

<blockquote><pre>
public class example {
  // enums and constants
  public final static double PI = exampleJNI.get_PI();
  public final static String VERSION = exampleJNI.get_VERSION();
  public final static int FOO = exampleJNI.get_FOO();
  public final static String path = exampleJNI.get_path();
}
</pre></blockquote>

Although these are final static variables, they are not compiler constants that can, for example, be used 
in a switch statement. This can be changed by using the %javaconst(flag) directive. It works like all
the other %feature directives. The default is %javaconst(0) and %javaconst(1) will initialize all 
final static variables using the C code. For example:

<blockquote><pre>
%javaconst(1);
%javaconst(0) BIG;
#define BIG 1000LL
#define EXPRESSION (0x100+5)
</pre></blockquote>

generates:

<blockquote><pre>
public class example {
  // enums and constants
  public final static long BIG = exampleJNI.get_BIG();
  public final static int EXPRESSION = (0x100+5);
}
</pre></blockquote>

Using the %javaconst(1) directive can be dangerous as not all C code will compile as Java code. For example the 
<tt>1000LL</tt> value for the <tt>BIG</tt> constant above would not generate valid Java code. 
The above example also demonstrates how you can target particular constants with %javaconst.

<p>
Note:  declarations declared as <tt>const</tt> are wrapped as read-only variables and
will be accessed using a getter as described in the previous section.  They
are not wrapped as constants.


<a name="n17"></a><H3>14.3.5 Enumerations</H3>


Enumerations are wrapped as final static integers in Java and are also initialised using a JNI call. For example:

<blockquote>
<pre>
enum Beverage { ALE, LAGER, STOUT, PILSNER };
</pre>
</blockquote>

generates:

<blockquote><pre>
public class example {
  // enums and constants
  public final static int ALE = exampleJNI.get_ALE();
  public final static int LAGER = exampleJNI.get_LAGER();
  public final static int STOUT = exampleJNI.get_STOUT();
  public final static int PILSNER = exampleJNI.get_PILSNER();
}
</pre></blockquote>

For enums, make sure that the definition of the enumeration actually appears in a header
file or in the wrapper file somehow---if you just stick an enum in a SWIG interface without
also telling the C compiler about it, the wrapper code won't compile.

<p>

<a name="n18"></a><H3>14.3.6 Pointers</H3>


C/C++ pointers are fully supported by SWIG.  Furthermore, SWIG has no problem working with
incomplete type information.  Here is a rather simple interface:

<blockquote>
<pre>
%module example

FILE *fopen(const char *filename, const char *mode);
int fputs(const char *, FILE *);
int fclose(FILE *);
</pre>
</blockquote>

When wrapped, you will be able to use the functions in a natural way from Java. For example:

<blockquote>
<pre>
SWIGTYPE_p_FILE f = example.fopen("junk","w");
example.fputs("Hello World\n", f);
example.fclose(f);
</pre>
</blockquote>

Underneath the covers, pointers to C/C++ objects traverse the JNI boundary held in a Java long. 
In order to implement static type checking of pointers within Java, they are wrapped by a simple Java class. 
In the example above the <tt>FILE *</tt> pointer is wrapped with a <i>type wrapper class </i> 
called <tt>SWIGTYPE_p_FILE</tt>.

<p>
Once obtained a type wrapper object can be freely passed around to different C functions that
expect to receive an object of that type.  The only thing you can't do is 
dereference the pointer from Java. Of course, that isn't much of a concern in this example.

<p>
As much as you might be inclined to modify a pointer value directly
from Java, don't.  The value is not necessarily the
same as the logical memory address of the underlying object.  The value will
vary depending on the native byte-ordering of the platform (i.e.,
big-endian vs. little-endian).  By design it is also not possible to manually cast
a pointer to a new type by using Java casts as it is particularly dangerous when
casting C++ objects.  If you need to cast a pointer or
change its value, consider writing some helper functions instead.  For
example:

<blockquote>
<pre>
%inline %{
/* C-style cast */
Bar *FooToBar(Foo *f) {
   return (Bar *) f;
}

/* C++-style cast */
Foo *BarToFoo(Bar *b) {
   return dynamic_cast&lt;Foo*&gt;(b);
}

Foo *IncrFoo(Foo *f, int i) {
    return f+i;
}
%}
</pre>
</blockquote>

Also, if working with C++, you should always try
to use the new C++ style casts.  For example, in the above code, the
C-style cast may return a bogus result whereas as the C++-style cast will return
a NULL pointer if the conversion can't be performed.
<p>

<a name="n19"></a><H3>14.3.7 Arrays</H3>


SWIG will handle arrays and are simple to use.  Let's consider an example:

<blockquote>
<pre>
int array[4];
void populate(int x[]) {
    int i;
    for (i=0; i<4; i++)
        x[i] = 100 + i;
}
</pre>
</blockquote>

These one dimensional arrays can then be used as if they were Java arrays:

<blockquote>
<pre>
int[] array = new int[3];
example.populate(array);

System.out.print("array: ");
for (int i=0; i&lt;array.length; i++)
    System.out.print(array[i] + " ");

example.setArray(array);

int[] global_array = example.getArray();

System.out.print("\nglobal_array: ");
for (int i=0; i&lt;array.length; i++)
    System.out.print(global_array[i] + " ");
</pre>
</blockquote>

Java arrays are passed by value, so any changes a function makes to the array will be seen by the calling function. 
Here is the output after running this code:

<blockquote>
<pre>
array: 100 101 102 103 0 0
global_array: 100 101 102 103
</pre>
</blockquote>

Note that for assigning array variables the length of the C variable is used, so as the example demonstrates it is possible to use an array that is bigger than the C code will cope with.
Only the number of elements in the C array will be used.
However, if the Java array is not large enough then you are likely to get a segmentation fault or access violation, just like you would in C.
When arrays are used in functions like <code>populate</code>, the size of the C array passed to the function is determined by the size of the Java array.
Please be aware that using arrays is not efficient as all the elements are copied from the Java array to a C array whenever the array is passed to and from JNI code.
There is an array library which can also be used and this approach is covered later.

<p>

<a name="n20"></a><H3>14.3.8 Structures</H3>


If you wrap a C structure, it is wrapped by a Java class with getters and setters for access to the
member variables. For example,

<p>
<blockquote><pre>struct Vector {
	double x,y,z;
};

</pre></blockquote>

is used as follows:

<blockquote><pre>
Vector v = new Vector();
v.setX(3.5);
v.setY(7.2);
double x = v.getX();
double y = v.getY();
</pre></blockquote>
The variable setters and getters are also based on the JavaBean design pattern covered already covered under the Global variables section.
Similar access is provided for unions and the public data members of C++ classes.<p>

This object is actually an instance of a Java class that has been wrapped around a pointer to the C structure.  
This instance doesn't actually do anything--it just serves as a proxy.
The pointer to the C object is held in the Java proxy class in much the same way as pointers are held by type wrapper classes.
Further details about Java proxy classes are covered a little later.

<p>
<tt>const</tt> members of a structure are read-only. Data members
can also be forced to be read-only using the <tt>%immutable</tt> directive. For example:

<blockquote>
<pre>
struct Foo {
   ...
   %immutable;
   int x;        /* Read-only members */
   char *name;
   %mutable;
   ...
};
</pre>
</blockquote>

<p>
When <tt>char *</tt> members of a structure are wrapped, the contents are assumed to be
dynamically allocated using <tt>malloc</tt> or <tt>new</tt> (depending on whether or not
SWIG is run with the -c++ option).   When the structure member is set, the old contents will be 
released and a new value created.   If this is not the behavior you want, you will have to use
a typemap (described later).

<p>
If a structure contains arrays, access to those arrays is managed in a similar manner as global arrays.
Consider this example:

<blockquote>
<pre>
struct Bar {
    int  x[16];
};
</pre>
</blockquote>

If accessed in Java, you will see behavior like this:

<blockquote>
<pre>
Bar b = new Bar();
int[] x1 = new int[16];
for (int i=0; i<x1.length; i++)
    x1[i] = 99;
b.setX(x1);
int[] x2 = b.getX();
</pre>
</blockquote>

The two integer arrays, <code>x1</code> and <code>x2</code> are two different arrays but are of the same size and the same member values.
<p>

<p>
When a member of a structure is itself a structure, it is handled as a
pointer.  For example, suppose you have two structures like this:

<blockquote>
<pre>
struct Foo {
   int a;
};

struct Bar {
   Foo f;
};
</pre>
</blockquote>

Now, suppose that you access the <tt>f</tt> member of <tt>Bar</tt> like this:

<blockquote>
<pre>
Bar b = new Bar();
Foo x = b.getF();
</pre>
</blockquote>

In this case, <tt>x</tt> is a pointer that points to the <tt>Foo</tt> that is inside <tt>b</tt>.
This is the same value as generated by this C code:

<blockquote>
<pre>
Bar b;
Foo *x = &b->f;       /* Points inside b */
</pre>
</blockquote>

Because the pointer points inside the structure, you can modify the contents and 
everything works just like you would expect. For example:

<blockquote>
<pre>
Bar b = new Bar();
b.getF().setA(3);   // Modify b.f.a
Foo x = b.getF();                   
x.setA(3);          // Modify x.a - this is the same as b.f.a
</pre>
</blockquote>


<a name="n21"></a><H3>14.3.9 C++ classes</H3>


C++ classes are wrapped by Java classes as well. For example, if you have this class,

<p>
<blockquote><pre>class List {
public:
  List();
  ~List();
  int  search(char *item);
  void insert(char *item);
  void remove(char *item);
  char *get(int n);
  int  length;
};
</pre></blockquote>

you can use it in Java like this:

<blockquote><pre>
List l = new List();
l.insert("Ale");
l.insert("Stout");
l.insert("Lager");
String item = l.get(2);
int length = l.getLength();
</pre></blockquote>

Class data members are accessed in the same manner as C structures.  

<p>
Static class members are unsurprisingly wrapped as static members of the Java class:

<blockquote>
<pre>
class Spam {
public:
   static void foo();
   static int bar;
};
</pre>
</blockquote>

The static members work like any other Java static member:

<blockquote>
<pre>
Spam.foo();
int bar = Spam.getBar();
</pre>
</blockquote>


<a name="n22"></a><H3>14.3.10 C++ inheritance</H3>


SWIG is fully aware of issues related to C++ inheritance.  Therefore, if you have
classes like this

<blockquote>
<pre>
class Foo {
...
};

class Bar : public Foo {
...
};
</pre>
</blockquote>

those classes are wrapped into a hierarchy of Java classes that reflect the same inheritance
structure:

<blockquote>
<pre>
Bar b = new Bar();
Class c = b.getClass();
System.out.println(c.getSuperclass().getName());
</pre>
</blockquote>

will of course display:

<blockquote><pre>
Foo
</pre></blockquote>


Furthermore, if you have functions like this

<blockquote>
<pre>
void spam(Foo *f);
</pre>
</blockquote>

then the Java function <tt>spam()</tt> accepts instances of <tt>Foo</tt> or instances of any other proxy classes derived from <tt>Foo</tt>.

<p>
Note that Java does not support multiple inheritance so any multiple inheritance in the C++ code is not going to work. 
A warning is given when multiple inheritance is detected and only the first base class is used. 

<a name="n23"></a><H3>14.3.11 Pointers, references and pass by value</H3>


In C++, there are many different ways a function might receive
and manipulate objects.  For example:

<blockquote>
<pre>
void spam1(Foo *x);      // Pass by pointer
void spam2(Foo &x);      // Pass by reference
void spam3(Foo x);       // Pass by value
</pre>
</blockquote>

In Java, there is no detailed distinction like this--specifically,
there are only instances of classes.  There are no pointers nor references.
Because of this, SWIG unifies all of these types
together in the wrapper code.  For instance, if you actually had the
above functions, it is perfectly legal to do this from Java:

<blockquote>
<pre>
Foo f = new Foo();  // Create a Foo
example.spam1(f);   // Ok. Pointer
example.spam2(f);   // Ok. Reference
example.spam3(f);   // Ok. Value.
</pre>
</blockquote>

Similar behavior occurs for return values.  For example, if you had
functions like this,

<blockquote>
<pre>
Foo *spam5();
Foo &spam6();
Foo  spam7();
</pre>
</blockquote>

then all three functions will return a pointer to some <tt>Foo</tt> object.
Since the third function (spam7) returns a value, newly allocated memory is used 
to hold the result and a pointer is returned (Java will release this memory 
when the return object's finalizer is run by the garbage collector).

<a name="n24"></a><H3>14.3.12 C++ overloaded functions</H3>


C++ overloaded functions, methods, and constructors are mostly supported by SWIG.  For example,
if you have two functions like this:

<blockquote>
<pre>
void foo(int);
void foo(char *c);
</pre>
</blockquote>

You can use them in Java in a straightforward manner:

<blockquote>
<pre>
foo(3);           // foo(int)
foo("Hello");     // foo(char *c)
</pre>
</blockquote>

Similarly, if you have a class like this,

<blockquote>
<pre>
class Foo {
public:
    Foo();
    Foo(const Foo &);
    ...
};
</pre>
</blockquote>

you can write Java code like this:

<blockquote>
<pre>
Foo f = new Foo();        // Create a Foo
Foo g = new Foo(f);       // Copy f
</pre>
</blockquote>

Overloading support is not quite as flexible as in C++. Sometimes there are methods that SWIG
can't disambiguate as there is more than one C++ type maps onto one Java type. For example:

<blockquote>
<pre>
void spam(int);
void spam(unsigned short);
</pre>
</blockquote>

Here both int and unsigned short map onto a Java int. 
Here is another example:

<blockquote>
<pre>
void foo(Bar *b);
void foo(Bar &b);
</pre>
</blockquote>

If declarations such as these appear, you will get a warning message like this:

<blockquote>
<pre>
example.i:12: Warning(509): Overloaded spam(unsigned short) is shadowed by spam(int) at example.i:11.
</pre>
</blockquote>
The generated Java code will not compile either.

To fix this, you either need to ignore or rename one of the methods.  For example:

<blockquote>
<pre>
%rename(spam_short) spam(short);
...
void spam(int);    
void spam(short);   // Accessed as spam_short
</pre>
</blockquote>

or

<blockquote>
<pre>
%ignore spam(short);
...
void spam(int);    
void spam(short);   // Ignored
</pre>
</blockquote>

<P>

<a name="n25"></a><H3>14.3.13 C++ namespaces</H3>


SWIG is aware of C++ namespaces, but namespace names do not appear in
the module nor do namespaces result in a module that is broken up into
submodules or packages.  For example, if you have a file like this,

<blockquote>
<pre>
%module example

namespace foo {
   int fact(int n);
   struct Vector {
       double x,y,z;
   };
};
</pre>
</blockquote>

it works in Java as follows:

<blockquote>
<pre>
int f = example.fact(3);
Vector v = new Vector();
v.setX(3.4);
double y = v.getY();
</pre>
</blockquote>

If your program has more than one namespace, name conflicts (if any) can be resolved using <tt>%rename</tt>
For example:

<blockquote>
<pre>
%rename(Bar_spam) Bar::spam;

namespace Foo {
    int spam();
}

namespace Bar {
    int spam();
}
</pre>
</blockquote>

If you have more than one namespace and your want to keep their
symbols separate, consider wrapping them as separate SWIG modules.
Each SWIG module can be placed into a separate package.

<a name="n26"></a><H3>14.3.14 C++ templates</H3>


C++ templates don't present a huge problem for SWIG.  However, in order
to create wrappers, you have to tell SWIG to create wrappers for a particular
template instantiation.  To do this, you use the <tt>%template</tt> directive.
For example:

<blockquote>
<pre>
%module example
%{
#include "pair.h"
%}

template&lt;class T1, class T2&gt;
struct pair {
   typedef T1 first_type;
   typedef T2 second_type;
   T1 first;
   T2 second;
   pair();
   pair(const T1&, const T2&);
  ~pair();
};

%template(pairii) pair&lt;int,int&gt;;
</pre>
</blockquote>

In Java:

<blockquote>
<pre>
pairii p = new pairii(3,4);
int first = p.getFirst();
int second = p.getSecond();
</pre>
</blockquote>

Obviously, there is more to template wrapping than shown in this example.
More details can be found in the <a href="SWIGPlus.html">SWIG and C++</a> chapter.   Some more complicated
examples will appear later.

<a name="n27"></a><H2>14.4 Further details on the generated Java classes</H2>


In the previous section, a high-level view of Java wrapping was
presented.  A key component of this wrapping is that structures and
classes are wrapped by Java proxy classes and type wrapper classes are used
in situations where no proxies are generated.  This provides a very
natural, type safe Java interface to the C/C++ code and fits in nicely with the Java programing paradigm.
However, a number of low-level details were omitted.  This section provides a brief overview
of how the proxy classes work and then covers the type wrapper classes.
First the crucial JNI class is considered.

<a name="n28"></a><H3>14.4.1 The JNI class</H3>


In the <a href="SWIG.html">"SWIG basics"</a> and <a href="SWIGPlus.html">"SWIG and C++"</a> chapters,
details of low-level structure and class wrapping are described.  To summarize those chapters, if you
have a global function and class like this

<blockquote>
<pre>
class Foo {
public:
     int x;
     int spam(int num, Foo* foo);
};
void egg(Foo* chips);
</pre>
</blockquote>

then SWIG transforms the class into a set of low-level procedural wrappers.
These procedural wrappers essentially perform the equivalent of this C/C++ code:

<blockquote>
<pre>
Foo *new_Foo() {
    return new Foo();
}
void delete_Foo(Foo *f) {
    delete f;
}
int Foo_x_get(Foo *f) {
    return f->x;
}
void Foo_x_set(Foo *f, int value) {
    f->x = value;
}
int Foo_spam(Foo *f, int num, Foo* foo) {
    return f->spam(num, foo);
}
</pre>
</blockquote>

These procedural function names don't actually exist, but their functionality appears inside the generated
JNI functions. The JNI function have to follow a particular naming convention so the function names are actually:

<blockquote>
<pre>
JNIEXPORT jlong JNICALL Java_exampleJNI_new_1Foo(JNIEnv *jenv, jclass jcls);
JNIEXPORT void JNICALL Java_exampleJNI_delete_1Foo(JNIEnv *jenv, jclass jcls, jlong jarg1);
JNIEXPORT void JNICALL Java_exampleJNI_set_1Foo_1x(JNIEnv *jenv, jclass jcls, jlong jarg1, jint jarg2);
JNIEXPORT jint JNICALL Java_exampleJNI_get_1Foo_1x(JNIEnv *jenv, jclass jcls, jlong jarg1);
JNIEXPORT jint JNICALL Java_exampleJNI_Foo_1spam(JNIEnv *jenv, jclass jcls, jlong jarg1, jint jarg2, jlong jarg3);
JNIEXPORT void JNICALL Java_exampleJNI_egg(JNIEnv *jenv, jclass jcls, jlong jarg1);
</pre>
</blockquote>

For every JNI C function there has to be a static native Java function. These appear in the JNI class:

<blockquote>
<pre>
class exampleJNI {
  public final static native long new_Foo();
  public final static native void delete_Foo(long jarg1);
  public final static native void set_Foo_x(long jarg1, int jarg2);
  public final static native int get_Foo_x(long jarg1);
  public final static native int Foo_spam(long jarg1, int jarg2, long jarg3);
  public final static native void egg(long jarg1);
}
</pre>
</blockquote>

The JNI class contains the complete Java - C/C++ interface so all function calls go via the JNI class.
<p>

You may notice that SWIG uses a Java long wherever a pointer or class object needs traversing the Java-C/C++ boundary.
This approach leads to minimal JNI code which makes for better performance as JNI code involves a lot of string manipulation
SWIG uses Java code wherever possible as it is compiled into byte code which requires fewer string operations.

<p>
The functions in this class cannot be accessed outside of its package. Access to them is gained through the module class for globals otherwise the appropriate proxy class.

<p>
The name of the JNI class can be changed from its default which is the module name with JNI appended after it. The module directive attribute <code>jniclassname</code> is used to achieve this.

<blockquote>
<pre>
%module (jniclassname="name") modulename
</pre>
</blockquote>

If <code>name</code> is the same as <code>modulename</code> then the module class name gets changed
from <code>modulename</code> to <code>modulenameModule</code>.

<a name="n29"></a><H4>14.4.1.1 The JNI class pragmas</H4>


The JNI class can be tailored through the use of pragmas, but is not commonly done. The list of pragmas for the JNI class is:

<p>
<table BORDER>
<tr VALIGN=TOP>
<td><b>Pragma</b></td>
<td><b>Description</b></td>
</tr>

<tr>
    <td>jniclassbase            </td> <td>Base class for the JNI class</td>
</tr>
<tr>
    <td>jniclassclassmodifiers  </td> <td>Class modifiers for the JNI class</td>
</tr>
<tr>
    <td>jniclasscode            </td> <td>Java code is copied verbatim into the JNI class</td>
</tr>
<tr>
    <td>jniclassimports         </td> <td>Java code, usually one or more import statements, placed before the JNI class definition</td>
</tr>
<tr>
    <td>jniclassinterfaces      </td> <td>Comma separated interface classes for the JNI class</td>
</tr>
</table>

<p>
The pragma code appears in the JNI class where you would expect it to so that the pragmas appear in the generated class like this:

<blockquote>
<pre>
[ jniclassimports pragma ]
[ jniclassmodifiers pragma ] class jniclassname extends [ jniclassbase pragma ] implements [ jniclassinterfaces pragma ] {
[ jniclasscode pragma ]
... SWIG generated native functions ...
}
</pre>
</blockquote>

The <tt>jniclasscode</tt> pragma is quite useful for adding in a static block for loading the shared object / dynamic link library and demonstrates how the pragmas work:

<blockquote>
<pre>
%pragma(java) jniclasscode=%{
  static {
    try {
        System.loadLibrary("example");
    } catch (UnsatisfiedLinkError e) {
      System.err.println("Native code library failed to load. \n" + e);
      System.exit(1);
    }
  }
%}
</pre>
</blockquote>

Pragmas will take either <tt>""</tt> or <tt>%{ %}</tt> as delimeters. 
For example, let's change the JNI class access attribute to public. All the methods in the JNI class will then be callable outside of its package:

<blockquote>
<pre>
%pragma(java) jniclassclassmodifiers="public"
</pre>
</blockquote>


<a name="n30"></a><H3>14.4.2 The Java module class</H3>


All global functions and variable getters/setters appear in the module class. For our example, there is just one function:

<blockquote>
<pre>
public class example {
  public static void egg(Foo chips) {
    exampleJNI.egg(Foo.getCPtr(chips));
  }
}
</pre>
</blockquote>

The module class is necessary as there is no such thing as a global in Java so all the C globals are put into this class. They are generated as static functions and so must be accessed as such by using the module name in the static function call:

<blockquote>
<pre>
example.egg(new Foo());
</pre>
</blockquote>

The primary reason for having the module class wrapping the calls in the JNI class is to implement static type checking. In this case only a <tt>Foo</tt> can be passed to the <tt>egg</tt> function, whereas any <tt>long</tt> can be passed to the <tt>egg</tt> function in the JNI class.

<a name="n31"></a><H4>14.4.2.1 The Java module class pragmas</H4>


The module class can be tailored through the use of pragmas, in the same manner as the JNI class. The pragmas are similarly named and are used in the same way. The complete list follows:

<p>
<table BORDER>
<tr VALIGN=TOP>
<td><b>Pragma</b></td>
<td><b>Description</b></td>
</tr>
<tr>
    <td>modulebase            </td> <td>Base class for the module class</td>
</tr>
<tr>
    <td>moduleclassmodifiers  </td> <td>Class modifiers for the module class</td>
</tr>
<tr>
    <td>modulecode            </td> <td>Java code is copied verbatim into the module class</td>
</tr>
<tr>
    <td>moduleimports         </td> <td>Java code, usually one or more import statements, placed before the module class definition</td>
</tr>
<tr>
    <td>moduleinterfaces      </td> <td>Comma separated interface classes for the module class</td>
</tr>

</table>

<p>

The pragma code appears in the generated module class like this:

<blockquote>
<pre>
[ moduleimports pragma ]
[ modulemodifiers pragma ] class modulename extends [ modulebase pragma ] implements [ moduleinterfaces pragma ] {
[ modulecode pragma ]
... SWIG generated wrapper functions ...
}
</pre>
</blockquote>

<a name="n32"></a><H3>14.4.3 Java proxy classes</H3>


A Java proxy class is generated for each structure, union or C++ class that is wrapped.
The default proxy class for our previous example looks like this:

<blockquote>
<pre>
public class Foo {
  private long swigCPtr;
  protected boolean swigCMemOwn;

  protected Foo(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected void finalize() {
    delete();
  }

  public void delete() {
    if(swigCPtr != 0 && swigCMemOwn) {
      exampleJNI.delete_Foo(swigCPtr);
      swigCMemOwn = false;
    }
    swigCPtr = 0;
  }

  protected static long getCPtr(Foo obj) {
    return obj.swigCPtr;
  }

  public void setX(int x) {
    exampleJNI.set_Foo_x(swigCPtr, x);
  }

  public int getX() {
    return exampleJNI.get_Foo_x(swigCPtr);
  }

  public int spam(int num, Foo foo) {
    return exampleJNI.Foo_spam(swigCPtr, num, Foo.getCPtr(foo));
  }

  public Foo() {
    this(exampleJNI.new_Foo(), true);
  }
}
</pre>
</blockquote>


This class merely holds a pointer to the underlying C++ object (<tt>swigCPtr</tt>).
It also contains all the methods in the C++ class it is proxying plus getters and setters for public
member variables. These functions call the native methods in the JNI class. 
The advantage of having this extra layer is the type safety that the proxy class functions offer. 
It adds static type checking which leads to fewer surprises at runtime. 
For example, you can see that if you attempt to use the <tt> spam() </tt> 
function it will only compile when the parameters passed are an <tt>int</tt> and a <tt>Foo</tt>. 
From a user's point of view, it makes the class work as if it were a Java class:

<blockquote>
<pre>
Foo f = new Foo();
f.setX(3);
int y = f.spam(5, new Foo());
</pre>
</blockquote>

<a name="n33"></a><H4>14.4.3.1 Memory management</H4>


Each proxy class has an ownership flag <tt>swigCMemOwn</tt>.   The value of this
flag determines who is responsible for deleting the underlying C++ object.   If set to <tt>true</tt>,
the proxy class's finalizer will destroy the C++ object when the proxy class is 
garbage collected.   If set to false, then the destruction of the proxy class has no effect on the C++ object.

<P>
When an object is created by a constructor or returned by value, Java automatically takes
ownership of the result. 
On the other hand, when pointers or references are returned to Java, there is often no way to know where
they came from.  Therefore, the ownership is set to zero.  For example:


<blockquote>
<pre>
class Foo {
public:
    Foo();
    Foo bar1();
    Foo &bar2();
    Foo *bar2();
};
</pre>
</blockquote>

In Java:

<blockquote>
<pre>
Foo f = new Foo();   //  f.swigCMemOwn = true
Foo f1 = f.bar1();   // f1.swigCMemOwn = true
Foo f2 = f.bar2();   // f2.swigCMemOwn = false
Foo f3 = f.bar3();   // f3.swigCMemOwn = false
</pre>
</blockquote>

This behavior for pointers and references is especially important for classes that act as containers.  
For example, if a method returns a pointer to an object
that is contained inside another object, you definitely don't want
Java to assume ownership and destroy it!

<p>
For the most part, memory management issues remain hidden.  However,
there are situations where you might have to manually
change the ownership of an object.  For instance, consider code like this:

<blockquote>
<pre>
class Obj {};
class Node {
   Obj *value;
public:
   void set_value(Obj *v) { value = v; }
};
</pre>
</blockquote>

Now, consider the following Java code:

<blockquote>
<pre>
Node n = new Node();    // Create a node
{
  Obj o = new Obj();    // Create an object
  n.set_value(o);       // Set value
}                       // o goes out of scope
</pre>
</blockquote>

In this case, the Node <tt>n</tt> is holding a reference to
<tt>o</tt> internally.  However, SWIG has no way to know that this
has occurred.  The Java proxy class still thinks that it has ownership of 
<tt>o</tt>.  As <tt>o</tt> has gone out of scope, it could be garbage collected in which case the C++ destructor
will be invoked and <tt>n</tt> will then be holding a stale-pointer to <tt>o</tt>.  If
you're lucky, you will only get a segmentation fault.

<p>
To work around this, the ownership flag of <tt>o</tt> needs changing to <tt>false</tt>. 
The ownership flag is a private member variable of the proxy class so this is not possible without some customization of the proxy class. 
This is achieved using a typemap to add pure Java code to the proxy class and is detailed later in the section on typemaps.

<p>
Sometimes a function will create memory and return a pointer to a newly allocated object. 
SWIG has no way of knowing this so by default the proxy class does not manage the returned object.
However, you can tell the proxy class to manage the memory if you specify the <code>%newobject</code> directive. Consider:

<blockquote>
<pre>
class Obj {...};
class Factory {
public:
    static Obj *createObj() { return new Obj(); }
};
</pre>
</blockquote>

If we call the factory function, then we have to manually delete the memory:

<blockquote>
<pre>
Obj obj = Factory.createObj();   // obj.swigCMemOwn = false
...
obj.delete();
</pre>
</blockquote>

Now add in the %newobject directive:

<blockquote>
<pre>
%newobject Factory::createObj();

class Obj {};
class Factory {
public:
    static Obj *createObj() { return new Obj(); }
};
</pre>
</blockquote>

No call to <code>delete()</code> is needed as the garbage collector will make the C++ destructor call because <code>swigCMemOwn</code> is now true.

<blockquote>
<pre>
Obj obj = Factory.createObj();   // obj.swigCMemOwn = true;
...
</pre>
</blockquote>


<a name="n34"></a><H4>14.4.3.2 Inheritance</H4>


Java proxy classes will mirror C++ inheritance chains. For example, given the base class <tt>Base</tt> and its derived class </tt>Derived</tt>:

<blockquote><pre>
class Base {
public:
  virtual double foo();
};

class Derived : public Base {
public:
  virtual double foo();
};
</pre></blockquote>

The base class is generated much like any other proxy class seen so far:

<blockquote><pre>
public class Base {
  private long swigCPtr;
  protected boolean swigCMemOwn;

  protected Base(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected void finalize() {
    delete();
  }

  public void delete() {
    if(swigCPtr != 0 && swigCMemOwn) {
      exampleJNI.delete_Base(swigCPtr);
      swigCMemOwn = false;
    }
    swigCPtr = 0;
  }

  protected static long getCPtr(Base obj) {
    return obj.swigCPtr;
  }

  public double foo() {
    return exampleJNI.Base_foo(swigCPtr);
  }

  public Base() {
    this(exampleJNI.new_Base(), true);
  }
}
</pre></blockquote>

The <tt>Derived</tt> class extends <tt>Base</tt> mirroring the C++ class inheritance hierarchy. 

<blockquote><pre>
public class Derived extends Base {
  private long swigCPtr;

  protected Derived(long cPtr, boolean cMemoryOwn) {
    super(exampleJNI.SWIGDerivedToBase(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }

  protected void finalize() {
    delete();
  }

  public void delete() {
    if(swigCPtr != 0 && swigCMemOwn) {
      exampleJNI.delete_Derived(swigCPtr);
      swigCMemOwn = false;
      super.delete();
    }
    swigCPtr = 0;
  }

  protected static long getCPtr(Derived obj) {
    return obj.swigCPtr;
  }

  public double foo() {
    return exampleJNI.Derived_foo(swigCPtr);
  }

  public Derived() {
    this(exampleJNI.new_Derived(), true);
  }
}
</pre></blockquote>

Note the memory ownership is controlled by the base class. 
However each class in the inheritance hierarchy has its own pointer value which is obtained during construction. 
The <tt>SWIGDerivedToBase()</tt> call converts the pointer from a <tt>Derived*</tt> to a <tt>Base*</tt> as C++ compilers are free to implement 
pointers in the inheritance hierarchy with different values. 

<p>

It is of course possible to extend <tt>Base</tt> using your own Java classes. 
If <tt>Derived</tt> is provided by the C++ code, you could for example add in a pure Java class <tt>Extended</tt> derived from <tt>Base</tt>. 
There is a caveat and that is any C++ code will not know about your Java class <tt>Rectangle</tt> so this type of derivation is restricted.<p>


<a name="n35"></a><H4>14.4.3.3 Proxy classes and garbage collection</H4>


By default each proxy class has a <code>delete()</code> and <code>finalize()</code> methods. 
The <code>finalize()</code> method calls <code>delete()</code> which frees any malloc'd memory for wrapped C structs or calls the C++ class destructors. 
The idea is for <code>delete()</code> to be called when you have finished with the C/C++ object. 
Ideally you need not call <code>delete()</code>, but rather leave it to the garbage collector to call it from the finalizer. 
The unfortunate thing is that Sun, in their wisdom, do not guarantee that the finalizers will be called. 
When a program exits, the garbage collector does not always call the finalizers. 
Depending on what the finalizers do and which operating system you use, this may or may not be a problem. 
<p>

If the <code>delete()</code> call into JNI code is just for memory handling, there is not a problem when run on Windows and Unix. 
Say your JNI code creates memory on the heap which your finalizers will clean up, the finalizers may or may not be called before the program exits. 
In Windows and Unix all memory that a process uses is returned to the system on exit, so this isn't a problem. 
This is not the case in some operating systems like vxWorks. 
If however, your finalizer calls into JNI code invoking the C++ destructor which in turn releases a TCP/IP socket for example, there is no guarantee that it will be released. 
Note that the garbage collector will eventually run, so long running programs will have their unreferenced object's finalizers called.
<p>

Some not so ideal solutions are:
<ol>
<li start=1>
Call the <code>System.runFinalizersOnExit(true)</code> or <code>Runtime.getRuntime().runFinalizersOnExit(true)</code> to ensure the finalizers are called before the program exits. The catch is that this is a deprecated function call as the documenation says: 
<blockquote><i>
This method is inherently unsafe. It may result in finalizers being called on live objects while other threads are concurrently manipulating those objects, resulting in erratic behavior or deadlock.
</i></blockquote> 
In many cases you will be lucky and find that it works, but it is not to be advocated. 
Have a look at <a href=http://java.sun.com>Sun's Java web site</a> and search for <code>runFinalizersOnExit</code>.
</li>
<p>
<li>
From jdk1.3 onwards a new function, <code>addShutdownHook()</code>, was introduced which is guaranteed to be called when your program exits. 
You can encourage the garbage collector to call the finalizers, for example, add this static block to the class that has the <code>main()</code> function: 
<blockquote><pre>
  static {
    Runtime.getRuntime().addShutdownHook( 
      new Thread() {
        public void run() { System.gc(); System.runFinalization(); }
      }
    );
  }
</pre></blockquote>
Although this usually works, the documentation doesn't guarantee that <code>runFinalization()</code> will actually call the finalizers. 
As the the shutdown hook is guaranteed you could also make a JNI call to clean up any resources that are being tracked by the C/C++ code.
</li>
<p>
<li>
Call the <code>delete()</code> function manually. 
As a suggestion it may be a good idea to set the object to null so that should the object be inadvertantly used again a Java null pointer exception is thrown, the alternative would crash the JVM by using a null C pointer. 
For example given a SWIG generated class A:
<blockquote><pre>
A myA = new A();
// use myA ...
myA.delete();
// any use of myA here would crash the JVM 
myA=null;
// any use of myA here would cause a Java null pointer exception to be thrown
</pre></blockquote>
The SWIG generated code ensures that the memory is not deleted twice, in the event the finalizers get called in addition to the manual <code>delete()</code> call.
</li>

<p>
<li>
Write your own object manager in Java. 
You could derive all SWIG classes from a single base class which could track which objects have had their finalizers run, then call the rest of them on program termination.
The section on <a href=#n9929>Java typemaps</a> details how this can be done.
</li>
</ol>

<a name="n36"></a><H3>14.4.4 Type wrapper classes</H3>


The generated type wrapper class, for say an <tt>int *</tt>, looks like this:

<blockquote><pre>
public class SWIGTYPE_p_int {
  private long swigCPtr;

  protected SWIGTYPE_p_int(long cPtr, boolean bFutureUse) {
    swigCPtr = cPtr;
  }

  protected SWIGTYPE_p_int() {
    swigCPtr = 0;
  }

  protected static long getCPtr(SWIGTYPE_p_int obj) {
    return obj.swigCPtr;
  }
}
</pre></blockquote>

The methods do not have public access, so by default it is impossible to do anything with objects of this class other than 
pass them around. The methods in the class are part of the inner workings of SWIG. 
If you need to mess around with pointers, even create a null pointer, you will have to use some special typemaps to achieve this and is covered in the typemaps section.

<p>
Note that if you use a pointer or reference to a proxy class in a function then no type wrapper class is generated because the proxy class can be used
as the function function parameter. If however,  you need anything more complicated like a pointer to a pointer to a proxy class then a typewrapper class
is generated for your use. 
<p>

Note that SWIG generates a type wrapper class and not a proxy class when it has not parsed the definition of a type that gets used. 
For example, say SWIG has not parsed the definition of <tt>class Snazzy</tt> because it is in a header file that you may have forgotten to use the <tt>%include</tt> directive on.
Should SWIG parse <tt>Snazzy *</tt> being used in a function parameter, it will then generates a type wrapper class around a <tt>Snazzy</tt> pointer.
Also recall from earlier that SWIG will use a pointer when a class is passed by value or by reference:

<blockquote>
<pre>
void spam(Snazzy *x, Snazzy &y, Snazzy z);
</pre>
</blockquote>

Should SWIG not know anything about <tt>Snazzy</tt> then a <tt>SWIGTYPE_p_Snazzy</tt> must be used for all 3 parameters in the <tt>spam</tt> function.

<p>

<a name="n37"></a><H2>14.5 Common customization features</H2>


The last section presented the absolute basics of C/C++ wrapping. If you do nothing
but feed SWIG a header file, you will get an interface that mimics the behavior
described.  However, sometimes this isn't enough to produce a nice module.  Certain
types of functionality might be missing or the interface to certain functions might
be awkward.  This section describes some common SWIG features that are used
to improve the interface to existing C/C++ code.

<a name="n38"></a><H3>14.5.1 C/C++ helper functions</H3>


Sometimes when you create a module, it is missing certain bits of functionality. For
example, if you had a function like this

<blockquote>
<pre>
typedef struct Image {...};
void set_transform(Image *im, double m[4][4]);
</pre>
</blockquote>

it would be accessible from Java, but there may be no easy way to call it.
The problem here is that there is no easy way to construct and manipulate a suitable
<tt>double [4][4]</tt> value to use.   To fix this, you can write some extra C helper
functions.  Just use the <tt>%inline</tt> directive. For example:

<blockquote>
<pre>
%inline %{
/* Note: double[4][4] is equivalent to a pointer to an array double (*)[4] */
double (*new_mat44())[4] {
   return (double (*)[4]) malloc(16*sizeof(double));
}
void free_mat44(double (*x)[4]) {
   free(x);
}
void mat44_set(double x[4][4], int i, int j, double v) {
   x[i][j] = v;
}
double mat44_get(double x[4][4], int i, int j) {
   return x[i][j];
}
%}
</pre>
</blockquote>

From Java, you could then write code like this:

<blockquote>
<pre>
Image im = new Image();
SWIGTYPE_p_a_4__double a = example.new_mat44();
example.mat44_set(a,0,0,1.0);
example.mat44_set(a,1,1,1.0);
example.mat44_set(a,2,2,1.0);
...
example.set_transform(im,a);
example.free_mat44(a);
</pre>
</blockquote>

Admittedly, this is not the most elegant looking approach.  However, it works and it wasn't too
hard to implement.  It is possible to improve on this using Java code, typemaps, and other
customization features as covered in later sections, but sometimes helper functions are a quick and easy solution to difficult cases.  

<a name="n39"></a><H3>14.5.2 Class extension with %extend</H3>


One of the more interesting features of SWIG is that it can extend
structures and classes with new methods or constructors.
Here is a simple example:

<blockquote>
<pre>
%module example
%{
#include "someheader.h"
%}

struct Vector {
   double x,y,z;
};

%extend Vector {
   char *toString() {
       static char tmp[1024];
       sprintf(tmp,"Vector(%g,%g,%g)", self->x,self->y,self->z);
       return tmp;
   }
   Vector(double x, double y, double z) {
       Vector *v = (Vector *) malloc(sizeof(Vector));
       v->x = x;
       v->y = y;
       v->z = z;
       return v;
   }
};
</pre>
</blockquote>

Now, in Java

<blockquote>
<pre>
Vector v = new Vector(2,3,4);
System.out.println(v);
</pre>
</blockquote>
will display

<blockquote>
<pre>
Vector(2,3,4)
</pre>
</blockquote>

<tt>%extend</tt> works with both C and C++ code.  It does not modify the underlying object
in any way---the extensions only show up in the Java interface.

<a name="n40"></a><H3>14.5.3 Exception handling with %exception</H3>


If a C or C++ function throws an error, you may want to convert that error into a Java
exception. To do this, you can use the <tt>%exception</tt> directive.  <tt>%exception</tt>
simply lets you rewrite part of the generated wrapper code to include an error check.

<p>
In C, a function often indicates an error by returning a status code (a negative number
or a NULL pointer perhaps).  Here is a simple example of how you might handle that:

<blockquote>
<pre>
%exception malloc {
  $action
  if (!result) {
    jclass clazz = jenv->FindClass("java/lang/OutOfMemoryError");
    jenv->ThrowNew(clazz, "Not enough memory");
    return $null;
  }
}
void *malloc(size_t nbytes);
</pre>
</blockquote>

In Java,

<blockquote>
<pre>
SWIGTYPE_p_void a = example.malloc(2000000000);
</pre>
</blockquote>

will produce a familiar looking Java exception:

<blockquote>
<pre>
Exception in thread "main" java.lang.OutOfMemoryError: Not enough memory
        at exampleJNI.malloc(Native Method)
        at example.malloc(example.java:16)
        at main.main(main.java:112)
</pre>
</blockquote>

If a library provides some kind of general error handling framework, you can also use
that.  For example:

<blockquote>
<pre>
%exception {
  $action
  if (err_occurred()) {
    jclass clazz = jenv->FindClass("java/lang/RuntimeException");
    jenv->ThrowNew(clazz, err_message());
    return $null;
  }
}
</pre>
</blockquote>

No declaration name is given to <tt>%exception</tt>, it is applied to all wrapper functions.
The <tt> $action </tt> is a SWIG special variable and is replaced by the C/C++ function call being wrapped.
The <tt> return $null; </tt> handles all JNI function return types, namely those that are have a void return and those that do not. 
This is useful for typemaps that will be used in JNI functions returning all return types. 
See the section on
<a href="#n33">Typemap variables</a> for further explanation.

<p>
C++ exceptions are also easy to handle.  
We can catch the C++ exception and rethrow it as a Java exception like this:<p>

<blockquote>
<pre>
%exception getitem {
  try {
     $action
  } catch (std::out_of_range &e) {
    jclass clazz = jenv->FindClass("java/lang/Exception");
    jenv->ThrowNew(clazz, "Range error");
    return $null;
   }
}

class Base {
public:
     Foo *getitem(int index);      // Exception handler added
     ...
};
</pre>
</blockquote>

The examples above use the C++ JNI calling syntax as opposed to the C calling syntax and so will not compile as C.
It is however possible to write JNI calls which will compile under both C and C++ and is covered in <a href="#n34">typemaps for both C and C++ compilation</a>. 

<p>
The language-independent <tt>exception.i</tt> library file can also be used
to raise exceptions.  See the <a href="Library.html">SWIG Library</a> chapter.

<a name="n41"></a><H2>14.6 Tips and techniques</H2>


Although SWIG is largely automatic, there are certain types of wrapping problems that
require additional user input.    Examples include dealing with output parameters,
strings and arrays.   This chapter discusses the common techniques for
solving these problems.

<a name="n42"></a><H3>14.6.1 Input and output parameters</H3>


A common problem in some C programs is handling parameters passed as simple pointers.  For
example:

<blockquote>
<pre>
void add(int x, int y, int *result) {
   *result = x + y;
}
</pre>
</blockquote>

or perhaps

<blockquote>
<pre>
int sub(int *x, int *y) {
   return *x-*y;
}
</pre>
</blockquote>

The <tt>typemaps.i</tt> file will help in these situations.  For example:

<blockquote>
<pre>
%module example
%include "typemaps.i"

void add(int, int, int *OUTPUT);
int  sub(int *INPUT, int *INPUT);
</pre>
</blockquote>

In Java, this allows you to pass simple values.  For example:

<blockquote>
<pre>
int result = example.sub(7,4);
System.out.println("7 - 4 = " + result);
int[] sum = {0};
example.add(3,4,sum);
System.out.println("3 + 4 = " + sum[0]);
</pre>
</blockquote>

Which will display:
<blockquote> <pre>
7 - 4 = 3
3 + 4 = 7
</pre></blockquote>

Notice how the <tt>INPUT</tt> parameters allow integer values to be passed instead of pointers
and how the <tt>OUTPUT</tt> parameter will return the result in the first element of the integer array.

<p>
If you don't want to use the names <tt>INPUT</tt> or <tt>OUTPUT</tt>, use the <tt>%apply</tt>
directive.  For example:

<blockquote>
<pre>
%module example
%include "typemaps.i"

%apply int *OUTPUT { int *result };
%apply int *INPUT  { int *x, int *y};

void add(int x, int y, int *result);
int  sub(int *x, int *y);
</pre>
</blockquote>

<p>
If a function mutates one of its parameters like this,

<blockquote>
<pre>
void negate(int *x) {
   *x = -(*x);
}
</pre>
</blockquote>

you can use <tt>INOUT</tt> like this:

<blockquote>
<pre>
%include "typemaps.i"
...
void negate(int *INOUT);
</pre>
</blockquote>

In Java, the input parameter is the first element in a 1 element array and is replaced by the output of the function. For example:

<blockquote>
<pre>
int[] neg = {3};
example.negate(neg);
System.out.println("Negative of 3 = " + neg[0]);
</pre>
</blockquote>

And no prizes for guessing the output:
<blockquote><pre>
Negative of 3 = -3
</pre></blockquote>

Note: Since most Java primitive types are immutable and are passed by value, it is not possible to
perform in-place modification of type passed as a parameter.

<p>
Be aware that the primary purpose of the <tt>typemaps.i</tt> file is to support primitive datatypes.
Writing a function like this

<blockquote>
<pre>
void foo(Bar *OUTPUT);
</pre>
</blockquote>

will not have the intended effect since <tt>typemaps.i</tt> does not define an OUTPUT rule for <tt>Bar</tt>.

<a name="n43"></a><H3>14.6.2 Simple pointers</H3>


If you must work with simple pointers such as <tt>int *</tt> or <tt>double *</tt> another approach to using 
<tt>typemaps.i</tt> is to use the <tt>cpointer.i</tt> pointer library file.    For example:

<blockquote>
<pre>
%module example
%include "cpointer.i"

extern void add(int x, int y, int *result);
%pointer_functions(int, intp);
</pre>
</blockquote>

The <tt>%pointer_functions(type,name)</tt> macro generates five helper functions that can be used to create,
destroy, copy, assign, and dereference a pointer.  In this case, the functions are as follows:

<blockquote>
<pre>
int  *new_intp();
int  *copy_intp(int *x);
void  delete_intp(int *x);
void  intp_assign(int *x, int value);
int   intp_value(int *x);
</pre>
</blockquote>

In Java, you would use the functions like this:

<blockquote>
<pre>
SWIGTYPE_p_int intPtr = example.new_intp();
example.add(3,4,intPtr);
int result = example.intp_value(intPtr);
System.out.println("3 + 4 = " + result);
</pre>
</blockquote>

If you replace <tt>%pointer_functions(int,intp)</tt> by <tt>%pointer_class(int,intp)</tt>, the interface is more class-like.

<blockquote>
<pre>
intp intPtr = new intp();
example.add(3,4,intPtr.cast());
int result = intPtr.value();
System.out.println("3 + 4 = " + result);
</pre>
</blockquote>

See the <a href="Library.html">SWIG Library</a> chapter for further details.

<a name="n44"></a><H3>14.6.3 Unbounded C Arrays</H3>


Sometimes a C function expects an array to be passed as a pointer.  For example,

<blockquote>
<pre>
int sumitems(int *first, int nitems) {
    int i, sum = 0;
    for (i = 0; i < nitems; i++) {
        sum += first[i];
    }
    return sum;
}
</pre>
</blockquote>

One of the ways to do this is to apply the array typemaps that come with SWIG:

<blockquote>
<pre>
%apply int[ANY] {int *};
</pre>
</blockquote>

You can then use a pure Java array and pass it to the C code:

<blockquote>
<pre>
int[] array = new int[10000000];          // Array of 10-million integers
for (int i=0; i<array.length; i++) {      // Set some values
  array[i] = i;
}
int sum = example.sumitems(array,10000);
System.out.println("Sum = " + sum);
</pre>
</blockquote>

and the sum would be displayed:

<blockquote>
<pre>
Sum = 49995000
</pre>
</blockquote>

This approach is probably the most natural way to use arrays.
However, it suffers from performance problems when using large arrays as a lot of copying
of the elements occurs in transferring the array from the Java world to the C++ world.
A alternative way to do this is to use the <tt>carrays.i</tt> library file.
For example:

<blockquote>
<pre>
%include "carrays.i"
%array_functions(int, intArray);
</pre>
</blockquote>

The <tt>%array_functions(type,name)</tt> macro generates five helper functions that can be used to create,
destroy, copy, assign, and dereference a pointer.  In this case, the functions are as follows:

<blockquote>
<pre>
int *new_intArray(int nelements);
void delete_intArray(int *x);
int intArray_getitem(int *x, int index);
void intArray_setitem(int *x, int index, int value);
</pre>
</blockquote>

In Java, you would use the functions like this:

<blockquote>
<pre>
SWIGTYPE_p_int array = example.new_intArray(10000000);  // Array of 10-million integers
for (int i=0; i<10000; i++) {                           // Set some values
    example.intArray_setitem(array,i,i);
}
int sum = example.sumitems(array,10000);
System.out.println("Sum = " + sum);
</pre>
</blockquote>

If you replace <tt>%array_functions(int,intp)</tt> by <tt>%array_class(int,intp)</tt>, the interface is more class-like.

<blockquote>
<pre>
%include "carrays.i"
%array_class(int, intArray);
</pre>
</blockquote>

The <tt>%array_class(type, name)</tt> macro creates wrappers for an unbounded array object that
can be passed around as a simple pointer like <tt>int *</tt> or <tt>double *</tt>.
For instance, you will be able to do this in Java:

<blockquote>
<pre>
intArray array = new intArray(10000000);  // Array of 10-million integers
for (int i=0; i<10000; i++) {             // Set some values
    array.setitem(i,i);
}
int sum = example.sumitems(array.cast(),10000);
System.out.println("Sum = " + sum);
</pre>
</blockquote>

The array "object" created by <tt>%array_class()</tt> does not
encapsulate pointers inside a special array object.  In fact, there is
no bounds checking or safety of any kind (just like in C).  Because of
this, the arrays created by this library are extremely low-level
indeed.  You can't iterate over them nor can you even query their
length.  In fact, any valid memory address can be accessed if you want
(negative indices, indices beyond the end of the array, etc.).
Needless to say, this approach is not going to suit all applications.
On the other hand, this low-level approach is extremely efficient and
well suited for applications in which you need to create buffers,
package binary data, etc.

<a name="n45"></a><H2>14.7 Java typemaps</H2>


This section describes how you can modify SWIG's default wrapping behavior
for various C/C++ datatypes using the <tt>%typemap</tt> directive.   
You are also advised to be familiar with the the material in the "<a href="Typemaps.html">Typemaps</a>" chapter.
While not absolutely essential knowledge, this section assumes some familiarity with the Java Native Interface (JNI). 
JNI documentation can be consulted either online at <a href=http://java.sun.com>Sun's Java web site</a> or from a good JNI book. 
The following two books are recommended:<p>
<ul>
<li> Title: 'Essential JNI: Java Native Interface.' Author: Rob Gordon. Publisher: Prentice Hall. ISBN: 0-13-679895-0.  </li>
<li> Title: 'The Java Native Interface: Programmer's Guide and Specification.' Author: Sheng Liang. Publisher: Addison-Wesley. ISBN: 0-201-32577-2.  </li>
</ul>

<p>
Before proceeding, it should be stressed that typemaps are not a required 
part of using SWIG---the default wrapping behavior is enough in most cases.
Typemaps are only used if you want to change some aspect of the generated code.

<a name="n46"></a><H3>14.7.1 Default primitive type mappings</H3>


The following table lists the default type mapping from Java to C/C++.<p>
<table BORDER>
<tr>
<td><b>C/C++ type</b></td>
<td><b>Java type</b></td>
<td><b>JNI type</b></td>
</tr>

<tr>
<td>bool<br> const bool & </td>
<td>boolean</td>
<td>jboolean</td>
</tr>

<tr>
<td>char<br>const char &</td>
<td>char</td>
<td>jchar</td>
</tr>

<tr>
<td>signed char<br>const signed char &</td>
<td>byte</td>
<td>jbyte</td>
</tr>

<tr>
<td>unsigned char<br>const unsigned char &</td>
<td>short</td>
<td>jshort</td>
</tr>

<tr>
<td>short<br>const short &</td>
<td>short</td>
<td>jshort</td>
</tr>

<tr>
<td>unsigned short<br> const unsigned short &</td>
<td>int</td>
<td>jint</td>
</tr>

<tr>
<td>int<br> const int &</td>
<td>int</td>
<td>jint</td>
</tr>

<tr>
<td>unsigned int<br> const unsigned int &</td>
<td>long</td>
<td>jlong</td>
</tr>

<tr>
<td>long<br>const long &</td>
<td>int</td>
<td>jint</td>
</tr>

<tr>
<td>unsigned long<br>const unsigned long &</td>
<td>long</td>
<td>jlong</td>
</tr>

<tr>
<td>long long<br> const long long &</td>
<td>long</td>
<td>jlong</td>
</tr>

<tr>
<td>unsigned long long<br>const unsigned long long &</td>
<td>java.math.BigInteger</td>
<td>jobject</td>
</tr>

<tr>
<td>float<br>const float &</td>
<td>float</td>
<td>jfloat</td>
</tr>

<tr>
<td>double<br> const double &</td>
<td>double</td>
<td>jdouble</td>
</tr>

<tr>
<td>char*</td>
<td>String</td>
<td>jstring</td>
</tr>

</table>
<br>
Arrays are implemented using the same mappings, for example a C array, <tt>unsigned short[SIZE]</tt>, is mapped to a Java array, <tt>int[SIZE]</tt>. 
Note that SWIG treats the C <tt>char</tt> type as a character and <tt>char*</tt> as a string. 
The <tt>signed char</tt> type can be used if you want to treat <tt>char</tt> as a signed number rather than a character.
Also note that all const references to primitive types are treated as if they are passed by value.
<p>

Given the following C function:
<blockquote> <pre>
void func(unsigned short a, char *b, const long &c, double d[], unsigned long long e);
</blockquote> </pre>
The module class method would be:
<blockquote> <pre>
public static void func(int a, String b, int c, double[] d, java.math.BigInteger e) {...}
</blockquote> </pre>
The JNI class would use the same types:
<blockquote> <pre>
public final static native void func(int jarg1, String jarg2, int jarg3, double[] jarg4, java.math.BigInteger jarg5);
</blockquote> </pre>
and the JNI function would look like this:
<blockquote> <pre>
JNIEXPORT void JNICALL Java_exampleJNI_func(JNIEnv *jenv, jclass jcls, jint jarg1, jstring jarg2, jint jarg3, jdoubleArray jarg4, jobject jarg5) {...}
</blockquote> </pre>
<p>

The mappings for C int and C long are appropriate for 32 bit applications which are used in the 32 bit JVMs. 
There is no perfect mapping between Java and C as Java doesn't support all the unsigned C data types. 
However, the mappings allow the full range of values for each C type from Java. 
<p>

<a name="n47"></a><H3>14.7.2 bit JVMs</H3>


If you are using a 64 bit JVM you may have to override the C long, but probably not C int default mappings. 
Mappings will be system dependent, for example long will need remapping on Unix LP64 systems (long, pointer 64 bits, int 32 bits), but not on 
Microsoft 64 bit Windows which will be using a P64 IL32 (pointer 64 bits and int, long 32 bits) model. 
This may be automated in a future version of SWIG. 
Note that the Java write once run anywhere philosophy holds true for all pure Java code when moving to a 64 bit JVM. 
Unfortunately it won't of course hold true for JNI code.


<a name="n48"></a><H3>14.7.3 What is a typemap?</H3>


A typemap is nothing more than a code generation rule that is attached to 
a specific C datatype.   For example, to convert integers from Java to C,
you might define a typemap like this:

<p>
<blockquote><pre>%module example

%typemap(in) int {
	$1 = (int) PyLong_AsLong($input);
	printf("Received an integer : %d\n",$1);
}
extern int fact(int n);
</pre></blockquote>

<p>
Typemaps are always associated with some specific aspect of code generation.
In this case, the "in" method refers to the conversion of input arguments
to C/C++.  The datatype <tt>int</tt> is the datatype to which the typemap
will be applied.  The supplied C code is used to convert values.  In this
code a number of special variables prefaced by a <tt>$</tt> are used.  The
<tt>$1</tt> variable is a placeholder for a local variable of type <tt>int</tt>.
The <tt>$input</tt> variable is the input object of type <tt>PyObject *</tt>.
The <tt>$input</tt> variable <tt>$input</tt> contains the Java data, the JNI <tt>jint</tt> in this case.

<p>

When this example is compiled into a Java module, it can be used as follows:<p>
<p>
<blockquote><pre>
System.out.println(example.fact(6));
</pre></blockquote>
and the output will be:
<blockquote><pre>
Received an integer : 6
720
</pre></blockquote>

In this example, the typemap is applied to all occurrences of the <tt>int</tt> datatype.
You can refine this by supplying an optional parameter name.  For example:

<blockquote><pre>
%module example

%typemap(in) int n {
  $1 = $input;
  printf("Received an integer : %d\n",  $1);
}

extern int fact(int n);
</pre></blockquote>

In this case, the typemap code is only attached to arguments that exactly match <tt>int n</tt>.

<p>
The application of a typemap to specific datatypes and argument names involves
more than simple text-matching--typemaps are fully integrated into the
SWIG type-system.   When you define a typemap for <tt>int</tt>, that typemap
applies to <tt>int</tt> and qualified variations such as <tt>const int</tt>.  In addition,
the typemap system follows <tt>typedef</tt> declarations.  For example:

<blockquote>
<pre>
%typemap(in) int n {
  $1 = $input;
  printf("Received an integer : %d\n",  $1);
}
typedef int Integer;
extern int fact(Integer n);    // Above typemap is applied
</pre>
</blockquote>

However, the matching of <tt>typedef</tt> only occurs in one direction.  If you
defined a typemap for <tt>Integer</tt>, it is not applied to arguments of
type <tt>int</tt>.

<p>
Typemaps can also be defined for groups of consecutive arguments.  For example:

<blockquote>
<pre>
%typemap(in) (char *str, int len) {
...
};

int count(char c, char *str, int len);
</pre>
</blockquote>

When a multi-argument typemap is defined, the arguments are always handled as a single
Java parameter.  This allows the function to be used like this (notice how the length
parameter is omitted):

<blockquote>
<pre>
int c = example.count('e',"Hello World");
</pre>
</blockquote>

<a name="n49"></a><H3>14.7.4 Typemaps for mapping C/C++ types to Java types</H3>


The typemaps available to the Java module include the common typemaps listed in the main typemaps section. There are a number of additional typemaps which can be used with Java.
The most important of these implement the mapping of C/C++ types to Java types. There are three of them:

<br>&nbsp;
<table BORDER>
<tr>
<td><b>Typemap</b></td>

<td><b>Description</b></td>
</tr>

<tr>
<td>typemap(jni)</td>
<td>JNI types. These provide the default mapping of types from C/C++ to JNI for use in the JNI code.</td>
</tr>

<tr>
<td>typemap(jtype)</td>
<td>Java JNI class types. These provide the default mapping of types from C/C++ to Java for use in the JNI class.</td>
</tr>

<tr>
<td>typemap(jstype)</td>
<td>Java types. These provide the default mapping of types from C/C++ to Java when for use in the Java module class and Java proxy classes.</td>
</tr>
</table>

<p>The default code generated by SWIG for the Java module comes from the typemaps in the java.swg library file and implement the 
<a href="#n9930">Default primitive type mappings</a>
covered earlier.
There are other typemaps in the Java library which could be used. 
These are listed below:
<br>&nbsp;
<table BORDER>
<tr VALIGN=TOP>
<td><b>C Type</b></td>
<td><b>Typemap</b></td>
<td><b>File</b></td>
<td><b>Kind</b></td>
<td><b>Java Type</b></td>
<td><b>Function</b></td>
</tr>

<tr VALIGN=TOP>
<td>char *</td>
<td>BYTE</td>
<td>various.i</td>
<td>input
<br>output</td>
<td>byte[]</td>

<td VALIGN=TOP>Java byte array is converted to char array which
is released afterwards</td>
</tr>

<tr>
<td>char **</td>
<td>STRING_IN</td>
<td>various.i</td>
<td>input</td>
<td>String[]</td>
<td>\0 terminated array of \0 terminated strings
<br>the array is malloc-ed and released afterwards</td>
</tr>

<tr>
<td>char **</td>
<td>STRING_OUT</td>
<td>various.i</td>
<td>output</td>
<td>String[]</td>
<td>&amp;char*
<br>the argument is the address of an '\0' terminated string</td>
</tr>

<tr>
<td>char **</td>
<td>STRING_RET</td>
<td>various.i</td>
<td>return</td>
<td>String[]</td>
<td>\0 terminated array of \0 terminated strings
<br>the array is not free'd.</td>
</tr>

<tr>
<td>primitive type pointers</td>
<td>INPUT</td>
<td>typemaps.i</td>
<td>input</td>
<td>Java basic types</td>
<td>Allows values to be used for C functions taking pointers for data input.

<tr>
<td>primitive type pointers</td>
<td>OUTPUT</td>
<td>typemaps.i</td>
<td>output</td>
<td>Java basic type arrays</td>
<td>Allows values held within an array to be used for C functions taking pointers for data output.

<tr>
<td>primitive type pointers</td>
<td>INOUT</td>
<td>typemaps.i</td>
<td>input<br>output</td>
<td>Java basic type arrays</td>
<td>Allows values held within an array to be used for C functions taking pointers for data input and output.

<tr>
<td>string <br>wstring</td>
<td>[unnamed]</td>
<td>std_string.i</td>
<td>input<br> ouput</td>
<td>String</td>
<td>Use for std::string mapping to Java String.</td>
</tr>
</table>

<p>
If a %typemap(in) is written, a %typemap(freearg) and %typemap(argout) may also need to be written. 
This is because some types have a default 'freearg' and/or 'argout' typemap which may need overriding. 
The 'freearg' typemap sometimes releases memory allocated by the 'in' typemap. 
The 'argout' typemap sometimes sets values in function parameters which are passed by reference in Java. 
Take a look at the default typemaps in java.swg.</li>

<a name="n50"></a><H3>14.7.5 Typemap variables</H3>


The standard SWIG special variables are available for use within typemaps as described in the <a href=Typemaps.html>Typemaps documentation</a>, for example <tt>$1</tt>, <tt>$input</tt>,<tt>$result</tt> etc.

<p>
The Java module uses a few additional special variables:
<p>
<b><tt>$javaclassname</tt></b><br>
$javaclassname is similar to $1_type. It expands to the class name for use in Java. 
When wrapping a union, struct or class, it expands to the Java proxy class name.
Otherwise it expands to the type wrapper class name.
For example, $javaclassname is replaced by <tt>Foo</tt> when the wrapping a <tt>struct Foo</tt> or <tt>struct Foo *</tt> and 
<tt>SWIGTYPE_p_unsigned_short</tt> is used for <tt>unsigned short *</tt>.
<p>

<b><tt>$null </tt></b><br>
Used in input typemaps to return early from JNI functions that have either void or a non-void return type. Example:

<blockquote><pre>
%typemap(check) int * %{ 
  if (error) {
    SWIG_exception(SWIG_IndexError, "Array element error");
    return $null;
  }
%}
</pre></blockquote>

If the typemap gets put into a function with void as return, $null will expand to nothing:

<blockquote><pre>
void jni_fn(...) {
    if (error) {
      SWIG_exception(SWIG_IndexError, "Array element error");
      return ;
    }
  ...
}
</pre></blockquote>

otherwise $null expands to NULL 

<blockquote><pre>
jobject jni_fn(...) {
    if (error) {
      SWIG_exception(SWIG_IndexError, "Array element error");
      return NULL;
    }
  ...
}
</pre></blockquote>


<a name="n51"></a><H3>14.7.6 Typemaps for both C and C++ compilation</H3>


JNI calls must be written differently depending on whether the code is being compiled as C or C++. 
For example C compilation requires the pointer to a function pointer struct member syntax like

<blockquote><pre>
const jclass clazz = (*jenv)->FindClass(jenv, "java/lang/String");
</pre></blockquote>

whereas C++ code compilation of the same function call is a member function call using a class pointer like

<blockquote><pre>
const jclass clazz = jenv->FindClass("java/lang/String");
</pre></blockquote>

To enable typemaps to be used for either C or C++ compilation, a set of JCALLx macros have been defined in Lib/java/javahead.swg, 
where x is the number of arguments in the C++ version of the JNI call. 
The above JNI calls would be written in a typemap like this

<blockquote><pre>
const jclass clazz = JCALL1(FindClass, jenv, "java/lang/String");
</pre></blockquote>

Note that the SWIG preprocessor expands these into the appropriate C or C++ JNI calling convention. 
The C calling convention is emitted by default and the C++ calling convention is emitted when using the -c++ SWIG commandline option. 
If you do not intend your code to be targeting both C and C++ then your typemaps can use the appropriate JNI calling convention and need not use the JCALLx macros.
<p>

<a name="n52"></a><H3>14.7.7 Java code typemaps</H3>


Most of SWIG's typemaps are used for the generation of C/C++ code. The typemaps in this section are used solely for the generation of Java code. Elements of proxy classes and type wrapper classes come from the following typemaps.

<p>

<tt>%typemap(javabase)</tt>
<blockquote>
base (extends) for Java class: empty default
</blockquote>

<tt>%typemap(javaclassmodifiers)</tt>
<blockquote>
class modifiers for the Java class: default is "public"
</blockquote>

<tt>%typemap(javacode)</tt>
<blockquote>
Java code is copied verbatim to the Java class: empty default
</blockquote>

<tt>%typemap(javaimports)</tt>
<blockquote>
import statements for Java class: empty default
</blockquote>

<tt>%typemap(javainterfaces)</tt>
<blockquote>
interfaces (extends) for Java class: empty default
</blockquote>

<tt>%typemap(javafinalize)</tt>
<blockquote>
the <tt>finalize()</tt> method (proxy classes only): default calls the <tt>delete()</tt> method
</blockquote>

<tt>%typemap(javagetcptr)</tt>
<blockquote>
the <tt>getCPtr()</tt> method: default returns the <tt>swigCPtr</tt> member variable
</blockquote>

In summary the contents of the typemaps make up a proxy class like this:

<blockquote>
<pre>
[ javaimports typemap ]
[ javamodifiers typemap ] class proxyclassname extends [ javabase typemap ] implements [ javainterfaces typemap ] {
[ javafinalize typemap ]
... SWIG generated constructors ...
... SWIG generated delete() method  ...
[ javagetcptr typemap ]
[ javacode typemap ]
... proxy functions ...
}
</pre>
</blockquote>

The type wrapper class is similar in construction:

<blockquote>
<pre>
[ javaimports typemap ]
[ javamodifiers typemap ] class typewrappername extends [ javabase typemap ] implements [ javainterfaces typemap ] {
... SWIG generated constructors ...
[ javagetcptr typemap ]
[ javacode typemap ]
}
</pre>
</blockquote>

The defaults can be overridden to tailor these classes and are often used to hide or expose the C/C++ pointer. Here is an example which will change the <tt>getCPtr()</tt> method from the default protected access to public access. 

<blockquote>
<pre>
%typemap(javagetcptr) SWIGTYPE %{
  public static long getCPtr($javaclassname obj) {
    return obj.swigCPtr;
  }
%}
</pre>
</blockquote>

Note that <tt>SWIGTYPE</tt> will target all proxy classes, but not all type wrapper classes. For the typemap to be used in all type wrapper classes, all the different types that type wrapper classes could be used for should be targeted:

<blockquote>
<pre>
%typemap(javagetcptr) SWIGTYPE, SWIGTYPE *, SWIGTYPE &, SWIGTYPE [] %{
  public static long getCPtr($javaclassname obj) {
    return obj.swigCPtr;
  }
%}
</pre>
</blockquote>

<p>

<a name="n53"></a><H2>14.8 Typemap Examples</H2>


This section includes a few examples of typemaps.  For more examples, you
might look at the files "<tt>java.swg</tt>" and "<tt>typemaps.i</tt>" in
the SWIG library.


<a name="n54"></a><H3>14.8.1 Converting Java String arrays to char ** </H3>


A common problem in many C programs is the processing of command line arguments, which are usually passed in an array of NULL terminated strings.   
The following SWIG interface file allows a Java String array to be used as a <tt>char **</tt> object.<p>
<p>
<blockquote><pre>
%module example

/* This tells SWIG to treat char ** as a special case when used as a parameter in a function call */
%typemap(in) char** (jint size) {
    int i = 0;
    size = (*jenv)-&gt;GetArrayLength(jenv, $input);
    $1 = (char **) malloc((size+1)*sizeof(char *));
    /* make a copy of each string */
    for (i = 0; i&lt;size; i++) {
        jstring j_string = (jstring)(*jenv)-&gt;GetObjectArrayElement(jenv, $input, i);
        const char* c_string = (*jenv)-&gt;GetStringUTFChars(jenv, j_string, 0);
        $1[i] = malloc(strlen((c_string)+1)*sizeof(const char*));
        strcpy($1[i], c_string);
        (*jenv)-&gt;ReleaseStringUTFChars(jenv, j_string, c_string);
        (*jenv)-&gt;DeleteLocalRef(jenv, j_string);
    }
    $1[i] = 0;
}

/* This cleans up the memory we malloc'd before the function call */
%typemap(freearg) char** {
    int i;
    for (i=0; i&lt;size$argnum-1; i++)
      free($1[i]);
    free($1);
}

/* This allows a C function to return a char ** as a Java String array */
%typemap(out) char** {
    int i;
    int len=0;
    jstring temp_string;
    const jclass clazz = (*jenv)-&gt;FindClass(jenv, "java/lang/String");

    while ($1[len]) len++;    
    jresult = (*jenv)-&gt;NewObjectArray(jenv, len, clazz, NULL);
    /* exception checking omitted */

    for (i=0; i&lt;len; i++) {
      temp_string = (*jenv)-&gt;NewStringUTF(jenv, *result++);
      (*jenv)-&gt;SetObjectArrayElement(jenv, jresult, i, temp_string);
      (*jenv)-&gt;DeleteLocalRef(jenv, temp_string);
    }
}

/* These 3 typemaps tell SWIG what JNI and Java types to use */
%typemap(jni) char** "jobjectArray"
%typemap(jtype) char** "String[]"
%typemap(jstype) char** "String[]"

/* Now a few test functions */
%inline %{

int print_args(char **argv) {
    int i = 0;
    while (argv[i]) {
         printf("argv[%d] = %s\n", i, argv[i]);
         i++;
    }
    return i;
}

char **get_args() {
  static char *values[] = { "Dave", "Mike", "Susan", "John", "Michelle", 0};
  return &values[0];
}

%}
</pre></blockquote>

Note that the 'C' JNI calling convention is used. 
Checking for any thrown exceptions after JNI function calls has been omitted. 
When this module is compiled, our wrapped C functions can now be used by the following Java program:<p>
<p>
<blockquote><pre>
// File main.java

public class main {

  static {
    try {
     System.loadLibrary("example");
    } catch (UnsatisfiedLinkError e) {
      System.err.println("Native code library failed to load. " + e);
      System.exit(1);
    }
  }

  public static void main(String argv[]) {
    String animals[] = {"Cat","Dog","Cow","Goat"};
    example.print_args(animals);
    String args[] = example.get_args();
    for (int i=0; i&lt;args.length; i++)
        System.out.println(i + ":" + args[i]);
  }
}
</pre></blockquote>
When compiled and run we get:
<blockquote><pre>
$ java main
argv[0] = Cat
argv[1] = Dog
argv[2] = Cow
argv[3] = Goat
0:Dave
1:Mike
2:Susan
3:John
4:Michelle
</pre></blockquote>

In the example, a few different typemaps are used.  The "in" typemap is
used to receive an input argument and convert it to a C array.  Since dynamic
memory allocation is used to allocate memory for the array, the
"freearg" typemap is used to later release this memory after the execution of
the C function. The "out" typemap is used to function return values.
Lastly the "jni", "jtype" and "jstype" typemaps are also required to specify
what Java types to use.

<a name="n55"></a><H3>14.8.2 Expanding a Java object to multiple arguments</H3>


Suppose that you had a collection of C functions with arguments
such as the following:

<blockquote>
<pre>
int foo(int argc, char **argv);
</pre>
</blockquote>

In the previous example, a typemap was written to pass a Java String array as the <tt>char **argv</tt>.  This
allows the function to be used from Java as follows:

<blockquote>
<pre>
example.foo(4, new String[]{"red", "green", "blue", "white"});
</pre>
</blockquote>

Although this works, it's a little awkward to specify the argument count.  To fix this, a multi-argument
typemap can be defined.  This is not very difficult--you only have to make slight modifications to the
previous example's typemaps:

<blockquote>
<pre>
%typemap(in) (int argc, char **argv) {
    int i = 0;
    $1 = (*jenv)->GetArrayLength(jenv, $input);
    $2 = (char **) malloc(($1+1)*sizeof(char *));
    /* make a copy of each string */
    for (i = 0; i<$1; i++) {
        jstring j_string = (jstring)(*jenv)->GetObjectArrayElement(jenv, $input, i);
        const char* c_string = (*jenv)->GetStringUTFChars(jenv, j_string, 0);
        $2[i] = malloc(strlen((c_string)+1)*sizeof(const char*));
        strcpy($2[i], c_string);
        (*jenv)->ReleaseStringUTFChars(jenv, j_string, c_string);
        (*jenv)->DeleteLocalRef(jenv, j_string);
    }
    $2[i] = 0;
}

%typemap(freearg) (int argc, char **argv) {
    int i;
    for (i=0; i<$1-1; i++)
      free($2[i]);
    free($2);
}

%typemap(jni) (int argc, char **argv) "jobjectArray"
%typemap(jtype) (int argc, char **argv) "String[]"
%typemap(jstype) (int argc, char **argv) "String[]"
</pre>
</blockquote>

When writing a multiple-argument typemap, each of the types is referenced by a variable such 
as <tt>$1</tt> or <tt>$2</tt>.   The typemap code simply fills in the appropriate values from
the supplied Java parameter.

<p>
With the above typemap in place, you will find it no longer necessary
to supply the argument count.  This is automatically set by the typemap code.  For example:

<blockquote>
<pre>
example.foo(new String[]{"red", "green", "blue", "white"});
</pre>
</blockquote>


<a name="n56"></a><H3>14.8.3 Using typemaps to return arguments</H3>


A common problem in some C programs is that values may be returned in arguments rather than in the return value of a function. 
The typemaps.i file defines INPUT, OUTPUT and INOUT typemaps which can be used to solve some instances of this problem. 
This library file uses an array as a means of moving data to and from Java when wrapping a C function that takes pointers as parameters. <p>

Now we are going to outline an alternative approach to using arrays for C pointers. 
The INOUT typemap uses a double[] array for receiving and returning the double* parameters. 
In this approach we are able to use a Java class myDouble instead of double[] arrays where the C pointer double* is required. 

<blockquote><pre>
/* Returns a status value and two values in out1 and out2 */
int spam(double a, double b, double *out1, double *out2);
</pre></blockquote>

If we define a structure 'MyDouble' containing a double and use some typemaps we can solve this problem, for example we could put the following through SWIG:
<blockquote><pre>
%module example

%{
/* Returns a status value and two values in out1 and out2 */
int spam(double a, double b, double *out1, double *out2) {
  int status = 1;
  *out1 = a*10.0;
  *out2 = b*100.0;
  return status;
};
%}

/* Define a new structure to use instead of double* */
%inline %{
typedef struct {
    double value;
} MyDouble;
%}

/* 
This typemap will make any double* function parameters with name 'OutValue' take an
argument of MyDouble instead of double*. This will 
allow the calling function to read the double* value after returning from the function.
*/
%typemap(in) double *OutValue {
    jclass clazz = jenv-&gt;FindClass("MyDouble");
    jfieldID fid = jenv-&gt;GetFieldID(clazz, "swigCPtr", "J");
    jlong cPtr = jenv-&gt;GetLongField($input, fid);
    MyDouble* pMyDouble = NULL;
    *(MyDouble*)&pMyDouble = *(MyDouble*)&cPtr;
    $1 = &pMyDouble-&gt;value;
}

/* This tells SWIG what Java type to use */
%typemap(jtype) double* OutValue "MyDouble"
%typemap(jstype) double* OutValue "MyDouble"

/* This tells SWIG what the matching JNI type for the Java type is */
%typemap(jni) double* OutValue "jobject"

/* Now we apply the typemap to the named variables */
%apply double* OutValue { double *out1, double* out2 };
int spam(double a, double b, double *out1, double *out2);
</pre></blockquote>

Note that the C++ JNI calling convention has been used this time and so must be compiled as C++ and the -c++ commandline must be passed to SWIG. 
JNI error checking has been omitted for clarity.<p>

What the typemaps do are make the named double* function parameters use our new MyDouble wrapper structure. 
The 'in' typemap takes this structure, gets the C++ pointer to it, is then able to get the 'double value' member variable to pass to the C++ <tt>spam</tt> function. 
In Java, when the function returns, we use the SWIG created <tt>getValue()</tt> function to get the output value. 
The following Java program demonstrates this:
<blockquote><pre>
// File: main.java

public class main {

  static {
    try {
      System.loadLibrary("example");
    } catch (UnsatisfiedLinkError e) {
      System.err.println("Native code library failed to load. " + e);
      System.exit(1);
    }
  }

  public static void main(String argv[]) {
    MyDouble out1 = new MyDouble();
    MyDouble out2 = new MyDouble();
    int ret = example.spam(1.2, 3.4, out1, out2);
    System.out.println(ret + "  " + out1.getValue() + "  " + out2.getValue());
  }
}
</pre></blockquote>

When compiled and run we get:
<blockquote><pre>
$ java main
1 12.0  340.0
</pre></blockquote>

<a name="n57"></a><H3>14.8.4 Accessing array structure members</H3>


Consider the following data structure :<p>
<p>
<blockquote><pre>
#define LEN   5
typedef struct {
  int numbers[LEN];
} Data;
</pre></blockquote>

By default, the Java module supplies the memberin typemap in the java_arrays.i file to set array members. 
It is generic, but not particularly efficient as it copies one array member at a time. 
You may want to override it for the above Data struct as follows:<p>
<p>
<blockquote><pre>
%typemap(memberin) int[LEN] {
  /* Copy at most LEN characters into $1 */
  memcpy($1,$input,sizeof(int)*LEN);
}
</pre></blockquote>

Whenever an <tt>int[LEN]</tt> type is encountered in a structure or class, this typemap provides a safe mechanism for setting its value.   
An alternative implementation might choose to print an error message if the Java supplied array was too long to fit into the field.<p>
<p>
It should be noted that the <tt>[LEN]</tt> array size is attached to the typemap. 
A datatype involving some other kind of array would not be affected.   
However, you can write a typemap to match any sized array using the <tt>ANY</tt> keyword as follows :<p>
<p>
<blockquote><pre>
%typemap(memberin) int [ANY] {
  memcpy($1,$input,sizeof(int)*$1_dim0);
}
</pre></blockquote>
<p>
In this case, the variable <tt>$1_dim0</tt> is expanded to match the
array dimensions actually used in the C code. This allows the typemap
to be applied to types such as:

<blockquote>
<pre>
void foo(int x[10]);
void bar(int a[4], int b[8]);
</pre>
</blockquote>


<a name="n58"></a><H3>14.8.5 Pointer handling</H3>


C pointers in the Java module are held in a simple Java long, whereas other SWIG language modules use an encoding of the pointer in a string. 
These scripting languages use the SWIG runtime type checker for type checking as they do not support static type checking by a compiler.
The pointer stored in a Java long, which is a 64 bit number. 
However most JVMs are 32 bit applications so any JNI code must also be compiled as 32 bit. 
This means that the pointers in JNI code are also 32 bits. 
What happens for various reasons is on big endian machines the pointer is stored in the high order 4bytes, whereas on little endian machines the pointer is stored in the low order 4bytes. 
As a result, care must be taken if you intend to manipulate the pointer directly from Java. 
This can of course can be changed with judicious use of typemaps, but normally you needn't worry about any of this unless you want to modify pointers within Java code.<p>

By now you hopefully have the idea that typemaps are a powerful mechanism for building more specialized applications.  
While writing typemaps can be technical, many have already been written for you.  
See the Typemaps chapter for more information about using library files.<p>

To extract the pointer from a Java long, some rather scary looking casting has to be performed for operation on multiple platforms. 
The default "in" and "out" typemaps for a simple pointer are:


<blockquote>
<pre>
%typemap(in) SWIGTYPE * %{
    $1 = ($1_ltype)*(void**)&$input; 
%}
%typemap(out) SWIGTYPE * %{
*($&1_ltype)&$result = $1; 
%} 
</pre>
</blockquote>

<blockquote>
<pre>
JNIEXPORT jlong JNICALL Java_exampleJNI_bounce(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong jresult = 0 ;
    int *arg1 ;
    int *result;
    
    arg1 = (int *)*(void**)&jarg1; 
    result = (int *)bounce(arg1);
    
    *(int **)&jresult = result; 
    return jresult;
}
</pre>
</blockquote>



<a name="n59"></a><H2>14.9 Odds and ends</H2>


<a name="n60"></a><H3>14.9.1 Functional interface without proxy classes</H3>


It is possible to run SWIG in a mode that does not produce proxy classes by using the -noproxy commandline option.
The interface is rather primitive when wrapping structures or classes and is accessed through function calls to the module class.
All the functions in the module class are wrapped by functions with identical names as those in the JNI class.

Consider the example we looked at when looking at proxy classes:
<blockquote>
<pre>
class Foo {
public:
     int x;
     int spam(int num, Foo* foo);
};
</pre>
</blockquote>

When using the interface type wrapper classes are generated instead of proxy classes.
Access to all the functions and variables is through a C like set of functions where the first parameter passed is the pointer to the class, that is an instance of a type wrapper class.
Here is what the module class looks like:

<blockquote>
<pre>
public class example {
  public static void set_Foo_x(SWIGTYPE_p_Foo self, int x) {...}
  public static int get_Foo_x(SWIGTYPE_p_Foo self) {...}
  public static int Foo_spam(SWIGTYPE_p_Foo self, int num, SWIGTYPE_p_Foo foo) {...}
  public static SWIGTYPE_p_Foo new_Foo() {...}
  public static void delete_Foo(SWIGTYPE_p_Foo self) {...}
}
</pre>
</blockquote>

This approach is not nearly as natural as using proxy classes as the functions need to be used like this:

<blockquote>
<pre>
SWIGTYPE_p_Foo foo = example.new_Foo();
example.set_Foo_x(foo, 10);
int var = example.get_Foo_x(foo);
example.Foo_spam(foo, 20, foo);
example.delete_Foo(foo);
</pre>
</blockquote>

Unlike proxy classes, there is no attempt at tracking memory.
All destructors have to be called manually for example, <code>delete_Foo(foo)</code> above.


<a name="n61"></a><H3>14.9.2 Dynamic linking problems</H3>


The code to load a native library is <code>System.loadLibrary("name")</code>. 
This can fail and it can be due to a number of reasons. 
<p>

The most common is an incorrect naming of the native library for the name passed to the <code>loadLibrary</code> function. 
The text passed to the <code>loadLibrary</code> function must not include the the extension name in the text, that is <i>.dll</i> or <i>.so</i>. 
The text must be <i>name</i> and not <i>libname</i> for all platforms. On Windows the native library must then be called <i>name.dll</i> and on Unix it must be called <i>libname.so</i>. 
If you are debugging using <code> java -debug</code>, then the native library must be called <i>name_g.dll</i> on Windows and <i>libname_g.so</i> on Unix.
<p>

Another common reason for the native library not loading is because it is not in your path. On Unix make sure that your <i>LD_LIBRARY_PATH</i> contains the path to the native library. 
On Windows make sure the <i>path</i> environment variable contains the path to the native library. 
SWIG code usually works if you have <i>LD_LIBRARY_PATH</i> set to '.' (or no modification to <i>path</i> in Windows).
<p>

The native library will also not load if there are any unresolved symbols in the compiled C/C++ code. 
Unresolved symbols will be described if you use the -verbose:jni commandline switch when running Java.
<p>

Ensure that you are using the correct C/C++ compiler and linker combination and options for successful native library loading. 
The Examples/Makefile must have these set up correctly for your system. The 
SWIG installation package makes a best attempt at getting these correct but does not get it right 100% of the time.
<p>
Linking problems used to occur when there were underscores in the module name or package name. This was fixed in SWIG 1.3.7.

<a name="n62"></a><H3>14.9.3 Using your own JNI methods</H3>


Perhaps you have some hand written JNI functions that you want to use in addition to the SWIG generated JNI functions? This can be accomplished using the <tt>%native</tt> directive or the <tt>%ignore</tt> directive depending on what you want. <p>

If you don't want SWIG to wrap your JNI function as you have written the Java native function declaration in addition to the JNI function, simply use the <tt>%ignore</tt> directive. <p>
        
Alternatively you may want SWIG to help out and do some work by using the <tt>%native</tt> directive, for example:

<blockquote><pre>
%typemap (jtype) SomeCType "SomeJavaClass";
%native (HandRolledJavaName) int HandRolledCName(long, char*, SomeCType);
%{
JNIEXPORT jint JNICALL
Java_modulename_HandRolled ( JNIEnv *jenv, jclass jcls, jint net, jstring path, jobject SomeJavaClass)
{
/* implementation */
}
</pre></blockquote>

No C/C++ code will be generated and the <tt>Java_modulename_HandRolled</tt> function will be unmodified and accessible using the SWIG generated Java native function call which will look something like this:

<blockquote><pre>
  public final static native int HandRolledJavaName(int jarg1, String jarg2, SomeJavaClass jarg3);
</pre></blockquote>

What is happening here is the <tt>%native</tt> directive is telling SWIG to generate the module Java native method declaration, but not the JNI C code for a (possibly non-existent) C function called <tt>HandRolledCName</tt>. 
To accomplish this SWIG needs to be told about the mapping of (possibly non-existent) C types to Java types, either using the built in mapping (char* -&gt; String) or the supplied one using the jtype typemap (SomeCType -&gt; SomeJavaClass). 
This is only really useful if you want to mix your own JNI code and the SWIG generated code into one C/C++ file or mix your own JNI function calls into a SWIG generated Java class.

<a name="n63"></a><H3>14.9.4 Performance concerns and hints</H3>


However, if you're directly manipulating huge arrays of complex objects from Java, performance may suffer greatly.  
In these cases, you should consider implementing the functions in C or thinking of ways to optimize the problem. 
Try and minimise the expensive JNI calls to C/C++ functions, perhaps by using temporary Java variables instead of accessing the information directly from the C/C++ object.<p>

Java classes without any finalizers generally speed up code execution as there is less for the garbage collector to do. Finalizer generation can be stopped by using an empty <tt>javafinalize</tt> typemap: 

<blockquote><pre>
%typemap(javafinalize) SWIGTYPE ""
</pre></blockquote>

However, you will have to be careful about memory management and make sure that you code in a call to the <tt>delete()</tt> member function to free up the C/C++ object memory. This method calls the C++ destructor or <tt>free()</tt> for C code.
<p>

If performance is really critical you can use the low-level functional interface which eliminates some of the overhead of going through the proxy classes (at the expense of coding simplicity).<p>

<a name="n64"></a><H3>14.9.5 Known bugs</H3>


Known bugs at release:

<ul>
    <li>Pointers to member functions don't work yet.
</ul>

If you need these, have a go at writing your own typemaps.

</body>
</html>


<a name="n65"></a><H2>14.10 Examples</H2>


The directory Examples/java has a number of further examples. 
Take a look at these if you want to see of the techniques described in action.
The Examples/index.html in the parent directory contains the SWIG Examples Documentation and is a useful starting point. 
If your SWIG installation went well Unix users should be able to type <code>make</code> in each example directory, then <code>java main</code> to see them running.
For the benefit of Windows users, there are also Visual C++ project files in a couple of the examples.


