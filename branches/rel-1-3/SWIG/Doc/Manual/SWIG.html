<html>
<head>
<title>SWIG Basics</title>
</head>

<body bgcolor="#ffffff">
<h1>3 SWIG Basics</h1>

This chapter describes the basic operation of SWIG, the structure of its
input files, and how it handles various sorts of C/C++ declarations.
Specific details about each target language are described in later
chapters.   However, much of the underlying design philosophy and 
aspects of SWIG's implementation are contained here.

<h2>Running SWIG</h2>

To run SWIG, use the <tt>swig</tt> command with one or more of the
following options and a filename like this:

<p>
<blockquote><pre>swig [ <em>options</em> ] filename

-tcl                  Generate Tcl wrappers
-perl                 Generate Perl5 wrappers
-python               Generate Python wrappers
-guile                Generate Guile wrappers
-ruby                 Generate Ruby wrappers
-java                 Generate Java wrappers
-mzscheme             Generate mzscheme wrappers
-c++                  Enable C++ parsing
-I<em>dir</em>                 Add a directory to the file include path
-l<em>file</em>                Include a SWIG library file.
-c                    Generate raw wrapper code (omit supporting code)
-o <em>outfile</em>            Name of output file
-module <em>name</em>          Set the name of the SWIG module
-D<em>symbol</em>              Define a preprocessor symbol
-includeall           Follow all #include statements
-version              Show SWIG's version number
-help                 Display all options

</pre></blockquote>

Additional options are often defined for each target language.  A full list
can be obtained by typing <tt>swig -help</tt> or <tt>swig
-<em>lang</em> -help</tt>.

<h3>Input format</h3>

As input, SWIG expects a file containing ANSI C/C++ declarations and
special SWIG directives.  More often than not, this is a special SWIG
interface file which is usually denoted with a special <tt>.i</tt> or
<tt>.swg</tt> suffix.  In certain cases, SWIG can be used directly on
raw C header files or C source files.  However, this is not the most
typical case and there are several reasons why you might not want to
do this (described later).

<p>
The general format of a SWIG interface is as follows:

<p>
<blockquote><pre>%module mymodule 
%{
#include "myheader.h"
%}
// Now list ANSI C/C++ declarations
int foo;
int bar(int x);
...
</pre></blockquote>

The name of the module is supplied using the special <tt>%module</tt>
directive (or the <tt>-module</tt> command line option).  This
directive must appear at the beginning of the file and is used to name
the resulting extension module (in addition, this name is often used to define
a namespace in the target language).  If the module name is supplied on the
command line, it overrides the name specified with the
<tt>%module</tt> directive.

<p>
Everything in the <tt>%{ ... %}</tt> block is simply copied to the
resulting output file.  The enclosed text is not parsed or interpreted
by SWIG.  Although the use of a <tt>%{,%}</tt> block is optional, most
interface files have one to include header files and other supporting
C declarations.  The <tt>%{...%}</tt> syntax and
semantics in SWIG is analogous to that of the declarations section used
in input files to yacc or bison.

<h3>SWIG Output</h3>

The output of SWIG is a C/C++ file that contains all of the wrapper
code needed to build an extension module.  By default, an input file
with the name <tt>file.i</tt> is transformed into a file
<tt>file_wrap.c</tt> or <tt>file_wrap.cxx</tt> (depending on whether
or not the <tt>-c++</tt> option has been used).  The name of the
output file can be changed using the <tt>-o</tt> option.  In certain
cases, file suffixes are used by the compiler to determine the source
language (C, C++, etc.). Therefore, you may want to use the
<tt>-o</tt> option to change the suffix of the SWIG-generated wrapper
file (if needed). For example:

<blockquote><pre>
$ swig -c++ -python -o example_wrap.cpp example.i</pre></blockquote>

<p>
It is important to note that the output file created by SWIG normally
contains everything that is needed to construct a extension module
for the target scripting language. SWIG is not a stub compiler nor is
usually necessary to edit the output file (and if you look at the output,
you probably won't want to).      To build the final extension module, the
SWIG output file is compiled and linked with the rest of your C/C++
program to create a shared library.   If all goes well, your module is
now ready to use.

<h3>Comments</h3>

C and C++ style comments may appear anywhere in interface files.  In
previous versions of SWIG, comments were used to generate
documentation files. However, this feature is currently under repair
and will reappear in a later SWIG release.

<h3>C Preprocessor</h3>

Like C, SWIG preprocesses all input files through an enhanced version
of the C preprocessor.  All standard preprocessor features are
supported including file inclusion, conditional compilation and
macros. However, <tt>#include</tt> statements are ignored unless the
<tt>-includeall</tt> command line option has been supplied.  The
reason for disabling includes is that SWIG is sometimes used to
process raw C header files.  In this case, you usually only want the
extension module to include functions in the supplied header file
rather than everything that might be included by that header file
(i.e., system headers, C library functions, etc.).

<p>
It should also be noted that the SWIG preprocessor skips all text
enclosed inside a <tt>%{...%}</tt> block.  In addition, the
preprocessor includes a number of macro handling enhancements that
make it more powerful than the normal C preprocessor.  These
extensions are described in the "Preprocessor" section near the end of
this chapter.

<h3>SWIG Directives</h3>

Most of SWIG's operation is controlled by special directives that are
always preceded by a "<tt>%</tt>" to distinguish them from normal C
declarations. These directives are used to give SWIG hints or to alter
SWIG's parsing behavior in some manner.   

<p>
Since SWIG directives are not legal C syntax, it is generally not
possible to include them in header files.  However, SWIG directives can be
included in C header files using conditional compilation like this:

<blockquote><pre>
/* header.h  --- Some header file */

/* SWIG directives -- only seen if SWIG is running */ 
#ifdef SWIG
%module foo
#endif
</pre>
</blockquote>

<tt>SWIG</tt> is a special preprocessing symbol defined by SWIG when
it is parsing an input file.

<h3>Parser Limitations</h3>

Although SWIG can parse most common C/C++ declarations, it does not
provide a complete C/C++ parser implementation.  Most of these
limitations pertain to very complicated type declarations and certain
advanced C++ features.  Specifically, the following features are not
currently supported:

<p>
<ul>
<li>Non-conventional type declarations.
For example, SWIG does not support declarations such as the following
(even though this is legal C):

<blockquote>
<pre>
/* Non-conventional placement of storage specifier (extern) */
const int extern Number;
/* Function declaration with unnecessary grouping */
int (foo)(int,int); 
...
</pre>
</blockquote>

In practice, few (if any) C programmers actually write code like
is since this style is never featured in programming books.  However,
if you're feeling particularly obfuscated, you can certainly break SWIG.

<p>
<li>Running SWIG on C++ source files (what would appear in a .C or .cxx file) 
is not recommended.  Even though SWIG can parse C++ class declarations,
it does not know how to parse declarations that are decoupled from their
original class definition.  For example:

<blockquote>
<pre>
/* Not supported by SWIG */
int foo::bar(int) {
    ... whatever ...
}
</pre>
</blockquote>

<li>Certain advanced features of C++ such as namespaces and overloaded
operators are not currently supported. Please see the section on using SWIG
with C++ for more information.
</ul> <p>

In the event of a parsing error, conditional compilation can be used to skip
offending code.  For example:

<blockquote>
<pre>
#ifndef SWIG
... some bad declarations ...
#endif
</pre>
</blockquote>

Alternatively, you can just delete the offending code from the interface file.

<h2>Wrapping Simple C Declarations</h2>

SWIG wraps simple C declarations by creating an interface that closely matches
the way in which the declarations would be used in a C program.
For example, consider the following interface file:

<p>
<blockquote><pre>%module example

extern double sin(double x);
extern int strcmp(const char *, const char *);
extern int Foo;
#define STATUS 50
#define VERSION "1.1"
</pre></blockquote>

In this file, there are two functions <tt>sin()</tt> and <tt>strcmp()</tt>,
a global variable <tt>Foo</tt>, and two constants <tt>STATUS</tt> and
<tt>VERSION</tt>.  When SWIG creates an extension module, these
declarations are accessible as scripting language functions, variables, and
constants respectively.  For example, in Tcl:

<p>
<blockquote><pre>% sin 3
5.2335956
% strcmp Dave Mike
-1
% puts $Foo
42
% puts $STATUS
50
% puts $VERSION
1.1
</pre></blockquote>

Or in Python:

<p>
<blockquote><pre>
>>> example.sin(3)
5.2335956
>>> example.strcmp('Dave','Mike')
-1
>>> print example.cvar.Foo
42
>>> print example.STATUS
50
>>> print example.VERSION
1.1
</pre></blockquote>

Whenever possible, SWIG creates an interface that closely matches the underlying C/C++
code. However, due to subtle differences between languages, run-time
environments, and semantics, it is not always possible to do so.   The
next few sections describes various aspects of this mapping.

<h3>Basic Type Handling</h3>

In order to build an interface, SWIG has to convert C/C++ datatypes to
equivalent types in the target language.  Generally speaking,
scripting languages tend to provide a more limited set of types than C.
Therefore, this process involves a certain amount of type
coercion.

<p>
Most scripting languages provide a single integer type that is implemented using
the <tt>int</tt> or <tt>long</tt> datatype in C.   The following list shows
all of the C datatypes that SWIG will convert to and from integers in the target language:

<p>
<blockquote><pre>int
short
long
unsigned
signed
unsigned short
unsigned long
unsigned char
signed char
bool
</pre></blockquote>

<p>
When an integral value is converted from C, a cast is used to convert it to
the representation in the target language.
Thus, a 16 bit short in C may be promoted to a 32 bit integer.  When integers are 
converted in the other direction, the value is cast back into the original C type.  
If the value is too large to fit, it is silently truncated.
<!-- Dave: Maybe we should fix this -->

<p>
<tt>unsigned char</tt> and <tt>signed char</tt> are special cases that
are handled as small 8-bit integers. Normally, the <tt>char</tt>
datatype is mapped as a one-character ASCII string. <p>

<p>
The <tt>bool</tt> datatype is cast to and from an integer value of 0
and 1.<p>

<p>
Some care is required when working with large integer values. Most
scripting languages use 32-bit integers so mapping a 64-bit long
integer may lead to truncation errors. Similar problems may arise with
32 bit unsigned integers (which may appear as large negative
numbers). As a rule of thumb, the <tt>int</tt> datatype and all
variations of <tt>char</tt> and <tt>short</tt> datatypes are safe to
use. For <tt>unsigned int</tt> and <tt>long</tt> datatypes, you will
need to carefully check the correct operation of your program after
it has been wrapped with SWIG.

<p>
Although the SWIG parser supports the <tt>long long</tt> datatype,
very few language modules currently support it. This is because
<tt>long long</tt> usually exceeds the precision available in the
target language.  This limitation may be eliminated in future SWIG
releases.

<p>
SWIG recognizes the following floating point types :<p>

<blockquote><pre>
float
double
</pre></blockquote>
<p>

Floating point numbers are mapped to and from the natural
representation of floats in the target language. This is almost always
a C <tt>double</tt>. The rarely used datatype of <tt>long double</tt>
is not supported by SWIG.<p>

<p>
The <tt>char</tt> datatype is mapped into a NULL terminated ASCII
string with a single character. When used in a scripting language it
shows up as a tiny string containing the character value. When
converting the value back into C, SWIG takes a character string
from the scripting language and strips off the first character as the
char value. Thus if the value "foo" is assigned to a
<tt>char</tt> datatype, it gets the value `f'.<p>

<p>
The <tt>char *</tt> datatype is handled as a NULL-terminated ASCII
string. SWIG maps this into a 8-bit character string in the target
scripting language. SWIG converts character strings in the target
language to NULL terminated strings before passing them into C/C++. It
is illegal for these strings to have embedded NULL bytes.  Therefore,
the <tt>char *</tt> datatype is not generally suitable for passing
binary data (although SWIG's behavior can be modified to handle this).

<p>
At this time, SWIG does not provide any special support for Unicode or
wide-character strings (the C <tt>wchar_t</tt> type).  This is a
delicate topic that is quite complex and poorly understood by many
programmers.  For those scripting languages that provide Unicode
support, Unicode strings are often implicitly converted to an 8-bit
representation such as UTF-8 whenever they are matched to the <tt>char
*</tt> type (in which case the SWIG interface will probably work).

<h3>Global Variables</h3>

Whenever possible, SWIG maps C/C++ global variables into scripting language
variables.  For example,

<p>
<blockquote><pre>%module example
double foo;

</pre></blockquote>

results in a scripting language variable like this:

<p>
<blockquote><pre># Tcl
set foo [3.5]                   ;# Set foo to 3.5
puts $foo                       ;# Print the value of foo

# Python
cvar.foo = 3.5                  ;# Set foo to 3.5
print cvar.foo                  ;# Print value of foo

# Perl
$foo = 3.5;                     ;# Set foo to 3.5
print $foo,"\n";                ;# Print value of foo

</pre></blockquote>

Whenever the scripting language variable is used, the underlying C
global variable is accessed.  Although SWIG makes every
attempt to make global variables work like scripting language
variables, it is not always possible to do so.  For instance, in
Python, all global variables must be accessed through a special
variable object known as <tt>cvar</tt> (shown above).  Other languages may
convert variables to a pair of accessor functions.  For example, the
Java module generates a pair of functions <tt>double get_foo()</tt>
and <tt>set_foo(double val)</tt> that are used to manipulate the
value.

<p>
Finally, if a global variable has been declared as <tt>const</tt>, it
only supports read-only access.  Note: this behavior is new to SWIG-1.3.
Earlier versions of SWIG incorrectly handled <tt>const</tt> and created
constants instead.

<h3> Constants</h3>

Constants can be created using <tt>#define</tt>, enumerations,
or a special <tt>%constant</tt> directive.  The following
interface file shows a few valid constant declarations :<p>

<p>
<blockquote><pre>#define I_CONST       5               // An integer constant
#define PI            3.14159         // A Floating point constant
#define S_CONST       "hello world"   // A string constant
#define NEWLINE       '\n'            // Character constant

enum boolean {NO=0, YES=1};
enum months {JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG,
             SEP, OCT, NOV, DEC};
%constant double BLAH = 42.37;
#define F_CONST (double) 5            // A floating pointer constant with cast
#define PI_4 PI/4
#define FLAGS 0x04 | 0x08 | 0x40

</pre></blockquote>

In <tt>#define</tt> declarations, the type of a constant is inferred
by syntax. For example, a number with a decimal point is assumed to be
floating point.  In addition, SWIG must be able to fully resolve all
of the symbols used in a <tt>#define</tt> in order for a constant to
actually be created.  This restriction is necessary because
<tt>#define</tt> is also used to define preprocessor macros that are
definitely not meant to be part of the scripting language interface.
For example:

<blockquote>
<pre>
#define EXTERN extern

EXTERN void foo();
</pre>
</blockquote>

In this case, we probably don't want to create a constant called 
<tt>EXTERN</tt> (what would the value be?).  In general,
SWIG will not create constants for macros unless the value can
be completely determined.  For instance, in the above example,
the declaration

<blockquote>
<pre>
#define PI_4  PI/4
</pre>
</blockquote>

defines a constant because <tt>PI</tt> was already defined as a
constant and the value is known.

<p>
The use of constant expressions is allowed, but SWIG does not evaluate
them. Rather, it passes them through to the output file and lets the C
compiler perform the final evaluation (SWIG does perform a limited
form of type-checking however).<p>

<p>
For enumerations, it is critical that the original enum definition be
included somewhere in the interface file (either in a header file or
in the <tt>%{,%}</tt> block). SWIG only translates the enumeration
into code needed to add the constants to a scripting language. It
needs the original enumeration declaration in order to get the correct
enum values as assignd by the C compiler.

<p>
The <tt>%constant</tt> directive is used to more precisely create
constants corresponding to different C datatypes.  Although it is not
usually not needed for simple values, it is more useful when working
with pointers and other more complex datatypes.  Typically, %constant
is only used when you want to add constants to the scripting language
interface that are defined in a normal header file. 

<h3>A brief word about <tt>const</tt></h3>

A common confusion with C programming is the semantic meaning of the
<tt>const</tt> qualifier in declarations--especially when it is mixed
with pointers and other type modifiers. In fact, previous versions of SWIG
handled <tt>const</tt> incorrectly--a situation that SWIG-1.3.7 and newer
releases has fixed.

<p>
Starting with SWIG-1.3, all variable declarations, regardless of any
use of <tt>const</tt>, are wrapped as global variables.  If a
declaration happens to be declared as <tt>const</tt>, it is wrapped as
a read-only variable. To tell if a variable is <tt>const</tt> or not,
you need to look at the right-most occurrence of the <tt>const</tt>
qualifier (that appears before the variable name).  If the right-most
<tt>const</tt> occurs after all other type modifiers (such as
pointers), then the variable is <tt>const</tt>.  Otherwise, it is not.

<p>
Here are some examples of <tt>const</tt> declarations.

<blockquote>
<pre>
const char a;           // A constant character
char const b;           // A constant character (the same)
char *const c;          // A constant pointer to a character
const char *const d;    // A constant pointer to a constant character
</pre>
</blockquote>

Here is an example of a declaration that is not <tt>const</tt>:

<blockquote>
<pre>
const char *e;          // A pointer to a constant character.  The pointer
                        // may be modified.
</pre>
</blockquote>

In this case, the pointer <tt>e</tt> can change---it's only the value
being pointed to that is read-only.

<h2>Pointers and complex objects</h2>

Most C programs have many more types than integers, floats, and
character strings.  Usually, there are pointers, arrays,
structures, and other types of objects.  This section
discusses the handling of these datatypes.

<h3> Simple pointers</h3>

Pointers to basic C datatypes such as <p>
<p>
<blockquote><pre>int *
double ***
char **
</pre></blockquote>
<p>
are fully supported by SWIG.  SWIG encodes pointers into a
representation that contains the actual value of the pointer and a string
representing the datatype. Thus, the SWIG representation of the above
pointers (in Tcl), might look like this:<p>

<p>
<blockquote><pre>_10081012_p_int
_1008e124_ppp_double
_f8ac_pp_char
</pre></blockquote>

<p>
A NULL pointer is represented by the string "NULL" or the value 0
encoded with type information.<p>

<p>
All pointers are treated as opaque objects by SWIG. Thus, a pointer
may be returned by a function and passed around to other C functions
as needed.  For all practical purposes, the scripting language
interface works in exactly the same way as you would manipulate the
pointer in a C program with the exception that the pointer can't be
dereferenced (at least not without additional help).

<p>
The scripting language representation of a pointer value should never be
manipulated directly.   Even though the values shown above look like hexadecimal
addresses, the numbers used may differ from the actual machine address (e.g.,
on little-endian machines, the digits may appear in reverse order).
Furthermore, SWIG does not
normally map pointers into high-level objects such as associative
arrays or lists (for example, converting an
<tt>int *</tt> into an list of integers). There are several reasons
why SWIG does not do this:<p>

<p>
<ul>
<li>There is not enough information in a C declaration to properly map
pointers into higher level constructs. For example, an <tt>int *</tt>
may indeed be an array of integers, but if it contains one million
elements, converting it into a Tcl, Perl, or Python list would
probably be an extremely bad idea.

<p>
<li>The underlying semantics associated with a pointer is not known
by SWIG.   For instance, an <tt>int *</tt> might not be an array at all--perhaps it
is an output value!

<P>
<li>By handling all pointers in a consistent manner, the implementation of SWIG is greatly
simplified and less prone to error.
</ul>
<p>

<h3> Run time pointer type checking</h3>

By allowing pointers to be manipulated from a scripting language, extension modules
effectively bypass compile-time type checking in the C/C++
compiler.  To prevent errors, a type signature is encoded into all
pointer values and is used to perform run-time type checking.  This
type-checking process is an integral part of SWIG and can not be
disabled or modified without using typemaps (described in later
chapters).

<p>
Like C, <tt>void *</tt> matches any kind of pointer.  Furthermore,
<tt>NULL</tt> pointers can be passed to any function that expects to
receive a pointer.  Although this has the potential to cause a crash,
<tt>NULL</tt> pointers are also sometimes used
as sentinel values or to denote a missing/empty value.  Therefore,
SWIG leaves NULL pointer checking up to the application.

<h3> Derived types, structs, and classes</h3>

For everything else (structs, classes, arrays, etc...) SWIG applies a
very simple rule :<p>

<p>
<center>
<b>Everything else is a pointer</b>
</center>

<p>
In other words, SWIG manipulates everything else by reference. This
model makes sense because most C/C++ programs make heavy use of
pointers and SWIG can use the type-checked pointer mechanism already
present for handling pointers to basic datatypes.<p>

<p>
Although this probably sounds complicated, it's really quite
simple. Suppose you have an interface file like this :<p>

<p>
<blockquote><pre>%module fileio
FILE *fopen(char *, char *);
int fclose(FILE *);
unsigned fread(void *ptr, unsigned size, unsigned nobj, FILE *);
unsigned fwrite(void *ptr, unsigned size, unsigned nobj, FILE *);
void *malloc(int nbytes);
void free(void *);

</pre></blockquote>

In this file, SWIG doesn't know what a <tt>FILE</tt> is, but it's used
as a pointer, so it doesn't really matter what it is. If you wrapped
this module into Python, you could use the functions just like you
would expect :<p>

<p>
<blockquote><pre># Copy a file 
def filecopy(source,target):
	f1 = fopen(source,"r")
	f2 = fopen(target,"w")
	buffer = malloc(8192)
	nbytes = fread(buffer,8192,1,f1)
	while (nbytes &gt; 0):
		fwrite(buffer,8192,1,f2)
		nbytes = fread(buffer,8192,1,f1)
	free(buffer)

</pre></blockquote>

In this case <tt>f1</tt>,<tt> f2</tt>, and <tt>buffer</tt> are all
opaque objects containing C pointers. It doesn't matter what value
they contain--our program works just fine without this knowledge.<p>

<h3>Undefined datatypes</h3>

When SWIG encounters an undeclared datatype, it automatically assumes
that it is a structure or class. For example, suppose the following
function appeared in a SWIG input file:<p>

<p>
<blockquote><pre>void matrix_multiply(Matrix *a, Matrix *b, Matrix *c);
</pre></blockquote>
<p>

SWIG has no idea what a "<tt>Matrix</tt>" is.  However, it is obviously
a pointer to something so SWIG generates a wrapper using its generic pointer
handling code. 

<p>
Unlike C or C++, SWIG does not actually care whether <tt>Matrix</tt>
has been previously defined in the interface file or not.  This
allows SWIG to generate interfaces from
only partial or limited information. In some cases, you may not care
what a <tt>Matrix</tt> really is as long as you can pass an opaque reference to
one around in the scripting language interface.

<p>
An important detail to mention is that SWIG will gladly generate
wrappers for an interface when there are unspecified type names.
However, <b>all unspecified types are internally handled as pointers
to structures or classes!</b>. For example, consider the following declaration:

<blockquote>
<pre>
void foo(size_t num);
</pre>
</blockquote>

If <tt>size_t</tt> is undeclared, SWIG generates wrappers
that expect to receive a type of <tt>size_t *</tt> (this mapping is described shortly).
As a result, the scripting interface might behave strangely.  For example:

<blockquote>
<pre>
foo(40);
TypeError: expected a _p_size_t.
</pre>
</blockquote>

The only way to fix this problem is to make sure you properly declare type names using
<tt>typedef</tt>.

<!-- We might want to add an error reporting flag to swig -->

<h3>Typedef</h3>

Like C, <tt>typedef</tt> can be used to define new type names in SWIG. For example:
<p>
<blockquote><pre>typedef unsigned int size_t;

</pre></blockquote>

<tt>typedef</tt> definitions appearing in a SWIG interface
are not propagated to the generated wrapper code.  Therefore, if you
write a new <tt>typedef</tt> declaration, you may have to also include
a small piece of code in a <tt>%{ ... %}</tt> block like this:

<blockquote>
<pre>
%{
/* Include in the generated wrapper file */
typedef unsigned int size_t;
%}
/* Tell SWIG about it */
typedef unsigned int size_t;
</pre>
</blockquote>

or

<blockquote>
<pre>
%inline %{
typedef unsigned int size_t;
%}
</pre>
</blockquote>

SWIG intelligently tracks <tt>typedef</tt> declarations and uses this information
for run-time type checking. For instance, if you use the above <tt>typedef</tt> and
had the following function declaration:

<blockquote>
<pre>
void foo(unsigned int *ptr);
</pre>
</blockquote>

The corresponding wrapper function accepts arguments of
type <tt>unsigned int *</tt> or <tt>size_t *</tt>.

<h2>Other Practicalities</h2>

So far, this chapter has presented almost everything you need to know to use SWIG
for simple interfaces. However, some C programs use idioms that are somewhat
more difficult to map to a scripting language interface.  This section describes
some of these issues.

<h3> Passing complex datatypes by value</h3>

Sometimes a C function takes structure parameters that are passed
by value.  For example, consider the following function:

<p>
<blockquote><pre>double dot_product(Vector a, Vector b);
</pre></blockquote>

<p>
To deal with this, SWIG transforms the function to use pointers by
creating a wrapper equivalent to the following:

<p>
<blockquote><pre>double wrap_dot_product(Vector *a, Vector *b) {
    return dot_product(*a,*b);
}
</pre></blockquote>

<p>
In the target language, the <tt>dot_product()</tt> function now accepts pointers
to Vectors instead of Vectors.  For the most part, this transformation
is transparent so you might not notice.

<h3>Return by value</h3>

C functions that return structures or classes datatypes by value are more difficult
to handle. Consider the following function:<p>

<p>
<blockquote><pre>Vector cross_product(Vector v1, Vector v2);

</pre></blockquote>

This function wants to return <tt>Vector</tt>, but SWIG only really supports
pointers.  As a result, SWIG creates a wrapper like this:

<p>
<blockquote><pre>Vector *wrap_cross_product(Vector *v1, Vector *v2) {
        Vector *result;
        result = (Vector *) malloc(sizeof(Vector));
        *(result) = cross(*v1,*v2);
        return result;
}
</pre></blockquote>

<p>
or if SWIG was run with the <tt>-c++</tt> option:<p>

<p>
<blockquote><pre>Vector *wrap_cross(Vector *v1, Vector *v2) {
        Vector *result = new Vector(cross(*v1,*v2)); // Uses default copy constructor
        return result;
}
</pre></blockquote>

<p>
In both cases, SWIG allocates a new object and returns a reference to it. It
is up to the user to delete the returned object when it is no longer
in use. Clearly, this will leak memory if you are unaware of the implicit
memory allocation.

<h3>Linking to complex variables</h3>

When global variables or class members involving complex datatypes are
encountered, SWIG handles them as pointers. For example, a global
variable like this<p>

<blockquote><pre>
Vector unit_i;
</pre></blockquote>
<p>
gets mapped to an underlying pair of set/get functions like this :<p>
<p>
<blockquote><pre>Vector *unit_i_get() {
	return &amp;unit_i;
}
Vector *unit_i_set(Vector *value) {
	unit_i = *value;
	return &amp;unit_i;
}
</pre></blockquote>
<p>

Again some caution is in order. A global variable created in this
manner will show up as a pointer in the target scripting language. It
would be an extremely bad idea to free or destroy such a pointer.    Also,
C++ classes must supply a properly defined copy constructor in order for
assignment to work correctly.

<h3> Arrays</h3>

Arrays are fully supported by SWIG, but they are always handled as pointers instead
of mapping them to a special array object or list in the target language.  Thus, the
following declarations :<p>

<p>
<blockquote><pre>int foobar(int a[40]);
void grok(char *argv[]);
void transpose(double a[20][20]);
</pre></blockquote>

<p>
are processed as if they were really declared like this:

<p>
<blockquote><pre>int foobar(int *a);
void grok(char **argv);
void transpose(double (*a)[20]);
</pre></blockquote>

Like C, SWIG does not perform array bounds checking.  
It is up to the
user to make sure the pointer points a suitably allocated region of memory. 

<p>
Multi-dimensional arrays are transformed into a pointer to array of one less
dimension.  For example:

<blockquote>
<pre>
int [10];         // Maps to int *
int [10][20];     // Maps to int (*)[20]
int [10][20][30]; // Maps to int (*)[20][30]
</pre>
</blockquote>

It is important to note that in the C type system, a multidimensional
array <tt>a[][]</tt> is <b>NOT</b> equivalent to a single pointer
<tt>*a</tt> or a double pointer such as <tt>**a</tt>.  Instead, a
pointer to an array is used (as shown above) where the actual value of
the pointer is the starting memory location of the array.  The
reader is strongly advised to dust off their C book and re-read the
section on arrays before using them with SWIG.

<p>
Array variables are supported, but are read-only by default.  For example:

<blockquote>
<pre>
int   a[100][200];
</pre>
</blockquote>

In this case, reading the variable 'a' returns a pointer of type <tt>int (*)[200]</tt>
that points to the first element of the array <tt>&a[0][0]</tt>.  Trying to modify 'a' results
in an error.  This is because SWIG does not know how to copy data from the target
language into the array.   To work around this limitation, you may want to write
a few simple assist functions like this:

<blockquote>
<pre>
%inline %{
void a_set(int i, int j, int val) {
   a[i][j] = val;
}
int a_get(int i, int j) {
   return a[i][j];
}
%}
</pre>
</blockquote>

To dynamically create arrays of various sizes and shapes, it may be useful to write
some helper functions in your interface.  For example:

<blockquote>
<pre>
// Some array helpers
%inline %{
  /* Create any sort of [size] array */
  int *int_array(int size) {
     return (int *) malloc(size*sizeof(int));
  }
  /* Create a two-dimension array [size][10] */
  int (*int_array_10(int size))[10] {
     return (int (*)[10]) malloc(size*10*sizeof(int));
  }
%}
</pre>
</blockquote>

<h3>Creating read-only variables</h3>

A read-only variable can be created by using the <tt>%readonly</tt>
directive as shown :<p>

<blockquote><pre>
// File : interface.i

int 	a; 			// Can read/write
%readonly
int	b,c,d			// Read only variables
%readwrite
double	x,y			// read/write
</pre></blockquote>

<p>
The <tt>%readonly</tt> directive enables read-only mode until it is
explicitly disabled using the <tt>%readwrite</tt> directive.<p>

Read-only variables are also created when declarations are declared as <tt>const</tt>.
For example:

<blockquote>
<pre>
const int foo;               /* Read only variable */
char * const version="1.0";  /* Read only variable */
</pre>
</blockquote>

<h3>Renaming declarations</h3>

Normally, the name of a C function is used as the name of the command
added to the target scripting language. However, this name may
conflict with a keyword or already existing function in the scripting
language. To resolve a name conflict, use the <tt>%name</tt>
directive as shown :<p>

<p>
<blockquote><pre>// interface.i

%name(my_print) extern void print(char *);
%name(foo) extern int a_really_long_and_annoying_name;

</pre></blockquote>

SWIG still calls the correct C function, but in this case the
function <tt>print()</tt> will really be called "<tt>my_print()</tt>"
in the target language. <p>

<p>
A more powerful renaming operation can be performed with the<tt>
%rename</tt> directive:<p>

<p>
<blockquote><pre>%rename(newname) oldname;

</pre></blockquote>

<tt>%rename </tt>applies a renaming operation to all future
occurrences of a name. The renaming applies to functions, variables,
class and structure names, member functions, and member data. For
example, if you had two-dozen C++ classes, all with a member function
named `print' (which is a keyword in Python), you could rename them
all to `output' by specifying :<p>

<p>
<blockquote><pre>%rename(output) print; // Rename all `print' functions to `output'
</pre></blockquote>

<p>
SWIG does not currently perform any checks to see if the functions it wraps are
already defined in the target scripting language. However, if you are
careful about namespaces and your use of modules, you can usually
avoid these problems.<p>

<P>
A more powerful variant of %rename can be used to help 
wrap C++ overloaded functions and methods.   This is described a little later in the
C++ section.

<h3>Default/optional arguments</h3>

SWIG supports default arguments in both C and C++ code.  For example:
<p>
<blockquote><pre>int plot(double x, double y, int color=WHITE);

</pre></blockquote>
In this case, SWIG generates wrapper code where the
default arguments are optional. For example, this function could be
used in Tcl as follows :<p>

<p>
<blockquote><pre>% plot -3.4 7.5 				# Use default value
% plot -3.4 7.5 10				# set color to 10 instead

</pre></blockquote>

Although the ANSI C standard does not allow default arguments, default
arguments specified in a SWIG interface work with both C and C++.

<h3>Pointers to functions and callbacks</h3>

Occasionally, a C library may include functions that expect to receive
pointers to functions--possibly to serve as callbacks. SWIG
provides full support for function pointers provided that the callback
functions are defined in C and not in the target language.  For example,
consider a function like this:

<blockquote><pre>
int binary_op(int a, int b, int (*op)(int,int));
</pre></blockquote>
<p>

When you first wrap something like this into an extension module, you
may find the function to be impossible to use.  For instance, in Python:

<blockquote><pre>
>>> def add(x,y):
...     return x+y
...
>>> binary_op(3,4,add)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: Type error. Expected _p_f_int_int__int
>>>
</pre>
</blockquote>

The reason for this error is that SWIG doesn't know how to map a scripting
language function into a C callback.  However, existing C functions can
be used as arguments provided you install them as constants.
The easiest way to do this is to use the <tt>%constant</tt> directive like this:

<blockquote><pre>
/* Function with a callback */
int binary_op(int a, int b, int (*op)(int,int));

/* Some callback functions */
%constant int add(int,int);
%constant int sub(int,int);
%constant int mul(int,int);
</pre></blockquote>

In this case, <tt>add</tt>, <tt>sub</tt>, and <tt>mul</tt> become function pointer
constants in the target scripting language.  This allows you to use them as follows:

<blockquote>
<pre>
>>> binary_op(3,4,add)
7
>>> binary_op(3,4,mul)
12
>>>
</pre>
</blockquote>

Unfortunately, by declaring the callback functions as constants, they are no longer accesible
as functions. For example:

<blockquote>
<pre>
>>> add(3,4)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: object is not callable: '_ff020efc_p_f_int_int__int'
>>>
</pre>
</blockquote>

If you want to make a function available as both a callback function and a function, you
can use the <tt>%callback</tt> and <tt>%nocallback</tt> directives like this:

<blockquote>
<pre>
/* Function with a callback */
int binary_op(int a, int b, int (*op)(int,int));

/* Some callback functions */
%callback("%s_cb")
int add(int,int);
int sub(int,int);
int mul(int,int);
%nocallback
</pre></blockquote>

The argument to <tt>%callback</tt> is a printf-style format string that
specifies the naming convention for the callback constants (<tt>%s</tt> gets replaced
by the function name).  The callback mode remains in effect until it is explicitly
disabled using <tt>%nocallback</tt>.  When you do this, the interface now works as follows:

<blockquote>
<pre>
>>> binary_op(3,4,add_cb)
7
>>> binary_op(3,4,mul_cb)
12
>>> add(3,4)
7
>>> mul(3,4)
12
</pre>
</blockquote>

Notice that when the function is used as a callback, special names
such as <tt>add_cb</tt> is used instead.  To call the function
normally, just use the original function name such as <tt>add()</tt>.

<p>
SWIG provides a number of extensions to standard C printf formatting
that may be useful in this context.  For instance, the following
variation installs the callbacks as all upper-case constants such as
<tt>ADD</tt>, <tt>SUB</tt>, and <tt>MUL</tt>:

<blockquote><pre>
/* Some callback functions */
%callback("%(upper)s")
int add(int,int);
int sub(int,int);
int mul(int,int);
%nocallback
</pre></blockquote>

A format string of <tt>"%(lower)s"</tt> converts all characters to lower-case.
A string of <tt>"%(title)s"</tt> capitalizes the first character and converts the
rest to lower case.

<p>
And now, a few final notes about function pointer support.  Although SWIG
does not normally allow callback functions to be written in the target language, this
can be accomplished with the use of typemaps and other advanced SWIG features.
Generally speaking, this is accomplished by writing a C stub that serves as the
callback but which transfers control back to the scripting language interpreter.

<h2>Structures, unions, and object oriented C programming</h2>

If SWIG encounters the definition of a structure or union, it will
create a set of accessor functions for you. Although SWIG does not need
structure definitions to build an interface, providing definitions
make it possible to access structure members. The accessor functions
generated by SWIG simply take a pointer to an object and allow access
to an individual member. For example, the declaration :<p>

<p>
<blockquote><pre>struct Vector {
	double x,y,z;
}

</pre></blockquote>

gets transformed into the following set of accessor functions :<p>

<p>
<blockquote><pre>double Vector_x_get(Vector *obj) {
	return obj-&gt;x;
}
double Vector_y_get(Vector *obj) { 
	return obj-&gt;y;
}
double Vector_z_get(Vector *obj) { 
	return obj-&gt;z;
}
void Vector_x_set(Vector *obj, double value) {
	obj-&gt;x = value;
}
void Vector_y_set(Vector *obj, double value) {
	obj-&gt;y = value;
}
void Vector_z_set(Vector *obj, double value) {
	obj-&gt;z = value;
}
</pre></blockquote>

<h3> Typedef and structures</h3>

SWIG supports the following construct which is quite common in C
programs :<p>

<p>
<blockquote><pre>typedef struct {
	double x,y,z;
} Vector;

</pre></blockquote>

When encountered, SWIG will assume that the name of the object is
`Vector' and create accessor functions like before. If two different
names are used like this :<p>

<p>
<blockquote><pre>typedef struct vector_struct {
	double x,y,z;
} Vector;

</pre></blockquote>

the name `Vector' will still be used instead of "vector_struct".<p>

<h3> Character strings and structures</h3>

Structures involving character strings require some care. SWIG assumes
that all members of type <tt>char *</tt> have been dynamically
allocated using <tt>malloc()</tt> and that they are NULL-terminated
ASCII strings. When such a member is modified, the previously contents
will be released, and the new contents allocated. For example :<p>

<p>
<blockquote><pre>%module mymodule
...
struct Foo {
	char *name;
	...
}

</pre></blockquote>

This results in the following accessor functions :<p>

<p>
<blockquote><pre>char *Foo_name_get(Foo *obj) {
	return Foo-&gt;name;
}

char *Foo_name_set(Foo *obj, char *c) {
	if (obj-&gt;name) free(obj-&gt;name);
	obj-&gt;name = (char *) malloc(strlen(c)+1);
	strcpy(obj-&gt;name,c);
	return obj-&gt;name;
}
</pre></blockquote>

<p>
If this behavior differs from what you need in your applications,
the SWIG "memberin" typemap can be used to change it.  See the
typemaps chapter for details.

<h3>Array members</h3>

Arrays may appear as the members of structures, but they will be
read-only. SWIG will write an accessor function that returns the
pointer to the first element of the array, but will not write a
function to change the contents of the array itself. 
When this
situation is detected, SWIG generates a warning message such as the
following :<p>

<p>
<blockquote><pre>interface.i:116. Warning. Array member will be read-only

</pre></blockquote>

To eliminate the warning message, typemaps can be used, but this is
discussed in a later chapter.  In many cases, the warning message is
harmless.

<h3>C constructors and destructors </h3>

When wrapping structures, it is generally useful to have a
mechanism for creating and destroying objects.  You can write this
code yourself, by appropriate call to <tt>malloc()</tt>.  However,
SWIG will generate functions for you automatically if you use C++
syntax like this:

<p>
<blockquote><pre>%module mymodule
...
struct Vector {
        Vector();       // Tell SWIG to create a C constructor
        ~Vector();      // Tell SWIG to create a C destructor
        double x,y,z;
}

</pre></blockquote>
When used with C code, SWIG now creates two additional functions like this :<p>

<p>
<blockquote><pre>Vector *new_Vector() {
       return (Vector *) malloc(sizeof(Vector));
}

void delete_Vector(Vector *v) {
        free(v);
}

</pre></blockquote>

Note: this behavior only applies when SWIG is used on C code (when the
-c++ is <em>not</em> supplied on the command line).   C++ is handled differently.

<p>
As an alternative to explicitly defining constructors and destructors,
SWIG can also automatically generate them using either a command line
option or a pragma. For example :<p>
<p>
<blockquote><pre>swig -make_default example.i 

</pre></blockquote>
or<p>
<p>
<blockquote><pre>%module foo
...
%pragma make_default 					// Make default constructors
... declarations ...
%pragma no_default					// Disable default constructors

</pre></blockquote>
This works with both C and C++.<p>

<h3> Adding member functions to C structures</h3>

Many scripting languages provide a mechanism for creating classes and
supporting object oriented programming. From a C standpoint, object
oriented programming really just boils down to the process of
attaching functions to structures. These functions normally operate
on an instance of the structure (or object) in some way or another. Although there is a
natural mapping of C++ to such a scheme, there is no direct mechanism
for utilizing it with C code. However, SWIG provides a special
<tt>%addmethods</tt> directive that makes it possible to attach
methods to C structures for purposes of building an object oriented
scripting language interface. Suppose you have a C header file with
the following declaration :<p>
<p>
<blockquote><pre>/* file : vector.h */
...
typedef struct {
	double x,y,z;
} Vector;

</pre></blockquote>

You can make a Vector look alot like a class by writing a SWIG interface like this:

<p>
<blockquote><pre>// file : vector.i
%module mymodule
%{
#include "vector.h"
%}

%include vector.h 				// Just grab original C header file
%addmethods Vector { 				// Attach these functions to struct Vector
	Vector(double x, double y, double z) {
		Vector *v;
		v = (Vector *v) malloc(sizeof(Vector));
		v-&gt;x = x;
		v-&gt;y = y;
		v-&gt;z = z;
		return v;
	}
	~Vector() {
		free(self);
	}
	double magnitude() {
		return sqrt(self-&gt;x*self-&gt;x+self-&gt;y*self-&gt;y+self-&gt;z*self-&gt;z);
	}
	void print() {
		printf("Vector [%g, %g, %g]\n", self-&gt;x,self-&gt;y,self-&gt;z);
	}
};

</pre></blockquote>

Now, when used with shadow classes in Python, you can do things like
this :<p>

<p>
<blockquote><pre>&gt;&gt;&gt; v = Vector(3,4,0) 					# Create a new vector
&gt;&gt;&gt; print v.magnitude()					# Print magnitude
5.0
&gt;&gt;&gt; v.print()					# Print it out
[ 3, 4, 0 ]
&gt;&gt;&gt; del v					# Destroy it
</pre></blockquote>
<p>

The <tt>%addmethods</tt> directive can also be used inside the definition
of the Vector structure. For example:<p>

<blockquote><pre>// file : vector.i
%module mymodule
%{
#include "vector.h"
%}

typedef struct {
	double x,y,z;
	%addmethods {
		Vector(double x, double y, double z) { ... }
		~Vector() { ... }
		...
	}
} Vector;
</pre></blockquote>

<p>
Finally, <tt>%addmethods</tt> can be used to access externally written
functions provided they follow the naming convention used in this
example :<p>

<p>
<blockquote><pre>/* File : vector.c */
/* Vector methods */
#include "vector.h"
Vector *new_Vector(double x, double y, double z) {
	Vector *v;
	v = (Vector *) malloc(sizeof(Vector));
	v-&gt;x = x;
	v-&gt;y = y;
	v-&gt;z = z;
	return v;
}
void delete_Vector(Vector *v) {
	free(v);
}

double Vector_magnitude(Vector *v) {
	return sqrt(v-&gt;x*v-&gt;x+v-&gt;y*v-&gt;y+v-&gt;z*v-&gt;z);
}

// File : vector.i
// Interface file
%module mymodule
%{
#include "vector.h"
%}

typedef struct {
	double x,y,z;
	%addmethods {
		double magnitude();  // This will call Vector_magnitude
		...
	}
} Vector;
</pre>
</blockquote>

A little known feature of the <tt>%addmethods</tt> directive is that
it can also be used to add synthesized attributes or to modify the
behavior of existing data attributes.  For example, suppose you wanted
to make <tt>magnitude</tt> a read-only attribute of <tt>Vector</tt>
instead of a method.  To do this, you might write some code like this:

<blockquote>
<pre>
// Add a new attribute to Vector
%addmethods Vector {
    const double magnitude;
}
// Now supply the implementation of the Vector_magnitude_get function
%{
const double Vector_magnitude_get(Vector *v) {
  return (const double) return sqrt(v-&gt;x*v-&gt;x+v-&gt;y*v-&gt;y+v-&gt;z*v-&gt;z);
}
%}

</pre>
</blockquote>

Now, for all practial purposes, <tt>magnitude</tt> will appear like an attribute
of the object.

<p>
A similar technique can also be used to work with problematic data members.
For example, consider this interface:

<blockquote>
<pre>
struct Person {
   char name[50];
   ...
}
</pre>
</blockquote>

By default, the <tt>name</tt> attribute is read-only because SWIG does not
normally know how to modify arrays.  However, you can rewrite the interface
as follows to change this:

<blockquote>
<pre>
struct Person {
    %addmethods {
       char *name;
    }
...
}

// Specific implementation of set/get functions
%{
char *Person_name_get(Person *p) {
   return p->name;
}
void Person_name_set(Person *p, char *val) {
   strncpy(p->name,val,50);
}
%}
</pre>
</blockquote>

Finally, it should be stressed that even though <tt>%addmethods</tt>
can be used to add new data members, these new members can not require
the allocation of additional storage in the object (e.g., their values must
be entirely synthesized from existing attributes of the structure).

<h3> Nested structures</h3>

Occasionally, a C program will involve structures like this :<p>
<p>
<blockquote><pre>typedef struct Object {
	int objtype;
	union {
		int 	ivalue;
		double	dvalue;
		char	*strvalue;
		void	*ptrvalue;
	} intRep;
} Object;

</pre></blockquote>

When SWIG encounters this, it performs a structure splitting operation
that transforms the declaration into the equivalent of the
following:<p>
<p>
<blockquote><pre>typedef union {
	int 		ivalue;
	double		dvalue;
	char		*strvalue;
	void		*ptrvalue;
} Object_intRep;

typedef struct Object {
	int objType;
	Object_intRep intRep;
} Object;

</pre></blockquote>

SWIG will then create an <tt>Object_intRep</tt> structure for use inside
the interface file. Accessor functions will be created for both
structures. In this case, functions like this would be created :<p>
<p>
<blockquote><pre>Object_intRep *Object_intRep_get(Object *o) {
	return (Object_intRep *) &amp;o-&gt;intRep;
}
int Object_intRep_ivalue_get(Object_intRep *o) {
	return o-&gt;ivalue;
}
int Object_intRep_ivalue_set(Object_intRep *o, int value) {
	return (o-&gt;ivalue = value);
}
double Object_intRep_dvalue_get(Object_intRep *o) {
	return o-&gt;dvalue;
}
... etc ...

</pre></blockquote>

Although this process is a little hairy, it works like you would expect in the
target scripting language--especially when shadow classes are used.  For instance, in Perl:

<p>
<blockquote><pre># Perl5 script for accessing nested member
$o = CreateObject(); 				# Create an object somehow
$o-&gt;{intRep}-&gt;{ivalue} = 7 				# Change value of o.intRep.ivalue
</pre></blockquote>

<p>
If you have a lot nested structure declarations, it is
advisable to double-check them after running SWIG. Although,
there is a good chance that they will work, you may have to
modify the interface file in certain cases.

<h3>Other things to note about structure wrapping</h3>

SWIG doesn't care if the definition of a structure exactly matches
that used in the underlying C code (except in the case of nested
structures). For this reason, there are no problems omitting
problematic members or simply omitting the structure definition
altogether. If you are happy passing pointers around, this can
be done without ever giving SWIG a structure definition.<p>

<p>
Starting with SWIG1.3, a number of improvements have been made to SWIG's
code generator. Specifically, even though structure access has been described
in terms of high-level accessor functions such as this,

<blockquote>
<pre>
double Vector_x_get(Vector *v) {
   return v->x;
}
</pre>
</blockquote>

most of the generated code is actually inlined directly into wrapper
functions.  Therefore, no function <tt>Vector_x_get()</tt> actually
exists in the generated wrapper file.  For example, when creating a Tcl module,
the following function is generated instead:

<blockquote>
<pre>
static int
_wrap_Vector_x_get(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    struct Vector *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Vector_x_get self ",&arg0, SWIGTYPE_p_Vector) == TCL_E
RROR) return TCL_ERROR;
    result = (double ) (arg0->x);
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}
</pre>
</blockquote>

The only exception to this rule are methods defined with <tt>%addmethods</tt>.  In this
case, the added code is contained in a separate function.

<p>
Finally, it is important to note that most language modules may choose to
build a more advanced interface. Although you may never use the low-level
interface described here, most of SWIG's language modules use it in
some way or another.

<h2> C++ support</h2>

SWIG's support for C++ is an extension of the support for C functions,
variables, and structures.  However, because of its sheer complexity
and the fact that C++ is nearly impossible to integrate with itself
let alone any other language, SWIG only provides support for a moderate
subset of C++ features.
<p>
This section describes SWIG's low-level access to C++ declarations. In
many instances, this low-level interface may be hidden by shadow
classes or an alternative calling mechanism (this is usually language
dependent and is described in detail in later chapters).<p>

<h3> Supported C++ features</h3>

SWIG supports the following C++ features :<p>
<p>
<ul>
<li>Simple class definitions
<li>Constructors and destructors
<li>Virtual functions
<li>Public inheritance (including multiple inheritance)
<li>Static functions
<li>References
<li>Simple templates
<li>Pointers to members
</ul>

<p>
The following C++ features are not currently supported :<p>

<p>
<ul>
<li>Operator overloading
<li>Function and method overloading (without renaming)
<li>Nested classes
<li>Namespaces
<li>Complicated templates (probably)
</ul>

<p>
SWIG's C++ support has gradually been improved over the years so some
of these limitations may be lifted in a future release.  However, we make no promises.

<h3> C++ example</h3>
The following code shows a SWIG interface file for a simple C++
class.<p>

<p>
<blockquote><pre>%module list
%{
#include "list.h"
%}

// Very simple C++ example for linked list

class List {
public:
  List();
  ~List();
  int  search(char *value);
  void insert(char *);
  void remove(char *);
  char *get(int n);
  int  length;
static void print(List *l);
};
</pre></blockquote>

<p>
When compiling C++ code, it is critical that SWIG be called with the
`<tt>-c++</tt>' option. This changes the way a number of critical
features such as memory management are handled. It
also enables the recognition of C++ keywords. Without the <tt>-c++</tt>
flag, SWIG will either issue a warning or a large number of syntax
errors if it encounters C++ code in an interface file.<p>

<h3>Constructors and destructors</h3>

C++ constructors and destructors are translated into accessor
functions such as the following :<p>

<p>
<blockquote><pre>List * new_List(void) {
	return new List;
}
void delete_List(List *l) {
	delete l;
}

</pre></blockquote>
If a C++ class does not define any public constructors or
destructors, SWIG will automatically create a default constructor or 
destructor.   However, there are a few rules that define this behavior:

<ul>
<li>A default constructor is not created unless all bases classes allow a 
default constructor.

<p>
<li>Default constructors and destructors are not created if a class
defines constructors or destructors in a private: or protected: section.

<p>
<li>Default constructors and destructors are not created if any base
class defines a private default constructor or a private destructor.
</ul>

SWIG should never generate a constructor or destructor for a class in which
it is illegal to do so.   However, if it is necessary to disable the
default constructor/destructor creation, the %pragma no_default directive
can be used:

<blockquote>
<pre>
%pragma nodefault;   // Disable creation of constructor/destructor
class Foo {
...
};
%pragma makedefault;
</pre>
</blockquote>

<h3> Member functions</h3>

All member functions are translated into accessor functions like this :<p>
<p>
<blockquote><pre>int List_search(List *obj, char *value) {
	return obj-&gt;search(value);
}

</pre></blockquote>

This translation is the same even if the member function has been
declared as <tt>virtual</tt>.

<h3> Static members</h3>

Static member functions are called directly without making any special
transformations. For example, the static member function
<tt>print(List *l)</tt> directly invokes <tt>List::print(List *l)</tt>
in the generated wrapper code.

<h3> Member data</h3>

Member data is handled in exactly the same manner as for C
structures. A pair of accessor functions will be created. For example
:<p>

<p>
<blockquote><pre>int List_length_get(List *obj) {
	return obj-&gt;length;
}
int List_length_set(List *obj, int value) {
	obj-&gt;length = value;
	return value;
}

</pre></blockquote>

A read-only member can be created using the <tt>%readonly</tt> and
<tt>%readwrite</tt> directives. For example, we probably wouldn't want
the user to change the length of a list so we could do the following
to make the value available, but read-only.<p>

<p>
<blockquote><pre>class List {
public:
...
%readonly
	int length;
%readwrite
...
};
</pre></blockquote>

Similarly, all data attributes declared as <tt>const</tt> are wrapped as read-only members.

<h3>Protection</h3>

SWIG can only wrap class members that are declared public. Anything
specified in a private or protected section will simply be ignored. To
simplify your interface file, you may want to consider eliminating all
private and protected declarations (if you've copied a C++ header file
for example).<p>

<p>
By default, members of a class definition are assumed to be private
until you explicitly give a `<tt>public:</tt>' declaration (This is
the same convention used by C++).<p>

<h3>Enums and constants</h3>

Enumerations and constants placed in a class definition are mapped
into constants with the classname as a prefix. For example :<p>
<p>
<blockquote><pre>class Swig {
public:
	enum {ALE, LAGER, PORTER, STOUT};
};

</pre></blockquote>
Generates the following set of constants in the target scripting language :<p>
<p>
<blockquote><pre>Swig_ALE = Swig::ALE
Swig_LAGER = Swig::LAGER
Swig_PORTER = Swig::PORTER
Swig_STOUT = Swig::STOUT

</pre></blockquote>

Members declared as <tt>const</tt> are wrapped as read-only members and do not create constants.

<h3>References</h3>

C++ references are supported, but SWIG handles them internally as pointers. For example,
a declaration like this :<p>
<p>
<blockquote><pre>class Foo {
public:
	double bar(double &amp;a);
}
</pre></blockquote>
<p>
is accessed using a function similar to this:<p>
<p>
<blockquote><pre>double Foo_bar(Foo *obj, double *a) {
	obj-&gt;bar(*a);
}

</pre></blockquote>

Functions that return a reference are remapped to return a pointer instead.
For example:

<blockquote><pre>
class Bar {
public:
     double &spam();
};
</pre>
</blockquote>

Generates code like this:

<blockquote>
<pre>
double *Bar_spam(Bar *obj) {
   double &result = obj->spam();
   return &result;
}
</pre>
</blockquote>

<h3>Inheritance</h3>

SWIG supports basic C++ public inheritance of classes and allows both
single and multiple inheritance. The SWIG type-checker knows about the
relationship between base and derived classes and allows pointers
to any object of a derived class to be used in functions of a base
class. The type-checker properly casts pointer values and is safe to
use with multiple inheritance.

<p> SWIG does not support private or protected inheritance (it is
parsed, but ignored).<p>

<p>
The following example shows how SWIG handles inheritance. For clarity,
the full C++ code has been omitted.<p>

<p>
<blockquote><pre>// shapes.i
%module shapes
%{
#include "shapes.h"
%}

class Shape {
public:
        double x,y;
	virtual double area() = 0;
	virtual double perimeter() = 0;
	void    set_location(double x, double y);
};
class Circle : public Shape {
public:
	Circle(double radius);
	~Circle();
	double area();
	double perimeter();
};
class Square : public Shape {
public:
	Square(double size);
	~Square();
	double area();
	double perimeter();
}
</pre></blockquote>

<p>
When wrapped into Perl5, we can now perform the following operations
:<p>

<p>
<blockquote><pre>beazley@slack% perl5.003
use shapes;
$circle = shapes::new_Circle(7);
$square = shapes::new_Square(10);
print shapes::Circle_area($circle),"\n";
# Notice use of base class below
print shapes::Shape_area($circle),"\n";
print shapes::Shape_area($square),"\n";
shapes::Shape_set_location($square,2,-3);
print shapes::Shape_perimeter($square),"\n";
&lt;ctrl-d&gt;
153.93804004599999757
153.93804004599999757
100.00000000000000000
40.00000000000000000
 
</pre></blockquote>
In this example,  Circle and Square objects have been created.  Member
functions can be invoked on each object by making calls to
<tt>Circle_area</tt>, <tt>Square_area</tt>, and so on. However, the same
results can be accomplished by simply using the <tt>Shape_area</tt>
function on either object.<p>

<p>
One important point concerning inheritance is that the low-level
accessor functions are only generated for classes in which they are
actually declared.  For instance, in the above example, the method
<tt>set_location()</tt> is only accessible as
<tt>Shape_set_location()</tt> and not as
<tt>Circle_set_location()</tt> or <tt>Square_set_location()</tt>.  Of
course, the <tt>Shape_set_location()</tt> function will accept any
kind of object derived from Shape.  Similarly, accessor functions for
the attributes <tt>x</tt> and <tt>y</tt> are generated as
<tt>Shape_x_get()</tt>, <tt>Shape_x_set()</tt>,
<tt>Shape_y_get()</tt>, and <tt>Shape_y_set()</tt>.  Functions such as
<tt>Circle_x_get()</tt> are not available--instead you should use
<tt>Shape_x_get()</tt>.


<p>
Although the low-level C-like interface is functional, most language
modules also produce a higher level OO interface using a technique
known as shadow classing.  This approach is described shortly and can be
used to provide a more natural C++ interface.

<h3>Renaming</h3>

C++ member functions and data can be renamed with the <tt>%name</tt>
directive. The <tt>%name</tt> directive only replaces the member
function name. For example :<p>

<p>
<blockquote><pre>class List {
public:
  List();
%name(ListSize) List(int maxsize);
  ~List();
  int  search(char *value); 
%name(find)    void insert(char *); 
%name(delete)  void remove(char *); 
  char *get(int n);
  int  length;
static void print(List *l);
};

</pre></blockquote>

This will create the functions <tt>List_find</tt>,
<tt>List_delete</tt>, and a function named <tt>new_ListSize</tt> for
the overloaded constructor.<p>
<p>
The <tt>%name </tt>directive can be applied to all members including
constructors, destructors, static functions, data members, and
enumeration values.<p>
<p>
The class name prefix can also be changed by specifying <p>
<p>
<blockquote><pre>%name(newname) class List {
...
}
</pre></blockquote>

<h3>Wrapping Overloaded Functions and Methods</h3>

This section describes the problem of wrapping overloaded C++
functions and methods.  This has long been a limitation of SWIG that
has only recently been addressed (primarily because we couldn't quite
figure out to do it without causing head-explosion).  However, in
order to understand the reasoning behind the current solution, it is
important to better understand the problem.

<p>
In C++, functions and methods can be overloaded by declaring them with
different type signatures.  For example:

<blockquote>
<pre>
void foo(int);
void foo(double);
void foo(Bar *b, Spam *s, int );
</pre>
</blockquote>

Later, when a call to function <tt>foo()</tt> is made, the
determination of which function to invoke is made by looking the types
of the arguments.  For example:

<blockquote>
<pre>
int x;
double y;
Bar *b;
Spam *s;
int z;
...
foo(x);        // Calls foo(int)
foo(y);        // Calls foo(double)
foo(b,s,z);    // Calls foo(Bar *, Spam *, int)
</pre>
</blockquote>

It is important to note that the selection of the overloaded method or
function is made by the C++ compiler and occurs at <b>compile
time</b> and not while your program runs.

<p>
Internally to the C++ compiler, overloaded functions are mapped to unique
identifiers using a name-mangling technique where the arguments are used to create
a unique type signature which is appended to the name.  This produces 
three unique function names that might look like this:

<blockquote>
<pre>
void foo__Fi(int);
void foo__Fd(double);
void foo__FP3BarP4Spami(Bar *, Spam *, int);
</pre>
</blockquote>

The implementation of overloaded methods in C++ is difficult to
translate directly to a scripting language environment because it
relies on static type-checking and compile-time binding of
methods--neither of which map to the dynamically typed
environment of a scripting language interpreter.  For example,
in Python, it is simply impossible to define three entirely different
versions of a function with exactly the same name.    The repeated
definitions would simply overwrite the previous definition.

<p>
To solve the overloading problem, let's first look at several approaches that have
been proposed as solutions, but which are <b>NOT</b> used to solve
the overloading problem in SWIG.

<ul>
<li><b>Explicit renaming</b>.  In earlier versions of SWIG, the only
way to handle overloading was to explicitly rename overloaded methods
to a unique name using the <tt>%name</tt> directive.  For example:

<blockquote>
<pre>
void foo(int);
%name(foo_d) foo(double);
%name(foo_barspam) foo(Bar *, Spam *, int);
</pre>
</blockquote>

Although this certainly works, it is extremely annoying to explicitly
annotate every class with a bunch of <tt>%name</tt> directives like that.  It fact,
it's so annoying that this really isn't a viable solution at all (except in
cases where there is very little overloading).  Dave sincerely apologizes for ever
thinking that this approach was a good idea--however, let's try to forget the past :-).

<p>
<li><b>Name Mangling</b>.  Another approach to overloading would be to
automatically generate name-mangled versions of the functions.
Although this would definitely work, it would also make the scripting
language interface extremely annoying to use.  For instance, does anyone
really want to type things like this in their program?

<blockquote>
<pre>
foo__FP3BarP4Spami(b,s,i);
</pre>
</blockquote>

Needless to say, this approach is not used by SWIG.

<p>
<li><b>Simplified Name Mangling</b>.  An alternative name mangling
approach would be to generate a simplified name mangling.  For
example, maybe you could just take the first letter of each type and
use it as the signature.  For example:

<blockquote>
<pre>
void foo(int);                  // becomes foo_i(int)
void foo(double);               // becomes foo_d(int)
void foo(Bar *, Spam *, int);   // becomes foo_BSi(int)
</pre>
</blockquote>

Although a lot more readable than the fully mangled version, this now has the
problem of naming clashes.  For instance, what is supposed to happen with these
two functions?

<blockquote>
<pre>
void foo(int i);               // ?????
void foo(instance *obj);       // ?????
</pre>
</blockquote>

Also, what happens if the mangled version happens to match a legitimate identifier
name used elsewhere in the program?  One could use the <tt>%name</tt> directive to
resolve such a conflict, but this tends to defeat the whole point. Clearly there is a problem here.

<p>
<li><b>Numbering</b>.  A really simple solution might be to number all of
the overloaded methods in order of definition. For example:

<blockquote>
<pre>
void foo(int);                  // becomes foo_1(int)
void foo(double);               // becomes foo_2(int)
void foo(Bar *, Spam *, int);   // becomes foo_3(int)
</pre>
</blockquote>

Unfortunately, the numbering doesn't give any clues about what the
actual function is.  Also, if the order changes or a new function is
added, all of the numbers might change--breaking all of the scripts
written against the interface.  There is also a tiny problem
of naming methods with inheritance:

<blockquote>
<pre>
class X {
public:
   virtual void foo(int);                // X_foo_1
   virtual void foo(double);             // X_foo_2
};

class Y {
public:
   virtual void foo(long);               // Y_foo_1
   virtual void foo(Bar *, Spam *, int); // Y_foo_2
};

class Z : public X, public Y {
public:
   virtual void foo(double);             // Z_foo_1 ??? Mismatch X_foo_2
   virtual void foo(Bar *, Spam *, int); // Z_foo_2 ??? 
  // What happens to X_foo_1 and Y_foo_1 here?
};
</pre>
</blockquote>

Due to the problems of making names consistent across class
hierarchies, it seems unlikely that a numbering scheme would ever work
all that well except in very simple cases. 

<p>
<li><b>Dynamic dispatch</b>.  By far, the most powerful approach to the problem
would be to implement some kind of dynamic dispatch mechanism in the
code generator.  For example, you might generate some code roughly 
equivalent to this pseudocode:

<blockquote>
<pre>
wrap_foo(args):
   if len(args) == 3:
        if (args[0].type == Bar and 
           args[1].type == Spam and
           args[2].type == int):
               foo((Bar *) arg[0], (Spam *) arg[1], (int) arg[2])
   else if len(args) == 1:
        if args[0].type == int:
               foo((int) args[0])
        else if args[0].type == double:
               foo((double) args[0])
   else:
        raise "Bad arguments to foo"
</pre>
</blockquote>

Unfortunately there are serious problems with this approach as
well. First, the addition of dynamic dispatch code introduces a huge
performance hit on the execution time of overloaded methods since the
arguments to each method call have to first be examined to figure out
which function to dispatch.  Although the sample code above doesn't
look too bad, this procedure may involve interaction with the SWIG
type-checker, typemaps (a SWIG customization scheme), and other more
advanced parts of the interpreter.  A more nasty problem has to do
with functions that can accept the same type of scripting object.  For
example, if you have this,

<blockquote>
<pre>
void foo(int);
void foo(double);
</pre>
</blockquote>

the <tt>foo(double)</tt> function will probably accept both a
scripting language integer and a floating point number as an argument.
As a result, it's possible for the <tt>foo(double)</tt> function to
hide the integer function <tt>foo(int)</tt> if arguments aren't
checked in the correct order.  For instance, if you switch the order
of the two functions in the interface file, does one suddenly become
unavailable?  To deal with this problem, you might decide to make all
of the overloaded functions additionally available through name mangling.  However,
that now introduces all of the problems of name mangling plus all of
the problems of dynamic dispatch!  

<p>
The bottom line is that even though some kind of dynamic dispatch
scheme may be the "best" way to support overloading, it is extremely
difficult to implement and it has some serious shortcomings including
performance, hiding of functions, and poor interaction with some of
SWIG's customization features.

<p>
<li><b>Trial Execution</b>.  An approach that is somewhat similar to dynamic dispatch
would be to implement a trial execution scheme.   In this case, each overloaded
function would generate a unique wrapper function, possibly with a name-mangled name. 
For example, something like this:

<blockquote>
<pre>
wrap_foo_i(args) {
    ...
    foo((int) arg[0]);
    ...
}
wrap_foo_d(args) {
    ...
    foo((double) arg[0]);
    ...
}
wrap_foo_BSi(args) {
    ...
    foo((Bar *) arg[0], (Spam *) arg[1], (int) arg[2]);
    ...
}
</pre>
</blockquote>

Next, a top-level wrapper could be written like this:

<blockquote>
<pre>
wrap_foo(args) {
   if (wrap_foo_i(args) == SUCCESS) return SUCCESS;
   if (wrap_foo_d(args) == SUCCESS) return SUCCESS;
   if (wrap_foo_BSi(args) == SUCCESS) return SUCCESS;
   return ERROR, "No matching function foo";
}
</pre>
</blockquote>
Like dynamic dispatch, this solution suffers a large
performance penalty from trying to start the execution of each
possible function.  In fact, the impact may be worse since the only
way to determine the proper function is to try all possibilities until
no errors occur (dynamic dispatch could make more intelligent
choices).  Another problem is that a function might throw an ERROR for
a different reason than improper arguments (maybe the arguments were
okay, but something happened during execution).  Therefore, you would
need to have some kind of special error condition to indicate an error
in argument conversion.  This approach also relies on name mangling,
raising the limitations already mentioned.

<p>
Of all of the schemes mentioned so far, trial execution has the
highest probability of actually being added to SWIG in the future.
However, no such support is currently available or planned.

<p>
<li><b>Don't allow overloading</b>.  Easy to implement and extremely annoying to
C++ programmers, but not particularly useful.
</ul>

Alas, what to do about overloading?

<p>
Starting with SWIG-1.3.7, a very simple enhancement has been added to
the <tt>%rename</tt> directive to help disambiguate overloaded
functions and methods.  Normally, the <tt>%rename</tt> directive is
used to rename a declaration everywhere in an interface file.  For
example, if you write this,

<blockquote>
<pre>
%rename(foo) bar;
</pre>
</blockquote>

all occurences of "bar" will be renamed to "foo" (this feature was
described a little earlier in this chapter in the section "Renaming
Declarations").  By itself, this doesn't do anything to help fix
overloaded methods.  However, the <tt>%rename</tt> can now be
parameterized as shown in this example:

<blockquote>
<pre>
/* Forward renaming declarations */
%rename(foo_i) foo(int); 
%rename(foo_d) foo(double);
...
void foo(int);           // Becomes 'foo_i'
void foo(char *c);       // Stays 'foo' (not renamed)

class Spam {
public:
   void foo(int);      // Becomes 'foo_i'
   void foo(double);   // Becomes 'foo_d'
   ...
};
</pre>
</blockquote>

Since, the <tt>%rename</tt> declaration is used to declare a renaming in advance, it can be
placed at the start of an interface file.  This makes it possible to apply consistent name
resolution without having to modify header files. For example:

<blockquote>
<pre>
%module foo

/* Rename these overloaded functions */
%rename(foo_i) foo(int); 
%rename(foo_d) foo(double);

%include "header.h"
</pre>
</blockquote>

When used in this simple form, the renaming is applied to all global functions and member functions
that match the prototype.   If you only want the renaming to apply to a certain scope, the C++
scope resolution operator (::) can be used.  For example:

<blockquote>
<pre>
%rename(foo_i) ::foo(int);      // Only rename foo(int) in the global scope.
                                // (will not rename class members)

%rename(foo_i) Spam::foo(int);  // Only rename foo(int) if it appears in class Spam
</pre>
</blockquote>

When a renaming operator is applied to a class as in <tt>Spam::foo(int)</tt>, it is applied to
that class and all derived classes.   This can be used to apply a consistent renaming across
an entire class hierarchy with only a few declarations.  For example:

<blockquote>
<pre>
%rename(foo_i) Spam::foo(int);
%rename(foo_d) SPam::foo(double);

class Spam {
public:
   virtual void foo(int);      // Renamed to foo_i
   virtual void foo(double);   // Renamed to foo_d
   ...
};

class Bar : public Spam {
public:
   virtual void foo(int);      // Renamed to foo_i
   virtual void foo(double);   // Renamed to foo_d
...
};

class Grok : public Bar {
public:
   virtual void foo(int);      // Renamed to foo_i
   virtual void foo(double);   // Renamed to foo_d
...
};
</pre>
</blockquote>

A final special form of <tt>%rename</tt> can be used to apply a renaming just to class
members:

<blockquote>
<pre>
%rename(foo_i) *::foo(int);   // Only rename foo(int) if it appears in a class.
</pre>
</blockquote>

Note: the *:: syntax is non-standard, but the '*' is meant to be a wildcard
that matches any class name.

<p>
Although the <tt>%rename</tt> approach does not automatically solve the overloading
problem for you (you have to supply a name), SWIG's error messages have been improved to help.
For example, consider this interface file:

<blockquote>
<pre>
%module foo

class Spam {
public:
   void foo(int);
   void foo(double);
   void foo(Bar *, Spam *, int);
};
</pre>
</blockquote>

If you run SWIG on this file, you will get the following error messages:

<blockquote>
<pre>
foo.i:6. Overloaded declaration ignored.  Spam::foo(double )
foo.i:5. Previous declaration is Spam::foo(int )
foo.i:7. Overloaded declaration ignored.  Spam::foo(Bar *,Spam *,int )
foo.i:5. Previous declaration is Spam::foo(int )
</pre>
</blockquote>

The error messages indicate the problematic functions along with their
type signature.  In addition, the previous definition is supplied.
Therefore, you can just look at these errors and decide how you want
to handle the overloaded functions.  For example:

<blockquote>
<pre>
%module foo
%rename(foo_d)         Spam::foo(double);               // name foo_d
%rename(foo_barspam)   Spam::foo(Bar *, Spam *, int);   // name foo_barspam
...
class Spam { 
...
};
</pre>
</blockquote>

And again, for a class hierarchy, you may be able to solve all of the
problems by just renaming members in the base class--those renamings
automatically propagate to all derived classes.

<p>
A few final notes about the enhanced <tt>%rename</tt> directive:

<ul>
<li>The scope qualifier (::) can also be used on simple names.  For example:
<blockquote>
<pre>
%rename(bar) ::foo;       // Rename foo to bar in global scope only
%rename(bar) Spam::foo;   // Rename foo to bar in class Spam only
%rename(bar) *::foo;      // Rename foo in classes only
</pre>
</blockquote>

<p>
<li>Name matching tries to find the most specific match that is
defined.  A qualified name such as <tt>Spam::foo</tt> always has
higher precedence than an unqualified name <tt>foo</tt>.
<tt>Spam::foo</tt> has higher precedence than <tt>*::foo</tt> and
<tt>*::foo</tt> has higher precedence than <tt>foo</tt>.  A
parameterized name has higher precedence than an unparameterized name
within the same scope level.  However, an unparameterized name with a
scope qualifier has higher precedence than a parameterized name in
global scope (e.g., a renaming of <tt>Spam::foo</tt> takes precedence
over a renaming of <tt>foo(int)</tt>).

<p>
<li>
The order in which <tt>%rename</tt> directives are defined does not matter
as long as they appear before the declarations to be renamed.  Thus, there is no difference
between saying:

<blockquote>
<pre>
%rename(bar) foo;
%rename(foo_i) Spam::foo(int);
%rename(Foo) Spam::foo;
</pre>
</blockquote>

and this

<blockquote>
<pre>
%rename(Foo) Spam::foo;
%rename(bar) foo;
%rename(foo_i) Spam::foo(int);
</pre>
</blockquote>

(the declarations are not stored in a linked list and order has no
importance).  Of course, a repeated <tt>%rename</tt> directive will
change the setting for a previous <tt>%rename</tt> directive if exactly the 
same name, scope,  and parameters are supplied.

<p>
<li>For multiple inheritance where renaming rules are defined for multiple base classes,
the first renaming rule found on a depth-first traversal of the class hierarchy 
is used.

</ul>

<h3>Adding new methods</h3>

New methods can be added to a class using the <tt>%addmethods</tt>
directive. This directive is primarily used in conjunction with shadow
classes to add additional functionality to an existing class. For
example :<p>
<p>
<blockquote><pre>%module vector
%{
#include "vector.h"
%}

class Vector {
public:
	double x,y,z;
	Vector();
	~Vector();
	... bunch of C++ methods ...
	%addmethods {
		char *__str__() {
			static char temp[256];
			sprintf(temp,"[ %g, %g, %g ]", v-&gt;x,v-&gt;y,v-&gt;z);
			return &amp;temp[0];
		}
	}
};
</pre></blockquote>
<p>

This code adds a<tt> __str__</tt> method to our class for producing a
string representation of the object. In Python, such a method would
allow us to print the value of an object using the <tt>print</tt>
command. <p>

<p>
<blockquote><pre>&gt;&gt;&gt;
&gt;&gt;&gt; v = Vector();
&gt;&gt;&gt; v.x = 3
&gt;&gt;&gt; v.y = 4
&gt;&gt;&gt; v.z = 0
&gt;&gt;&gt; print(v)
[ 3.0, 4.0, 0.0 ]
&gt;&gt;&gt;

</pre></blockquote>

The<tt> %addmethods</tt> directive follows all of the same conventions
as its use with C structures.<p>

<h3>Templates</h3>

In all versions of SWIG, template type names may appear anywhere a type
is expected in an interface file.  For example:

<blockquote>
<pre>
void foo(vector&lt;int&gt; *a, int n);
</pre>
</blockquote>

Starting with SWIG-1.3.7, simple C++ template declarations can also be easily wrapped.
For example, consider the following template class declaration:

<p>
<blockquote><pre>// File : list.h
template&lt;class T&gt; class List {
private:
    T *data;
    int nitems;
    int maxitems;
public:
    List(int max) {
      data = new T [max];
      nitems = 0;
      maxitems = max;
    }
    ~List() {
      delete [] data;
    };
    void append(T obj) {
      if (nitems &lt; maxitems) {
        data[nitems++] = obj;
      }
    }
    int length() {
      return nitems;
    }
    T get(int n) {
      return data[n];
    }
};
</pre></blockquote>

By itself, this template declaration is useless--SWIG simply ignores it
because it doesn't know how to generate any code until unless a definition of
<tt>T</tt> is provided.

<p>
To create wrappers for a specific template instantiation, use the <tt>%template</tt> directive like this:

<blockquote>
<pre>
/* Instantiate a few different versions of the template */
%template(intList) List&lt;int&gt;;
%template(doubleList) List&lt;double&gt;;
</pre>
</blockquote>

The argument to <tt>%template()</tt> is the name of the
instantiation in the target language.  Most target languages do not
recognize identifiers such as <tt>List&lt;int&gt;</tt>.  Therefore,
each instantiation of a template has to be associated with a nicely
formatted identifier such as <tt>intList</tt> or <tt>doubleList</tt>.
Furthermore, due to the details of the underlying implementation, the
name you select has to be unused in both C++ and the target scripting
language (e.g., the name must not match any existing C++ typename,
class name, or declaration name).

<p>
Internally, templates are handled by playing some clever tricks with macro
expansion.  Specifically, the <tt>%template(intList) List&lt;int&gt;</tt>
declaration gets expanded into the following code which is then parsed to create an
interface:

<blockquote>
<pre>
// Example of how templates are internally expanded by SWIG
%{
// Define a nice name for the instantiation
typedef List<int> intList;
%}
// Provide a simple class definition with types filled in
class intList {
private:
    int *data;
    int nitems;
    int maxitems;
public:
    intList(int max) {
      data = new int [max];
      nitems = 0;
      maxitems = max;
    }
    ~intList() {
      delete [] data;
    };
    void append(int obj) {
      if (nitems &lt; maxitems) {
        data[nitems++] = obj;
      }
    }
    int length() {
      return nitems;
    }
    int get(int n) {
      return data[n];
    }
};
</pre>
</blockquote>

SWIG can also generate wrappers for function templates using a similar technique.
For example:

<blockquote>
<pre>
// Function template
template<class T> T max(T a, T b) { return a > b ? a : b; }

// Make some different versions of this function
%template(maxint) max&lt;int&gt;;
%template(maxdouble) max&lt;double&gt;;
</pre>
</blockquote>

In this case, <tt>maxint</tt> and <tt>maxdouble</tt> become unique names for specific 
instantiations of the function.

<p>
If your goal is to make someone's head explode more than usual, SWIG
directives such as <tt>%name</tt> and <tt>%addmethods</tt> can be
included directly in template definitions.  Not only that, since
template support is built using the preprocessor, standard C
preprocessor operators such as <tt>#</tt> and <tt>##</tt> can be
applied to template parameters.  For example:

<p>
<blockquote><pre>// File : list.h
template&lt;class T&gt; class List {
   ...
public:
    List(int max);
    ~List();
    ...
    %name(getitem) T get(int index);
    %addmethods {
        char *__str__() {
            /* Make a string representation */
            ...
        }
        /* Return actual type of template instantiation as a string */
        char *ttype() {
            return #T;
        }
    }
};
</pre></blockquote>

In this example, the extra SWIG directives are propagated to <em>every</em> template 
instantiation.  

<p>
In addition, the <tt>%addmethods</tt> directive can be used to add
additional methods to a specific instantiation. For example:

<blockquote>
<pre>
%template(intList) List&lt;int&gt;;

%addmethods intList {
    void blah() {
          printf("Hey, I'm an intList!\n");
    }
};
</pre>
</blockquote>

Needless to say, SWIG's template support provides plenty of opportunities to
break the universe.  That said, an important final point to note is
that <b>SWIG performs no extensive error checking of templates!</b>
Specifically, SWIG does not perform type checking nor does it check to
see if the actual contents of the template declaration make any sense.
Since the C++ compiler will <em>definitely</em> check this when it
compiles the resulting wrapper file, there is no practical reason for
SWIG to duplicate this functionality (besides, none of the SWIG
developers are quite that masochistic).

<h3>Pointers to Members</h3>

Starting with SWIG1.3.7, there is limited parsing support for pointers to C++ class members.
For example:

<blockquote>
<pre>
double do_op(Object *o, double (Object::*callback)(double,double));
extern double (Object::*fooptr)(double,double);
%constant double (Object::*FOO)(double,double) = &Object::foo;
</pre>
</blockquote>

Although these kinds of pointers can be parsed and represented by the
SWIG type system, few language modules know how to handle them due to
implementation differences from standard C pointers.  Readers are
<em>strongly</em> advised to consult an advanced text such as the "The
Annotated C++ Manual" for specific details.

<p>
When pointers to members are supported, the pointer value might appear as a special
string like this:

<blockquote>
<pre>
>>> print example.FOO
_ff0d54a800000000_m_Object__f_double_double__double
>>>
</pre>
</blockquote>

In this case, the hexadecimal digits represent the entire value of the
pointer which usually consists of multiple words on most machines. 

<p>
SWIG's type-checking mechanism is also more limited when working with
member pointers.  Normally SWIG tries to keep track of inheritance
when checking types.  However, no such support is currently provided
for member pointers.

<h3>Partial class definitions</h3>

Since SWIG is still limited in its support of C++, it may be necessary
to use partial class information in an interface file.  However, since
SWIG does not need the entire class specification to work, conditional
compilation can be used to comment out problematic parts.  For example, if you had a nested
class definition, you might do this:

<blockquote>
<pre>
class Foo {
public:
#ifndef SWIG
   class Bar {
   public:
     ...
   };
#endif
   Foo();
  ~Foo();
   ...
};
</pre>
</blockquote>

<p>
Also, as a rule of thumb, SWIG should not be used on raw C++ source
files.  SWIG does not know how to parse C++ declarations that have
been declared outside of their class definition.  No such support is
planned for future releases.

<h2> Code Insertion</h2>

Sometimes it is necessary to insert special code into the resulting
wrapper file generated by SWIG.  For example, you may want to include
additional C code to perform initialization or other operations.
There are four common ways to insert code, but it's useful to know how the
output of SWIG is structured first.<p>

<h3> The output of SWIG</h3>

When SWIG creates its output file, it is broken up into four sections
corresponding to runtime libraries, headers, wrapper functions, and module
initialization code (in that order).   

<ul>
<li><b>Runtime libraries</b>.  <br>
This code is internal to SWIG and is used to include
type-checking and other support functions that are used by the rest of the module.

<p>
<li><b>Header section</b>.  <br>
This is user-defined support code that has been included by 
the <tt>%{ ... %}</tt> directive.  Usually this consists of header files and 
other helper functions.

<p>
<li><b>Wrapper code</b>.  <br>
These are the wrappers generated automatically by SWIG.

<p>
<li><b>Module initialization</b>.  <br>
The function generated by SWIG to initialize
the module upon loading.
</ul>

<h3> Code insertion blocks</h3>

Code is inserted into the appropriate code section by using one
of the following code insertion directives:

<blockquote>
<pre>
%runtime %{
   ... code in runtime section ...
%}

%header %{
   ... code in header section ...
%}

%wrapper %{
   ... code in wrapper section ...
%}

%init %{
   ... code in init section ...
%}
</pre>
</blockquote>

The bare <tt>%{ ... %}</tt> directive is a shortcut that is the same as
<tt>%header %{ ... %}</tt>.

<p>
Everything in a code insertion block is copied verbatim into the output file and is 
not parsed by SWIG.   Most SWIG input files have at least one such block to include header
files and support C code.  Additional code blocks may be placed anywhere in a
SWIG file as needed. <p>

<blockquote><pre>
%module mymodule
%{
#include "my_header.h"
%}
... Declare functions here
%{

void some_extra_function() {
  ...
}
%}
</pre></blockquote>

<p>
A common use for code blocks is to write "helper" functions. These
are functions that are used specifically for the purpose of building
an interface, but which are generally not visible to the normal C
program. For example :<p>
<p>
<blockquote><pre>%{
/* Create a new vector */
static Vector *new_Vector() {
	return (Vector *) malloc(sizeof(Vector));
}

%}
// Now wrap it 
Vector *new_Vector();
</pre></blockquote>

<h3>Inlined code blocks</h3>

Since the process of writing helper functions is fairly common,
there is a special inlined form of code block that is used as follows
:<p>
<p>
<blockquote><pre>%inline %{
/* Create a new vector */
Vector *new_Vector() {
	return (Vector *) malloc(sizeof(Vector));
}
%}

</pre></blockquote>

The <tt>%inline</tt> directive inserts all of the code that follows
verbatim into the header portion of an interface file. The code is
then parsed by both the SWIG preprocessor and parser.
Thus, the above example creates a new command <tt>new_Vector</tt> using only one
declaration. Since the code inside an <tt>%inline %{ ... %}</tt> block
is given to both the C compiler and SWIG, it is illegal to include any
SWIG directives inside the <tt>%{ ... %}</tt> block.<p>

<h3>Initialization blocks</h3>

When code is included in the <tt>%init</tt> section, it is copied directly into the 
module initialization function.  For example, if you needed to perform some extra
initialization, you could write this:
<p>
<blockquote><pre>%init %{
	init_variables();
%}
</pre></blockquote>

<h2>SWIG Preprocessor</h2>

SWIG includes its own enhanced version of the C preprocessor.  The preprocessor
supports the standard preprocessor directives and macro expansion rules.
However, a number of modifications and enhancements have been made.  This
section describes some of these modifications.

<h3>File inclusion</h3>

To include another file into a SWIG interface, use the <tt>%include</tt> directive
like this:

<blockquote>
<pre>
%include "pointer.i"
</pre>
</blockquote>

Unlike, <tt>#include</tt>, <tt>%include</tt> includes each file once (and will not
reload the file on subsequent <tt>%include</tt> declarations).  Therefore, it
is not necessary to use include-guards in SWIG interfaces.

<p>
By default, the <tt>#include</tt> is ignored unless you run SWIG with the
<tt>-includeall</tt> option.   The reason for ignoring traditional includes
is that you often don't want SWIG to try and wrap everything included
in standard header system headers and auxilliary files.

<h3>File imports</h3>

SWIG provides another file inclusion directive with the <tt>%import</tt> directive.
For example:

<blockquote>
<pre>
%import "foo.i"
</pre>
</blockquote>

The purpose of <tt>%import</tt> is to collect certain information from another 
SWIG interface file or a header file without actually generating any wrapper code.
Such information generally includes type declarations (e.g., <tt>typedef</tt>) as well as
C++ classes that might be used as base-classes for class declarations in the interface.
The use of <tt>%import</tt> is also important when SWIG is used to generate
extensions as a collection of related modules.   This is advanced topic and is described
in a later chapter.

<P>
The <tt>-importall</tt> directive tells SWIG to follow all <tt>#include</tt> statements
as imports.    This might be useful if you want to extract type definitions from system 
header files without generating any wrappers.

<h3>Conditional Compilation</h3>

SWIG fully supports the use of <tt>#if</tt>, <tt>#ifdef</tt>,
<tt>#ifndef</tt>, <tt>#else</tt>, <tt>#endif</tt> to conditionally
include parts of an interface.  The following symbols are predefined
by SWIG when it is parsing the interface:

<p>
<blockquote><pre>
SWIG                            Always defined when SWIG is processing a file
SWIGTCL                         Defined when using Tcl
SWIGTCL8                        Defined when using Tcl8.0
SWIGPERL                        Defined when using Perl
SWIGPERL5                       Defined when using Perl5
SWIGPYTHON                      Defined when using Python
SWIGGUILE                       Defined when using Guile
SWIGRUBY                        Defined when using Ruby
SWIGJAVA                        Defined when using Java
SWIGMZSCHEME                    Defined when using Mzscheme        
SWIGWIN                         Defined when running SWIG under Windows
SWIGMAC                         Defined when running SWIG on the Macintosh
</pre></blockquote>

In addition, SWIG defines the following set of standard C/C++ macros:

<blockquote>
<pre>
__LINE__                        Current line number
__FILE__                        Current file name
__STDC__                        Defined to indicate ANSI C
__cplusplus                     Defined when -c++ option used
</pre>
</blockquote>

Interface files can look at these symbols as necessary to change the
way in which an interface is generated or to mix SWIG directives with
C code. These symbols are also defined within the C code generated by
SWIG (except for the symbol `<tt>SWIG</tt>' which is only defined
within the SWIG compiler).<p>

<h3>Macro Expansion</h3>

Traditional preprocessor macros can be used in SWIG interfaces.  Be aware that the <tt>#define</tt> statement
is also used to try and detect constants.  Therefore, if you have something like this in your file,

<blockquote>
<pre>
#ifndef _FOO_H 1
#define _FOO_H 1
...
#endif
</pre>
</blockquote>
you may get some extra constants such as <tt>_FOO_H</tt> showing up in the scripting interface.

<p>
More complex macros can be defined in the standard way. For example:

<blockquote>
<pre>
#define EXTERN extern
#ifdef __STDC__
#define _ANSI(args)   (args)
#else
#define _ANSI(args) ()
#endif
</pre>
</blockquote>

The following operators can be appear in macro definitions:

<ul>
<li><tt>#x</tt><br>
Converts macro argument <tt>x</tt> to a string surrounded by double quotes ("x").

<p>
<li><tt>x ## y</tt><br>
Concatenates x and y together to form <tt>xy</tt>.

<p>
<li><tt>`x`</tt><br>
If <tt>x</tt> is a string surrounded by double quotes, do nothing.  Otherwise, turn into a string
like <tt>#x</tt>.  This is a non-standard SWIG extension.
</ul>

<h3>SWIG Macros</h3>

SWIG provides an enhanced macro capability with the <tt>%define</tt> and <tt>%enddef</tt> directives. 
For example:

<blockquote>
<pre>
%define ARRAYHELPER(type,name)
%inline %{
type *new_ ## name (int nitems) {
   return (type *) malloc(sizeof(type)*nitems);
}
void delete_ ## name(type *t) {
   free(t);
}
type name ## _get(type *t, int index) {
   return t[index];
}
void name ## _set(type *t, int index, type val) {
   t[index] = val;
}
%}
%enddef

ARRAYHELPER(int, IntArray)
ARRAYHELPER(double, DoubleArray)
</pre>
</blockquote>

The primary purpose of <tt>%define</tt> is to define large macros of code.  Unlike normal C preprocessor
macros, it is not necessary to terminate each line with a continuation character (\)--the macro definition
extends to the first occurrence of <tt>%enddef</tt>.    Furthermore, when such macros are expanded,
they are reparsed through the C preprocessor.  Thus, SWIG macros can contain all other preprocessor
directives except for nested <tt>%define</tt> statements.

<p>
The SWIG macro capability is a very quick and easy way to generate large amounts of code.  In fact,
many of SWIG's advanced features and libraries are built using this mechanism.

<h3>Preprocessing and %{ ... %} blocks</h3>

The SWIG preprocessor does not process any text enclosed in a code block %{ ... %}.  Therefore,
if you write code like this,

<blockquote>
<pre>
%{
#ifdef NEED_BLAH
int blah() {
   ...
}
#endif
%}
</pre>
</blockquote>

the contents of the <tt>%{ ... %}</tt> block are copied without
modification to the output (including all preprocessor directives).

<h3>Preprocessing and { ... }</h3>

SWIG always runs the preprocessor on text appearing inside <tt>{ ... }</tt>.  However,
sometimes it is desirable to make a preprocessor directive pass through to the output
file.  For example:

<blockquote>
<pre>
%addmethods Foo {
   void bar() {
      #ifdef DEBUG
       printf("I'm in bar\n");
      #endif
   }
}
</pre>
</blockquote>

By default, SWIG will interpret the <tt>#ifdef DEBUG</tt> statement.   However, if you wanted that code
to actually go into the wrapper file, prefix the preprocessor directives with % like this:

<blockquote>
<pre>
%addmethods Foo {
   void bar() {
      %#ifdef DEBUG
       printf("I'm in bar\n");
      %#endif
   }
}
</pre>
</blockquote>

SWIG will strip the extra <tt>%</tt> and leave the normal preprocessor directive.

<h2>An Interface Building Strategy</h2>

This section describes the general approach for building interface
with SWIG. The specifics related to a particular scripting language
are found in later chapters.<p>

<h3> Preparing a C program for SWIG</h3>

SWIG doesn't require modifications to your C code, but if you feed it
a collection of raw C header files or source code, the results might
not be what you expect---in fact, they might be awful. Here's a series
of steps you can follow to make an interface for a C program :<p>

<p>
<ul>
<li>Identify the functions that you want to wrap. It's probably not
necessary to access every single function in a C program--thus, a
little forethought can dramatically simplify the resulting scripting
language interface. C header files are particularly good source for
finding things to wrap.

<li>Create a new interface file to describe the scripting language
interface to your program.

<li>Copy the appropriate declarations into the interface file or use
SWIG's <tt>%include</tt> directive to process an entire C
source/header file. 

<li>Make sure everything in the interface file uses ANSI C/C++syntax.

<li>Make sure all necessary `<tt>typedef</tt>' declarations and
type-information is available in the interface file.

<li>If your program has a main() function, you may need to rename it
(read on).

<li>Run SWIG and compile.
</ul>
<p>
Although this may sound complicated, the process turns out to be
fairly easy once you get the hang of it. In fact, in most cases, you can
get a rough interface working in 5-10 minutes.

<p>
In the process of building an interface, SWIG may encounter syntax errors or
other problems.  The best way to deal with this is to simply copy the offending
code into a separate interface file and edit it. 

<h3> The SWIG interface file</h3>

The preferred method of using SWIG is to generate separate interface
file. Suppose you have the following C header file :<p>

<blockquote><pre>
/* File : header.h */

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

extern int foo(double);
extern double bar(int, int);
extern void dump(FILE *f);

</pre></blockquote>

A typical SWIG interface file for this header file would look like the
following :<p>

<blockquote><pre>
/* File : interface.i */
%module mymodule
%{
#include "header.h"
%}
extern int foo(double);
extern double bar(int, int);
extern void dump(FILE *f);

</pre></blockquote>
Of course, in this case, our header file is pretty simple so we could
have made an interface file like this as well:<p>

<p>
<blockquote><pre>/* File : interface.i */
%module mymodule
%include header.h
</pre></blockquote>
<p>
Naturally, your mileage may vary.<p>

<h3>Why use separate interface files?</h3>

Although SWIG can parse many header files, it is more common to write a
special <tt>.i</tt> file defining the interface to a package. There
are several reasons why you might want to do this:
<p>
<ul>
<li>It is rarely necessary to access every single function in a large
package. Many C functions might have little or no use in a scripted
environment. Therfore, why wrap them?

<li>Separate interface files provide an opportunity to provide more
precise rules about how an interface is to be constructed.

<li>Interface files can provide more structure and organization.

<li>SWIG can't parse certain definitions that appear in header
files. Having a separate file allows you to eliminate or work around
these problems.

<li>Interface files provide a more precise definition of what the interface
is. Users wanting to extend the system can go to the interface file
and immediately see what is available without having to dig it out of
header files.
</ul>

<h3>Getting the right header files</h3>

Sometimes, it is necessary to use certain header files in order for
the code generated by SWIG to compile properly. Make sure you
include certain header files by using a <tt>%{,%}</tt> block like this:

<blockquote><pre>
%module graphics
%{
#include &lt;GL/gl.h&gt;
#include &lt;GL/glu.h&gt;
%}

// Put rest of declarations here
...
</pre></blockquote>

<h3> What to do with main()</h3>

If your program defines a <tt>main()</tt> function, you may need to
get rid of it or rename it in order to use a scripting language. Most
scripting languages define their own <tt>main()</tt> procedure that
is called instead. <tt>main()</tt> also makes no sense when
working with dynamic loading. There are a few approaches to solving
the <tt>main()</tt> conflict :<p>
<p>
<ul>
<li>Get rid of <tt>main()</tt> entirely. 

<li>Rename <tt>main()</tt> to something else. You can do this by
compiling your C program with an option like <tt>-Dmain=oldmain</tt>.

<li>Use conditional compilation to only include <tt>main()</tt> when
not using a scripting language.
</ul>

<p>
Getting rid of <tt>main()</tt> may cause potential initialization
problems of a program. To handle this problem, you may consider
writing a special function called <tt>program_init()</tt> that
initializes your program upon startup. This function could then be
called either from the scripting language as the first operation, or
when the SWIG generated module is loaded.<p>

<p>
As a general note, many C programs only use the <tt>main()</tt>
function to parse command line options and to set parameters. However,
by using a scripting language, you are probably trying to create a
program that is more interactive. In many cases, the old
<tt>main()</tt> program can be completely replaced by a Perl, Python,
or Tcl script.<p>

<h3> How to avoid creating the interface from hell</h3>

SWIG makes it fairly easy to build a big interface really fast. In
fact, if you apply it to a large enough package, you'll find yourself
with a rather large amount of code being produced in the resulting
wrapper file. For instance,  wrapping a 1000 line C header file
with a large number of structure declarations may result in a wrapper
file containing 20,000-30,000 lines of code.  Here are a few things
you can do to make smaller interface:
<p>
<ul>
<li>It is usually not necessary to wrap every single function in a package.
Try to eliminate the unneeded ones.

<li>SWIG does not require structure definitions to operate. If you are
never going to access the members of a structure, don't wrap the
structure definition.

<li>Eliminate unneeded members of C++ classes.

<li>Think about what you are doing. If you are only using a subset of
some library, there is no need to wrap the whole thing.

<li>Write support or helper functions to simplify common
operations. Some C functions may not be easy to use in a scripting
language environment. You might consider writing an alternative
version and wrapping that instead.
</ul>

<p><hr>

<address>SWIG 1.3 - Last Modified : September 3, 2001</address>
</body>
</html>
