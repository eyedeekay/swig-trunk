<html>
<head>
<title>SWIG Basics</title>
</head>

<body bgcolor="#ffffff">
<h1>3 SWIG Basics</h1>

This chapter describes the basic operation of SWIG, the structure of its
input files, and how it handles various sorts of C/C++ declarations.
Specific details about each target language are described in later
chapters.   However, much of the underlying design philosophy and 
aspects of SWIG's implementation are contained here.

<h2>Running SWIG</h2>

To run SWIG, use the <tt>swig</tt> command with one or more of the
following options and a filename like this:

<p>
<blockquote><pre>swig [ <em>options</em> ] filename

-tcl                  Generate Tcl wrappers
-perl                 Generate Perl5 wrappers
-python               Generate Python wrappers
-guile                Generate Guile wrappers
-ruby                 Generate Ruby wrappers
-java                 Generate Java wrappers
-mzscheme             Generate mzscheme wrappers
-c++                  Enable C++ parsing
-I<em>dir</em>                 Add a directory to the file include path
-l<em>file</em>                Include a SWIG library file.
-c                    Generate raw wrapper code (omit supporting code)
-o <em>outfile</em>            Name of output file
-module <em>name</em>          Set the name of the SWIG module
-D<em>symbol</em>              Define a preprocessor symbol
-includeall           Follow all #include statements
-version              Show SWIG's version number
-help                 Display all options

</pre></blockquote>

Additional options are often defined for each target language.  A full list
can be obtained by typing <tt>swig -help</tt> or <tt>swig
-<em>lang</em> -help</tt>.

<h3>Input format</h3>

As input, SWIG expects a file containing ANSI C/C++ declarations and
special SWIG directives.  More often than not, this is a special SWIG
interface file which is usually denoted with a special <tt>.i</tt> or
<tt>.swg</tt> suffix.  In certain cases, SWIG can be used directly on
raw C header files or C source files.  However, this is not the most
typical case and there are several reasons why you might not want to
do this (described later).

<p>
The general format of a SWIG interface is as follows:

<p>
<blockquote><pre>%module mymodule 
%{
#include "myheader.h"
%}
// Now list ANSI C/C++ declarations
int foo;
int bar(int x);
...
</pre></blockquote>

The name of the module is supplied using the special <tt>%module</tt>
directive (or the <tt>-module</tt> command line option).  This
directive must appear at the beginning of the file and is used to name
the resulting extension module (in addition, this name is often used to define
a namespace in the target language).  If the module name is supplied on the
command line, it overrides the name specified with the
<tt>%module</tt> directive.

<p>
Everything in the <tt>%{ ... %}</tt> block is simply copied to the
resulting output file.  The enclosed text is not parsed or interpreted
by SWIG.  Although the use of a <tt>%{,%}</tt> block is optional, most
interface files have one to include header files and other supporting
C declarations.  The <tt>%{...%}</tt> syntax and
semantics in SWIG is analogous to that of the declarations section used
in input files to yacc or bison.

<h3>SWIG Output</h3>

The output of SWIG is a C/C++ file that contains all of the wrapper
code needed to build an extension module.  By default, an input file
with the name <tt>file.i</tt> is transformed into a file
<tt>file_wrap.c</tt> or <tt>file_wrap.cxx</tt> (depending on whether
or not the <tt>-c++</tt> option has been used).  The name of the
output file can be changed using the <tt>-o</tt> option.  In certain
cases, file suffixes are used by the compiler to determine the source
language (C, C++, etc.). Therefore, you may want to use the
<tt>-o</tt> option to change the suffix of the SWIG-generated wrapper
file (if needed). For example:

<blockquote><pre>
$ swig -c++ -python -o example_wrap.cpp example.i</pre></blockquote>

<p>
It is important to note that the output file created by SWIG normally
contains everything that is needed to construct a extension module
for the target scripting language. SWIG is not a stub compiler nor is
usually necessary to edit the output file (and if you look at the output,
you probably won't want to).      To build the final extension module, the
SWIG output file is compiled and linked with the rest of your C/C++
program to create a shared library.   If all goes well, your module is
now ready to use.

<h3>Comments</h3>

C and C++ style comments may appear anywhere in interface files.  In
previous versions of SWIG, comments were used to generate
documentation files. However, this feature is currently under repair
and will reappear in a later SWIG release.

<h3>C Preprocessor</h3>

Like C, SWIG preprocesses all input files through an enhanced version
of the C preprocessor.  All standard preprocessor features are
supported including file inclusion, conditional compilation and
macros. However, <tt>#include</tt> statements are ignored unless the
<tt>-includeall</tt> command line option has been supplied.  The
reason for disabling includes is that SWIG is sometimes used to
process raw C header files.  In this case, you usually only want the
extension module to include functions in the supplied header file
rather than everything that might be included by that header file
(i.e., system headers, C library functions, etc.).

<p>
It should also be noted that the SWIG preprocessor skips all text
enclosed inside a <tt>%{...%}</tt> block.  In addition, the
preprocessor includes a number of macro handling enhancements that
make it more powerful than the normal C preprocessor.  These
extensions are described in the "Preprocessor" chapter.

<h3>SWIG Directives</h3>

Most of SWIG's operation is controlled by special directives that are
always preceded by a "<tt>%</tt>" to distinguish them from normal C
declarations. These directives are used to give SWIG hints or to alter
SWIG's parsing behavior in some manner.   

<p>
Since SWIG directives are not legal C syntax, it is generally not
possible to include them in header files.  However, SWIG directives can be
included in C header files using conditional compilation like this:

<blockquote><pre>
/* header.h  --- Some header file */

/* SWIG directives -- only seen if SWIG is running */ 
#ifdef SWIG
%module foo
#endif
</pre>
</blockquote>

<tt>SWIG</tt> is a special preprocessing symbol defined by SWIG when
it is parsing an input file.

<h3>Parser Limitations</h3>

Although SWIG can parse most common C/C++ declarations, it does not
provide a complete C/C++ parser implementation.  Most of these
limitations pertain to complicated type declarations and advanced C++
features.  Specifically, the following features are not currently supported:

<p>
<ul>
<li>Non-conventional type declarations.
For example, SWIG does not support declarations such as the following
(even though this is legal C):

<blockquote>
<pre>
/* Non-conventional placement of storage specifier (extern) */
const int extern Number;
/* Function declaration with unnecessary grouping */
int (foo)(int,int); 
...
</pre>
</blockquote>

In practice, few (if any) C programmers actually write code like
is since this style is never featured in programming books.  However,
if you're feeling particularly obfuscated, you can certainly break SWIG.

<p>
<li>Running SWIG on C++ source files (what would appear in a .C or .cxx file) 
is not recommended.  Even though SWIG can parse C++ class declarations,
it does not know how to parse declarations that are decoupled from their
original class definition.  For example:

<blockquote>
<pre>
/* Not supported by SWIG */
int foo::bar(int) {
    ... whatever ...
}
</pre>
</blockquote>

<li>Other advanced features of C++ such as templates, namespaces, and operator
overloading are not currently supported. Please see the section on using SWIG
with C++ for more information.
</ul> <p>

In the event of a parsing error, conditional compilation can be used to skip
over offending code.  For example:

<blockquote>
<pre>
#ifndef SWIG
... some bad declarations ...
#endif
</pre>
</blockquote>

Alternatively, you can just delete the offending code from the interface file.

<h2>Wrapping Simple C Declarations</h2>

SWIG wraps simple C declarations by creating an interface that closely matches
the way in which the declarations would be used in a C program.
For example, consider the following interface file:

<p>
<blockquote><pre>%module example

extern double sin(double x);
extern int strcmp(const char *, const char *);
extern int Foo;
#define STATUS 50
#define VERSION "1.1"
</pre></blockquote>

In this file, there are two functions <tt>sin()</tt> and <tt>strcmp()</tt>,
a global variable <tt>Foo</tt>, and two constants <tt>STATUS</tt> and
<tt>VERSION</tt>.  When SWIG creates an extension module, these
declarations are accessible as scripting language functions, variables, and
constants respectively.  For example, in Tcl:

<p>
<blockquote><pre>% sin 3
5.2335956
% strcmp Dave Mike
-1
% puts $Foo
42
% puts $STATUS
50
% puts $VERSION
1.1
</pre></blockquote>

Or in Python:

<p>
<blockquote><pre>
>>> example.sin(3)
5.2335956
>>> example.strcmp('Dave','Mike')
-1
>>> print example.cvar.Foo
42
>>> print example.STATUS
50
>>> print example.VERSION
1.1
</pre></blockquote>

Whenever possible, SWIG creates an interface that closely matches the underlying C/C++
code. However, due to subtle differences between languages, run-time
environments, and semantics, it is not always possible to do so.   The
next few sections describes various aspects of this mapping.

<h3>Basic Type Handling</h3>

In order to build an interface, SWIG has to convert C/C++ datatypes to
equivalent types in the target language.  Generally speaking, scripting languages provide
a more limited set of types than C.  Therefore, this process involves a certain
amount of type manipulation.

<p>
Most scripting languages provide a single integer type that is implemented using
the <tt>int</tt> or <tt>long</tt> datatype in C.   The following list shows
all of the C datatypes that SWIG will convert to and from integers in the target language:

<p>
<blockquote><pre>int
short
long
unsigned
signed
unsigned short
unsigned long
unsigned char
signed char
bool
</pre></blockquote>

<p>
When an integral value is converted from C, a cast is used to convert it to
the representation in the target language.
Thus, a 16 bit short in C may be promoted to a 32 bit integer.  When integers are 
converted in the other direction, the value is cast back into the original C type.  
If the value is too large to fit, it is silently truncated.
<!-- Dave: Maybe we should fix this -->

<p>
<tt>unsigned char</tt> and <tt>signed char</tt> are special cases that
are handled as small 8-bit integers. Normally, the <tt>char</tt>
datatype is mapped as a one-character ASCII string. <p>

<p>
The <tt>bool</tt> datatype is cast to and from an integer value of 0
and 1.<p>

<p>
Some care is required when working with large integer values. Most
scripting languages use 32-bit integers so mapping a 64-bit long
integer may lead to truncation errors. Similar problems may arise with
32 bit unsigned integers (which may appear as large negative
numbers). As a rule of thumb, the <tt>int</tt> datatype and all
variations of <tt>char</tt> and <tt>short</tt> datatypes are safe to
use. For <tt>unsigned int</tt> and <tt>long</tt> datatypes, you will
need to carefully check the correct operation of your program after
it has been wrapped with SWIG.

<p>
Although the SWIG parser supports the <tt>long long</tt> datatype, very few language
modules currently support it.  This is because <tt>long long</tt> usually exceeds the
precision available in the target language.  This limitation may be 
eliminated in future SWIG releases.

<p>
SWIG recognizes the following floating point types :<p>

<blockquote><pre>
float
double
</pre></blockquote>
<p>

Floating point numbers are mapped to and from the natural
representation of floats in the target language. This is almost always
a C <tt>double</tt>. The rarely used datatype of <tt>long double</tt> is not
supported by SWIG.<p>

<p>
The <tt>char</tt> datatype is mapped into a NULL terminated ASCII
string with a single character. When used in a scripting language it
shows up as a tiny string containing the character value. When
converting the value back into C, SWIG takes a character string
from the scripting language and strips off the first character as the
char value. Thus if the value "foo" is assigned to a
<tt>char</tt> datatype, it gets the value `f'.<p>

<p>
The <tt>char *</tt> datatype is handled as a NULL-terminated ASCII
string. SWIG maps this into a 8-bit character string in the target scripting
language. SWIG converts character strings in the target language to
NULL terminated strings before passing them into C/C++. It is illegal
for these strings to have embedded NULL bytes.   Therefore, the <tt>char *</tt> datatype
is not generally suitable for passing binary data (although SWIG's behavior
can be modified to handle this).

<p>
At this time, SWIG does not provide any special support for Unicode or
wide-character strings (the C <tt>wchar_t</tt> type).  This is a
delicate topic that is quite complex and poorly understood by many programmers.
For those scripting languages that provide Unicode support, Unicode strings are often
implicitly converted to an 8-bit representation such as UTF-8 whenever they are
matched to the <tt>char *</tt> type (in which case the SWIG interface will probably work).

<h3>Global Variables</h3>

Whenever possible, SWIG maps C/C++ global variables into scripting language
variables.  For example,

<p>
<blockquote><pre>%module example
double foo;

</pre></blockquote>

results in a scripting language variable like this:

<p>
<blockquote><pre># Tcl
set foo [3.5]                   ;# Set foo to 3.5
puts $foo                       ;# Print the value of foo

# Python
cvar.foo = 3.5                  ;# Set foo to 3.5
print cvar.foo                  ;# Print value of foo

# Perl
$foo = 3.5;                     ;# Set foo to 3.5
print $foo,"\n";                ;# Print value of foo

</pre></blockquote>

Whenever the scripting language variable is used, the underlying C
global variable is accessed.  Although SWIG makes every
attempt to make global variables work like scripting language
variables, it is not always possible to do so.  For instance, in
Python, all global variables must be accessed through a special
variable object known as <tt>cvar</tt> (shown above).  Other languages may
convert variables to a pair of accessor functions.  For example, the
Java module generates a pair of functions <tt>double get_foo()</tt>
and <tt>set_foo(double val)</tt> that are used to manipulate the
value.

<p>
Finally, if a global variable has been declared as <tt>const</tt>, it
only supports read-only access.  Note: this behavior is new to SWIG-1.3.
Earlier versions of SWIG incorrectly handled <tt>const</tt> and created
constants instead.

<h3> Constants</h3>

Constants can be created using <tt>#define</tt>, enumerations,
or a special <tt>%constant</tt> directive.  The following
interface file shows a few valid constant declarations :<p>

<p>
<blockquote><pre>#define I_CONST       5               // An integer constant
#define PI            3.14159         // A Floating point constant
#define S_CONST       "hello world"   // A string constant
#define NEWLINE       '\n'            // Character constant

enum boolean {NO=0, YES=1};
enum months {JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG,
             SEP, OCT, NOV, DEC};
%constant double BLAH = 42.37;
#define F_CONST (double) 5            // A floating pointer constant with cast
#define PI_4 PI/4
#define FLAGS 0x04 | 0x08 | 0x40

</pre></blockquote>

In <tt>#define</tt> declarations, the type of a constant is inferred
by syntax. For example, a number with a decimal point is assumed to be
floating point.   In addition, SWIG must be able to fully resolve all of the
symbols used in a <tt>#define</tt> in order for a constant to actually be
created.    This restriction is necessary because <tt>#define</tt> is also
used to define preprocessor macros that are most definitely not meant to be part of the scripting
language interface.  For example:

<blockquote>
<pre>
#define EXTERN extern

EXTERN void foo();
</pre>
</blockquote>

In this case, we probably don't want to create a constant called 
<tt>EXTERN</tt> (what would the value be?).  Generally speaking,
SWIG will not create constants for macros unless the value can
be completely determined.  For instance, in the above example,
the declaration

<blockquote>
<pre>
#define PI_4  PI/4
</pre>
</blockquote>

defines a constant because <tt>PI</tt> was already defined as a
constant and the value is known.

<p>
The use of constant expressions is allowed, but SWIG does not evaluate
them. Rather, it passes them through to the output file and lets the C
compiler perform the final evaluation (SWIG does perform a limited
form of type-checking however).<p>

<p>
For enumerations, it is critical that the original enum definition be
included somewhere in the interface file (either in a header file or
in the <tt>%{,%}</tt> block). SWIG only translates the enumeration
into code needed to add the constants to a scripting language. It
needs the original enumeration declaration in order to get the correct
enum values as assignd by the C compiler.

<p>
The <tt>%constant</tt> directive is used to more precisely create constants
corresponding to different C datatypes.  Although it is not usually 
not needed for simple values, it is more useful when working with
pointers and other more complex datatypes.

<h3>A brief word about <tt>const</tt></h3>

A common confusion with C programming is the semantic meaning of the
<tt>const</tt> qualifier in declarations--especially when it is mixed
with pointers and other type modifiers. In fact, previous versions of SWIG
handled <tt>const</tt> incorrectly.

<p>
Starting with SWIG-1.3, all variable declarations, regardless of any
use of <tt>const</tt>, are wrapped as global variables.  If a
declaration happens to be declared as <tt>const</tt>, it is wrapped as
a read-only variable. To tell if a variable is <tt>const</tt> or not,
you need to look at the right-most occurrence of the <tt>const</tt>
qualifier (that appears before the variable name).  If the right-most
<tt>const</tt> occurs after all other type modifiers (such as
pointers), then the variable is <tt>const</tt>.  Otherwise, it is not.

<p>
Here are some examples of <tt>const</tt> declarations.

<blockquote>
<pre>
const char a;           // A constant character
char const b;           // A constant character (the same)
char *const c;          // A constant pointer to a character
const char *const d;    // A constant pointer to a constant character
</pre>
</blockquote>

Here is an example of a declaration that is not <tt>const</tt>:

<blockquote>
<pre>
const char *e;          // A pointer to a constant character.  The pointer
                        // may be modified.
</pre>
</blockquote>


<h2>Pointers and complex objects</h2>

Most C programs have many more types than integers, floats, and
character strings.  Usually, there are pointers, arrays,
structures, and other types of objects.  This section
discusses the handling of these datatypes.

<h3> Simple pointers</h3>

Pointers to basic C datatypes such as <p>
<p>
<blockquote><pre>int *
double ***
char **
</pre></blockquote>
<p>
are fully supported by SWIG.  SWIG encodes pointers into a
representation that contains the actual value of the pointer and a string
representing the datatype. Thus, the SWIG representation of the above
pointers (in Tcl), might look like this:<p>

<p>
<blockquote><pre>_10081012_p_int
_1008e124_ppp_double
_f8ac_pp_char
</pre></blockquote>

<p>
A NULL pointer is represented by the string "NULL" or the value 0
encoded with type information.<p>

<p>
All pointers are treated as opaque objects by SWIG. Thus, a pointer
may be returned by a function and passed around to other C functions
as needed.  For all practical purposes, the scripting language
interface works in exactly the same way as you would manipulate the
pointer in a C program with the exception that the pointer can't be
dereferenced (at least not without additional help).

<p>
The scripting language representation of a pointer value should never be
manipulated directly (although nothing prevents this). Furthermore, SWIG does not
normally map pointers into high-level objects such as associative
arrays or lists (for example, converting an
<tt>int *</tt> into an list of integers). There are several reasons
why SWIG does not do this:<p>

<p>
<ul>
<li>There is not enough information in a C declaration to properly map
pointers into higher level constructs. For example, an <tt>int *</tt>
may indeed be an array of integers, but if it contains one million
elements, converting it into a Tcl, Perl, or Python list would
probably be an extremely bad idea.

<p>
<li>The underlying semantics associated with a pointer is not known
by SWIG.   For instance, an <tt>int *</tt> might not be an array at all--perhaps it
is an output value!

<P>
<li>By handling all pointers in a consistent manner, the implementation of SWIG is greatly
simplified and less prone to error.
</ul>
<p>

<h3> Run time pointer type checking</h3>

By allowing pointers to be manipulated from a scripting language, extension modules
effectively bypass compile-time type checking in the C/C++
compiler.  To prevent errors, a type signature is encoded into all
pointer values and is used to perform run-time type checking.  This
type-checking process is an integral part of SWIG and can not be
disabled or modified without using typemaps (described in later
chapters).

<p>
Like C, <tt>void *</tt> matches any kind of pointer.  Furthermore,
<tt>NULL</tt> pointers can be passed to any function that expects to
receive a pointer.  Although this has the potential to cause a crash,
<tt>NULL</tt> pointers are also sometimes used
as sentinel values or to denote a missing/empty value.  Therefore,
SWIG leaves NULL pointer checking up to the application.

<h3> Derived types, structs, and classes</h3>

For everything else (structs, classes, arrays, etc...) SWIG applies a
very simple rule :<p>

<p>
<center>
<b>Everything else is a pointer</b>
</center>

<p>
In other words, SWIG manipulates everything else by reference. This
model makes sense because most C/C++ programs make heavy use of
pointers and SWIG can use the type-checked pointer mechanism already
present for handling pointers to basic datatypes.<p>

<p>
Although this probably sounds complicated, it's really quite
simple. Suppose you have an interface file like this :<p>

<p>
<blockquote><pre>%module fileio
FILE *fopen(char *, char *);
int fclose(FILE *);
unsigned fread(void *ptr, unsigned size, unsigned nobj, FILE *);
unsigned fwrite(void *ptr, unsigned size, unsigned nobj, FILE *);
void *malloc(int nbytes);
void free(void *);

</pre></blockquote>

In this file, SWIG doesn't know what a <tt>FILE</tt> is, but it's used
as a pointer, so it doesn't really matter what it is. If you wrapped
this module into Python, you could use the functions just like you
would expect :<p>

<p>
<blockquote><pre># Copy a file 
def filecopy(source,target):
	f1 = fopen(source,"r")
	f2 = fopen(target,"w")
	buffer = malloc(8192)
	nbytes = fread(buffer,8192,1,f1)
	while (nbytes &gt; 0):
		fwrite(buffer,8192,1,f2)
		nbytes = fread(buffer,8192,1,f1)
	free(buffer)

</pre></blockquote>

In this case <tt>f1</tt>,<tt> f2</tt>, and <tt>buffer</tt> are all
opaque objects containing C pointers. It doesn't matter what value
they contain--our program works just fine without this knowledge.<p>

<h3>Undefined datatypes</h3>

When SWIG encounters an undeclared datatype, it automatically assumes
that it is a structure or class. For example, suppose the following
function appeared in a SWIG input file:<p>

<p>
<blockquote><pre>void matrix_multiply(Matrix *a, Matrix *b, Matrix *c);
</pre></blockquote>
<p>

SWIG has no idea what a "<tt>Matrix</tt>" is.  However, it is obviously
a pointer to something so SWIG generates a wrapper using its generic pointer
handling code. 

<p>
Unlike C or C++, SWIG does not actually care whether <tt>Matrix</tt>
has been previously defined in the interface file or not.  This
allows SWIG to generate interfaces from
only partial or limited information. In some cases, you may not care
what a <tt>Matrix</tt> really is as long as you can pass an opaque reference to
one around in the scripting language interface.

<p>
An important detail to mention is that SWIG will gladly generate
wrappers for an interface when there are unspecified type names.
However, <b>all unspecified types are internally handled as pointers
to structures or classes!</b>. For example, consider the following declaration:

<blockquote>
<pre>
void foo(size_t num);
</pre>
</blockquote>

If <tt>size_t</tt> is undeclared, SWIG generates wrappers
that expect to receive a type of <tt>size_t *</tt> (this mapping is described shortly).
As a result, the scripting interface might behave strangely.  For example:

<blockquote>
<pre>
foo(40);
TypeError: expected a _p_size_t.
</pre>
</blockquote>

The only way to fix this problem is to make sure you properly declare type names using
<tt>typedef</tt>.

<!-- We might want to add an error reporting flag to swig -->

<h3>Typedef</h3>

Like C, <tt>typedef</tt> can be used to define new type names in SWIG. For example:
<p>
<blockquote><pre>typedef unsigned int size_t;

</pre></blockquote>

<tt>typedef</tt> definitions appearing in a SWIG interface
are not propagated to the generated wrapper code.  Therefore, if you
write a new <tt>typedef</tt> declaration, you may have to also include
a small piece of code in a <tt>%{ ... %}</tt> block like this:

<blockquote>
<pre>
%{
/* Include in the generated wrapper file */
typedef unsigned int size_t;
%}
/* Tell SWIG about it */
typedef unsigned int size_t;
</pre>
</blockquote>

or

<blockquote>
<pre>
%inline %{
typedef unsigned int size_t;
%}
</pre>
</blockquote>

SWIG intelligently tracks <tt>typedef</tt> declarations and uses this information
for run-time type checking. For instance, if you use the above <tt>typedef</tt> and
had the following function declaration:

<blockquote>
<pre>
void foo(unsigned int *ptr);
</pre>
</blockquote>

The corresponding wrapper function accepts arguments of
type <tt>unsigned int *</tt> or <tt>size_t *</tt>.

<h2>Other Practicalities</h2>

So far, this chapter has presented almost everything you need to know to use SWIG
for simple interfaces. However, some C programs use idioms that are somewhat
more difficult to map to a scripting language interface.  This section describes
some of these issues.

<h3> Passing complex datatypes by value</h3>

Sometimes a C function takes structure parameters that are passed
by value.  For example, consider the following function:

<p>
<blockquote><pre>double dot_product(Vector a, Vector b);
</pre></blockquote>

<p>
To deal with this, SWIG transforms the function to use pointers by
creating a wrapper equivalent to the following:

<p>
<blockquote><pre>double wrap_dot_product(Vector *a, Vector *b) {
    return dot_product(*a,*b);
}
</pre></blockquote>

<p>
In the target language, the <tt>dot_product()</tt> function now accepts pointers
to Vectors instead of Vectors.  For the most part, this transformation
is transparent so you might not notice.

<h3> Return by value</h3>

C functions that return structures or classes datatypes by value are more difficult
to handle. Consider the following function:<p>

<p>
<blockquote><pre>Vector cross_product(Vector v1, Vector v2);

</pre></blockquote>

This function wants to return <tt>Vector</tt>, but SWIG only really supports
pointers.  As a result, SWIG creates a wrapper like this:

<p>
<blockquote><pre>Vector *wrap_cross_product(Vector *v1, Vector *v2) {
        Vector *result;
        result = (Vector *) malloc(sizeof(Vector));
        *(result) = cross(*v1,*v2);
        return result;
}
</pre></blockquote>

<p>
or if SWIG was run with the <tt>-c++</tt> option:<p>

<p>
<blockquote><pre>Vector *wrap_cross(Vector *v1, Vector *v2) {
        Vector *result = new Vector(cross(*v1,*v2)); // Uses default copy constructor
        return result;
}
</pre></blockquote>

<p>
In both cases, SWIG allocates a new object and returns a reference to it. It
is up to the user to delete the returned object when it is no longer
in use. Clearly, this will leak memory if you are unaware of the implicit
memory allocation.

<h3>Linking to complex variables</h3>

When global variables or class members involving complex datatypes are
encountered, SWIG handles them as pointers. For example, a global
variable like this<p>

<blockquote><pre>
Vector unit_i;
</pre></blockquote>
<p>
gets mapped to an underlying pair of set/get functions like this :<p>
<p>
<blockquote><pre>Vector *unit_i_get() {
	return &amp;unit_i;
}
Vector *unit_i_set(Vector *value) {
	unit_i = *value;
	return &amp;unit_i;
}
</pre></blockquote>
<p>

Again some caution is in order. A global variable created in this
manner will show up as a pointer in the target scripting language. It
would be an extremely bad idea to free or destroy such a pointer.    Also,
C++ classes must supply a properly defined copy constructor in order for
assignment to work correctly.

<h3> Arrays</h3>

Arrays are fully supported by SWIG, but they are always handled as pointers instead
of mapping them to a special array object or list in the target language.  Thus, the
following declarations :<p>

<p>
<blockquote><pre>int foobar(int a[40]);
void grok(char *argv[]);
void transpose(double a[20][20]);
</pre></blockquote>

<p>
are processed as if they were really declared like this:

<p>
<blockquote><pre>int foobar(int *a);
void grok(char **argv);
void transpose(double (*a)[20]);
</pre></blockquote>

Like C, SWIG does not perform array bounds checking.  
It is up to the
user to make sure the pointer points a suitably allocated region of memory. 

<p>
Multi-dimensional arrays are transformed into a pointer to array of one less
dimension.  For example:

<blockquote>
<pre>
int [10];         // Maps to int *
int [10][20];     // Maps to int (*)[20]
int [10][20][30]; // Maps to int (*)[20][30]
</pre>
</blockquote>

It is important to note that in the C type system, a multidimensional
array <tt>a[][]</tt> is <b>NOT</b> equivalent to a single pointer
<tt>*a</tt> or a double pointer such as <tt>**a</tt>.  Instead, a
pointer to an array is used (as shown above) where the actual value of
the pointer is the starting memory location of the array.  The
reader is strongly advised to dust off their C book and re-read the
section on arrays before using them with SWIG.

<p>
Array variables are supported, but are read-only by default.  For example:

<blockquote>
<pre>
int   a[100][200];
</pre>
</blockquote>

In this case, reading the variable 'a' returns a pointer of type <tt>int (*)[200]</tt>
that points to the first element of the array <tt>&a[0][0]</tt>.  Trying to modify 'a' results
in an error.  This is because SWIG does not know how to copy data from the target
language into the array.   To work around this limitation, you may want to write
a few simple assist functions like this:

<blockquote>
<pre>
%inline %{
void a_set(int i, int j, int val) {
   a[i][j] = val;
}
int a_get(int i, int j) {
   return a[i][j];
}
%}
</pre>
</blockquote>

To dynamically create arrays of various sizes and shapes, it may be useful to write
some helper functions in your interface.  For example:

<blockquote>
<pre>
// Some array helpers
%inline %{
  /* Create any sort of [size] array */
  int *int_array(int size) {
     return (int *) malloc(size*sizeof(int));
  }
  /* Create a two-dimension array [size][10] */
  int (*int_array_10(int size))[10] {
     return (int (*)[10]) malloc(size*10*sizeof(int));
  }
%}
</pre>
</blockquote>

<h3>Creating read-only variables</h3>

A read-only variable can be created by using the <tt>%readonly</tt>
directive as shown :<p>

<blockquote><pre>
// File : interface.i

int 	a; 			// Can read/write
%readonly
int	b,c,d			// Read only variables
%readwrite
double	x,y			// read/write
</pre></blockquote>

<p>
The <tt>%readonly</tt> directive enables read-only mode until it is
explicitly disabled using the <tt>%readwrite</tt> directive.<p>

Read-only variables are also created when declarations are declared as <tt>const</tt>.
For example:

<blockquote>
<pre>
const int foo;               /* Read only variable */
char * const version="1.0";  /* Read only variable */
</pre>
</blockquote>

<h3>Renaming declarations</h3>

Normally, the name of a C function is used as the name of the command
added to the target scripting language. However, this name may
conflict with a keyword or already existing function in the scripting
language. To resolve a name conflict, use the <tt>%name</tt>
directive as shown :<p>

<p>
<blockquote><pre>// interface.i

%name(my_print) extern void print(char *);
%name(foo) extern int a_really_long_and_annoying_name;

</pre></blockquote>

SWIG still calls the correct C function, but in this case the
function <tt>print()</tt> will really be called "<tt>my_print()</tt>"
in the target language. <p>

<p>
A more powerful renaming operation can be performed with the<tt>
%rename</tt> directive:<p>

<p>
<blockquote><pre>%rename oldname newname;

</pre></blockquote>

<tt>%rename </tt>applies a renaming operation to all future
occurrences of a name. The renaming applies to functions, variables,
class and structure names, member functions, and member data. For
example, if you had two-dozen C++ classes, all with a member function
named `print' (which is a keyword in Python), you could rename them
all to `output' by specifying :<p>

<p>
<blockquote><pre>%rename print output; // Rename all `print' functions to `output'
</pre></blockquote>

<p>
SWIG does not currently perform any checks to see if the functions it wraps are
already defined in the target scripting language. However, if you are
careful about namespaces and your use of modules, you can usually
avoid these problems.<p>

<h3>Default/optional arguments</h3>

SWIG supports default arguments in both C and C++ code.  For example:
<p>
<blockquote><pre>int plot(double x, double y, int color=WHITE);

</pre></blockquote>
In this case, SWIG generates wrapper code where the
default arguments are optional. For example, this function could be
used in Tcl as follows :<p>

<p>
<blockquote><pre>% plot -3.4 7.5 				# Use default value
% plot -3.4 7.5 10				# set color to 10 instead

</pre></blockquote>

Although the ANSI C standard does not allow default arguments, default
arguments specified in a SWIG interface work with both C and C++.

<h3>Pointers to functions and callbacks</h3>

Occasionally, a C library may include functions that expect to receive
pointers to functions--possibly to serve as callbacks. SWIG
provides full support for function pointers provided that the callback
functions are defined in C and not in the target language.  For example,
consider a function like this:

<blockquote><pre>
int binary_op(int a, int b, int (*op)(int,int));
</pre></blockquote>
<p>

When you first wrap something like this into an extension module, you
may find the function to be impossible to use.  For instance, in Python:

<blockquote><pre>
>>> def add(x,y):
...     return x+y
...
>>> binary_op(3,4,add)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: Type error. Expected _p_f_int_int__int
>>>
</pre>
</blockquote>

The reason for this error is that SWIG doesn't know how to map a scripting
language function into a C callback.  However, existing C functions can
be used as arguments provided you install them as constants.
The easiest way to do this is to use the <tt>%constant</tt> directive like this:

<blockquote><pre>
/* Function with a callback */
int binary_op(int a, int b, int (*op)(int,int));

/* Some callback functions */
%constant int add(int,int);
%constant int sub(int,int);
%constant int mul(int,int);
</pre></blockquote>

In this case, <tt>add</tt>, <tt>sub</tt>, and <tt>mul</tt> become function pointer
constants in the target scripting language.  This allows you to use them as follows:

<blockquote>
<pre>
>>> binary_op(3,4,add)
7
>>> binary_op(3,4,mul)
12
>>>
</pre>
</blockquote>

Unfortunately, by declaring the callback functions as constants, they are no longer accesible
as functions. For example:

<blockquote>
<pre>
>>> add(3,4)
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: object is not callable: '_ff020efc_p_f_int_int__int'
>>>
</pre>
</blockquote>

If you want to make a function available as both a callback function and a function, you
can use the <tt>%callback</tt> and <tt>%nocallback</tt> directives like this:

<blockquote>
<pre>
/* Function with a callback */
int binary_op(int a, int b, int (*op)(int,int));

/* Some callback functions */
%callback("%s_cb")
int add(int,int);
int sub(int,int);
int mul(int,int);
%nocallback
</pre></blockquote>

The argument to <tt>%callback</tt> is a printf-style format string that
specifies the naming convention for the callback constants (<tt>%s</tt> gets replaced
by the function name).  The callback mode remains in effect until it is explicitly
disabled using <tt>%nocallback</tt>.  When you do this, the interface now works as follows:

<blockquote>
<pre>
>>> binary_op(3,4,add_cb)
7
>>> binary_op(3,4,mul_cb)
12
>>> add(3,4)
7
>>> mul(3,4)
12
</pre>
</blockquote>

Notice that when the function is used as a callback, special names
such as <tt>add_cb</tt> is used instead.  To call the function
normally, just use the original function name such as <tt>add()</tt>.

<p>
SWIG provides a number of extensions to standard C printf formatting
that may be useful in this context.  For instance, the following
variation installs the callbacks as all upper-case constants such as
<tt>ADD</tt>, <tt>SUB</tt>, and <tt>MUL</tt>:

<blockquote><pre>
/* Some callback functions */
%callback("%(upper)s")
int add(int,int);
int sub(int,int);
int mul(int,int);
%nocallback
</pre></blockquote>

A format string of <tt>"%(lower)s"</tt> converts all characters to lower-case.
A string of <tt>"%(title)s"</tt> capitalizes the first character and converts the
rest to lower case.

<p>
And now, a few final notes about function pointer support.  Although SWIG
does not normally allow callback functions to be written in the target language, this
can be accomplished with the use of typemaps and other advanced SWIG features.
Generally speaking, this is accomplished by writing a C stub that serves as the
callback but which transfers control back to the scripting language interpreter.
In addition, SWIG does not currently support pointers to C++ member functions.  No
such support is planned at this time due to the fact that such pointers can't
be easily interchanged with standard C pointers.

<h2>Structures, unions, and object oriented C programming</h2>

If SWIG encounters the definition of a structure or union, it will
create a set of accessor functions for you. Although SWIG does not need
structure definitions to build an interface, providing definitions
make it possible to access structure members. The accessor functions
generated by SWIG simply take a pointer to an object and allow access
to an individual member. For example, the declaration :<p>

<p>
<blockquote><pre>struct Vector {
	double x,y,z;
}

</pre></blockquote>

gets transformed into the following set of accessor functions :<p>

<p>
<blockquote><pre>double Vector_x_get(Vector *obj) {
	return obj-&gt;x;
}
double Vector_y_get(Vector *obj) { 
	return obj-&gt;y;
}
double Vector_z_get(Vector *obj) { 
	return obj-&gt;z;
}
void Vector_x_set(Vector *obj, double value) {
	obj-&gt;x = value;
}
void Vector_y_set(Vector *obj, double value) {
	obj-&gt;y = value;
}
void Vector_z_set(Vector *obj, double value) {
	obj-&gt;z = value;
}
</pre></blockquote>

<h3> Typedef and structures</h3>

SWIG supports the following construct which is quite common in C
programs :<p>

<p>
<blockquote><pre>typedef struct {
	double x,y,z;
} Vector;

</pre></blockquote>

When encountered, SWIG will assume that the name of the object is
`Vector' and create accessor functions like before. If two different
names are used like this :<p>

<p>
<blockquote><pre>typedef struct vector_struct {
	double x,y,z;
} Vector;

</pre></blockquote>

the name `Vector' will still be used instead of "vector_struct".<p>

<h3> Character strings and structures</h3>

Structures involving character strings require some care. SWIG assumes
that all members of type <tt>char *</tt> have been dynamically
allocated using <tt>malloc()</tt> and that they are NULL-terminated
ASCII strings. When such a member is modified, the previously contents
will be released, and the new contents allocated. For example :<p>

<p>
<blockquote><pre>%module mymodule
...
struct Foo {
	char *name;
	...
}

</pre></blockquote>

This results in the following accessor functions :<p>

<p>
<blockquote><pre>char *Foo_name_get(Foo *obj) {
	return Foo-&gt;name;
}

char *Foo_name_set(Foo *obj, char *c) {
	if (obj-&gt;name) free(obj-&gt;name);
	obj-&gt;name = (char *) malloc(strlen(c)+1);
	strcpy(obj-&gt;name,c);
	return obj-&gt;name;
}
</pre></blockquote>

<p>
If this behavior differs from what you need in your applications,
the SWIG "memberin" typemap can be used to change it.  See the
typemaps chapter for details.

<h3>Array members</h3>

Arrays may appear as the members of structures, but they will be
read-only. SWIG will write an accessor function that returns the
pointer to the first element of the array, but will not write a
function to change the contents of the array itself. 
When this
situation is detected, SWIG generates a warning message such as the
following :<p>

<p>
<blockquote><pre>interface.i:116. Warning. Array member will be read-only

</pre></blockquote>

To eliminate the warning message, typemaps can be used, but this is
discussed in a later chapter.  In many cases, the warning message is
harmless.

<h3>C constructors and destructors </h3>

When wrapping structures, it is generally useful to have a
mechanism for creating and destroying objects.  You can write this
code yourself, by appropriate call to <tt>malloc()</tt>.  However,
SWIG will generate functions for you automatically if you use C++
syntax like this:

<p>
<blockquote><pre>%module mymodule
...
struct Vector {
        Vector();       // Tell SWIG to create a C constructor
        ~Vector();      // Tell SWIG to create a C destructor
        double x,y,z;
}

</pre></blockquote>
When used with C code, SWIG now creates two additional functions like this :<p>

<p>
<blockquote><pre>Vector *new_Vector() {
       return (Vector *) malloc(sizeof(Vector));
}

void delete_Vector(Vector *v) {
        free(v);
}

</pre></blockquote>

Note: this behavior only applies when SWIG is used on C code (when the
-c++ is <em>not</em> supplied on the command line).   C++ is handled differently.

<p>
As an alternative to explicitly defining constructors and destructors,
SWIG can also automatically generate them using either a command line
option or a pragma. For example :<p>
<p>
<blockquote><pre>swig -make_default example.i 

</pre></blockquote>
or<p>
<p>
<blockquote><pre>%module foo
...
%pragma make_default 					// Make default constructors
... declarations ...
%pragma no_default					// Disable default constructors

</pre></blockquote>
This works with both C and C++.<p>

<h3> Adding member functions to C structures</h3>

Many scripting languages provide a mechanism for creating classes and
supporting object oriented programming. From a C standpoint, object
oriented programming really just boils down to the process of
attaching functions to structures. These functions normally operate
on an instance of the structure (or object) in some way or another. Although there is a
natural mapping of C++ to such a scheme, there is no direct mechanism
for utilizing it with C code. However, SWIG provides a special
<tt>%addmethods</tt> directive that makes it possible to attach
methods to C structures for purposes of building an object oriented
scripting language interface. Suppose you have a C header file with
the following declaration :<p>
<p>
<blockquote><pre>/* file : vector.h */
...
typedef struct {
	double x,y,z;
} Vector;

</pre></blockquote>

You can make a Vector look alot like a class by writing a SWIG interface like this:

<p>
<blockquote><pre>// file : vector.i
%module mymodule
%{
#include "vector.h"
%}

%include vector.h 				// Just grab original C header file
%addmethods Vector { 				// Attach these functions to struct Vector
	Vector(double x, double y, double z) {
		Vector *v;
		v = (Vector *v) malloc(sizeof(Vector));
		v-&gt;x = x;
		v-&gt;y = y;
		v-&gt;z = z;
		return v;
	}
	~Vector() {
		free(self);
	}
	double magnitude() {
		return sqrt(self-&gt;x*self-&gt;x+self-&gt;y*self-&gt;y+self-&gt;z*self-&gt;z);
	}
	void print() {
		printf("Vector [%g, %g, %g]\n", self-&gt;x,self-&gt;y,self-&gt;z);
	}
};

</pre></blockquote>

Now, when used with shadow classes in Python, you can do things like
this :<p>

<p>
<blockquote><pre>&gt;&gt;&gt; v = Vector(3,4,0) 					# Create a new vector
&gt;&gt;&gt; print v.magnitude()					# Print magnitude
5.0
&gt;&gt;&gt; v.print()					# Print it out
[ 3, 4, 0 ]
&gt;&gt;&gt; del v					# Destroy it
</pre></blockquote>
<p>

The <tt>%addmethods</tt> directive can also be used inside the definition
of the Vector structure. For example:<p>

<blockquote><pre>// file : vector.i
%module mymodule
%{
#include "vector.h"
%}

typedef struct {
	double x,y,z;
	%addmethods {
		Vector(double x, double y, double z) { ... }
		~Vector() { ... }
		...
	}
} Vector;
</pre></blockquote>

<p>
Finally, <tt>%addmethods</tt> can be used to access externally written
functions provided they follow the naming convention used in this
example :<p>

<p>
<blockquote><pre>/* File : vector.c */
/* Vector methods */
#include "vector.h"
Vector *new_Vector(double x, double y, double z) {
	Vector *v;
	v = (Vector *) malloc(sizeof(Vector));
	v-&gt;x = x;
	v-&gt;y = y;
	v-&gt;z = z;
	return v;
}
void delete_Vector(Vector *v) {
	free(v);
}

double Vector_magnitude(Vector *v) {
	return sqrt(v-&gt;x*v-&gt;x+v-&gt;y*v-&gt;y+v-&gt;z*v-&gt;z);
}

// File : vector.i
// Interface file
%module mymodule
%{
#include "vector.h"
%}

typedef struct {
	double x,y,z;
	%addmethods {
		double magnitude();  // This will call Vector_magnitude
		...
	}
} Vector;
</pre>
</blockquote>

A little known feature of the <tt>%addmethods</tt> directive is that
it can also be used to add synthesized attributes or to modify the
behavior of existing data attributes.  For example, suppose you wanted
to make <tt>magnitude</tt> a read-only attribute of <tt>Vector</tt>
instead of a method.  To do this, you might write some code like this:

<blockquote>
<pre>
// Add a new attribute to Vector
%addmethods Vector {
    const double magnitude;
}
// Now supply the implementation of the Vector_magnitude_get function
%{
const double Vector_magnitude_get(Vector *v) {
  return (const double) return sqrt(v-&gt;x*v-&gt;x+v-&gt;y*v-&gt;y+v-&gt;z*v-&gt;z);
}
%}

</pre>
</blockquote>

Now, for all practial purposes, <tt>magnitude</tt> will appear like an attribute
of the object.

<p>
A similar technique can also be used to work with problematic data members.
For example, consider this interface:

<blockquote>
<pre>
struct Person {
   char name[50];
   ...
}
</pre>
</blockquote>

By default, the <tt>name</tt> attribute is read-only because SWIG does not
normally know how to modify arrays.  However, you can rewrite the interface
as follows to change this:

<blockquote>
<pre>
struct Person {
    %addmethods {
       char *name;
    }
...
}

// Specific implementation of set/get functions
%{
char *Person_name_get(Person *p) {
   return p->name;
}
void Person_name_set(Person *p, char *val) {
   strncpy(p->name,val,50);
}
%}
</pre>
</blockquote>

Finally, it should be stressed that even though <tt>%addmethods</tt>
can be used to add new data members, these new members can not require
the allocation of additional storage in the object (e.g., their values must
be entirely synthesized from existing attributes of the structure).

<h3> Nested structures</h3>

Occasionally, a C program will involve structures like this :<p>
<p>
<blockquote><pre>typedef struct Object {
	int objtype;
	union {
		int 	ivalue;
		double	dvalue;
		char	*strvalue;
		void	*ptrvalue;
	} intRep;
} Object;

</pre></blockquote>

When SWIG encounters this, it performs a structure splitting operation
that transforms the declaration into the equivalent of the
following:<p>
<p>
<blockquote><pre>typedef union {
	int 		ivalue;
	double		dvalue;
	char		*strvalue;
	void		*ptrvalue;
} Object_intRep;

typedef struct Object {
	int objType;
	Object_intRep intRep;
} Object;

</pre></blockquote>

SWIG will then create an <tt>Object_intRep</tt> structure for use inside
the interface file. Accessor functions will be created for both
structures. In this case, functions like this would be created :<p>
<p>
<blockquote><pre>Object_intRep *Object_intRep_get(Object *o) {
	return (Object_intRep *) &amp;o-&gt;intRep;
}
int Object_intRep_ivalue_get(Object_intRep *o) {
	return o-&gt;ivalue;
}
int Object_intRep_ivalue_set(Object_intRep *o, int value) {
	return (o-&gt;ivalue = value);
}
double Object_intRep_dvalue_get(Object_intRep *o) {
	return o-&gt;dvalue;
}
... etc ...

</pre></blockquote>

Although this process is a little hairy, it works like you would expect in the
target scripting language--especially when shadow classes are used.  For instance, in Perl:

<p>
<blockquote><pre># Perl5 script for accessing nested member
$o = CreateObject(); 				# Create an object somehow
$o-&gt;{intRep}-&gt;{ivalue} = 7 				# Change value of o.intRep.ivalue
</pre></blockquote>

<p>
If you have a lot nested structure declarations, it is
advisable to double-check them after running SWIG. Although,
there is a good chance that they will work, you may have to
modify the interface file in certain cases.

<h3>Other things to note about structure wrapping</h3>

SWIG doesn't care if the definition of a structure exactly matches
that used in the underlying C code (except in the case of nested
structures). For this reason, there are no problems omitting
problematic members or simply omitting the structure definition
altogether. If you are happy passing pointers around, this can
be done without ever giving SWIG a structure definition.<p>

<p>
Starting with SWIG1.3, a number of improvements have been made to SWIG's
code generator. Specifically, even though structure access has been described
in terms of high-level accessor functions such as this,

<blockquote>
<pre>
double Vector_x_get(Vector *v) {
   return v->x;
}
</pre>
</blockquote>

most of the generated code is actually inlined directly into wrapper
functions.  Therefore, no function <tt>Vector_x_get()</tt> actually
exists in the generated wrapper file.  For example, when creating a Tcl module,
the following function is generated instead:

<blockquote>
<pre>
static int
_wrap_Vector_x_get(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
    struct Vector *arg0 ;
    double result ;
    
    if (SWIG_GetArgs(interp, objc, objv,"p:Vector_x_get self ",&arg0, SWIGTYPE_p_Vector) == TCL_E
RROR) return TCL_ERROR;
    result = (double ) (arg0->x);
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj((double) result));
    return TCL_OK;
}
</pre>
</blockquote>

The only exception to this rule are methods defined with <tt>%addmethods</tt>.  In this
case, the added code is contained in a separate function.

<p>
Finally, it is important to note that most language modules may choose to
build a more advanced interface. Although you may never use the low-level
interface described here, most of SWIG's language modules use it in
some way or another.

<h2> C++ support</h2>

SWIG's support for C++ is an extension of the support for C functions,
variables, and structures. However, SWIG only supports a subset of the
C++ language. It has never been my goal to write a full C++ compiler
or to turn scripting languages into some sort of weird pseudo C++
interpreter (considering how hard it is to write a C++ compiler, I'm
not sure this would even be feasible anyways). <p>
<p>
This section describes SWIG's low-level access to C++ declarations. In
many instances, this low-level interface may be hidden by shadow
classes or an alternative calling mechanism (this is usually language
dependent and is described in detail in later chapters).<p>

<h3> Supported C++ features</h3>

SWIG supports the following C++ features :<p>
<p>
<ul>
<li>Simple class definitions
<li>Constructors and destructors
<li>Virtual functions
<li>Public inheritance (including multiple inheritance)
<li>Static functions
<li>References
</ul>

<p>
The following C++ features are not currently supported :<p>

<p>
<ul>
<li>Operator overloading
<li>Function overloading (without renaming)
<li>Templates (anything that would be defined using the
`<tt>template</tt>' keyword).
<li>Friends
<li>Nested classes
<li>Namespaces
<li>Pointers to member functions.
</ul>

<p>
Since SWIG's C++ support is a "work in progress", many of these
limitations may be lifted in future releases. In particular, function
overloading and nested classes, may be supported in the
future. Operator overloading and templates are unlikely to be
supported anytime in the near future, but I'm not going to rule out
the possibility in later releases.<p>

<h3> C++ example</h3>
The following code shows a SWIG interface file for a simple C++
class.<p>

<p>
<blockquote><pre>%module list
%{
#include "list.h"
%}

// Very simple C++ example for linked list

class List {
public:
  List();
  ~List();
  int  search(char *value);
  void insert(char *);
  void remove(char *);
  char *get(int n);
  int  length;
static void print(List *l);
};
</pre></blockquote>

<p>
When compiling C++ code, it is critical that SWIG be called with the
`<tt>-c++</tt>' option. This changes the way a number of critical
features are handled with respect to differences between C and C++. It
also enables the detection of C++ keywords. Without the <tt>-c++</tt>
flag, SWIG will either issue a warning or a large number of syntax
errors if it encounters any C++ code in an interface file.<p>

<h3> Constructors and destructors</h3>

C++ constructors and destructors are translated into accessor
functions like the following :<p>

<p>
<blockquote><pre>List * new_List(void) {
	return new List;
}
void delete_List(List *l) {
	delete l;
}

</pre></blockquote>
If the original C++ class does not have any constructors or
destructors, putting constructors and destructors in the SWIG
interface file will cause SWIG to generate wrappers for the default
constructor and destructor of an object.<p>

<h3> Member functions</h3>

Member functions are translated into accessor functions like this :<p>
<p>
<blockquote><pre>int List_search(List *obj, char *value) {
	return obj-&gt;search(value);
}

</pre></blockquote>

Virtual member functions are treated in an identical manner since the
C++ compiler takes care of this for us automatically.<p>

<h3> Static members</h3>

Static member functions are called directly without making any
additional C wrappers. For example, the static member function
<tt>print(List *l)</tt> will simply be called as <tt>List::print(List
*l)</tt> in the resulting wrapper code.<p>

<h3> Member data</h3>

Member data is handled in exactly the same manner as used for C
structures. A pair of accessor functions will be created. For example
:<p>

<p>
<blockquote><pre>int List_length_get(List *obj) {
	return obj-&gt;length;
}
int List_length_set(List *obj, int value) {
	obj-&gt;length = value;
	return value;
}

</pre></blockquote>

A read-only member can be created using the <tt>%readonly</tt> and
<tt>%readwrite</tt> directives. For example, we probably wouldn't want
the user to change the length of a list so we could do the following
to make the value available, but read-only.<p>

<p>
<blockquote><pre>class List {
public:
...
%readonly
	int length;
%readwrite
...
};
</pre></blockquote>

<h3> Protection</h3>

SWIG can only wrap class members that are declared public. Anything
specified in a private or protected section will simply be ignored. To
simplify your interface file, you may want to consider eliminating all
private and protected declarations (if you've copied a C++ header file
for example).<p>

<p>
By default, members of a class definition are assumed to be private
until you explicitly give a `<tt>public:</tt>' declaration (This is
the same convention used by C++).<p>

<h3> Enums and constants</h3>

Enumerations and constants placed in a class definition are mapped
into constants with the classname as a prefix. For example :<p>
<p>
<blockquote><pre>class Swig {
public:
	enum {ALE, LAGER, PORTER, STOUT};
};

</pre></blockquote>
Generates the following set of constants in the target scripting language :<p>
<p>
<blockquote><pre>Swig_ALE = Swig::ALE
Swig_LAGER = Swig::LAGER
Swig_PORTER = Swig::PORTER
Swig_STOUT = Swig::STOUT

</pre></blockquote>
Members declared as <tt>const</tt> are wrapped in a similar manner.<p>

<h3> References</h3>

C++ references are supported, but SWIG will treat them as
pointers. For example, a declaration like this :<p>
<p>
<blockquote><pre>class Foo {
public:
	double bar(double &amp;a);
}
</pre></blockquote>
<p>
will be accessed using a function like this :<p>
<p>
<blockquote><pre>double Foo_bar(Foo *obj, double *a) {
	obj-&gt;bar(*a);
}

</pre></blockquote>

Functions returning a reference will be mapped into functions
returning pointers.<p>

<h3> Inheritance</h3>

SWIG supports basic C++ public inheritance of classes and allows both
single and multiple inheritance. The SWIG type-checker knows about the
relationship between base and derived classes and will allow pointers
to any object of a derived class to be used in functions of a base
class. The type-checker properly casts pointer values and is safe to
use with multiple inheritance.<p> SWIG does not support private or
protected inheritance (it will be parsed, but ignored).<p>

<p>
The following example shows how SWIG handles inheritance. For clarity,
the full C++ code has been omitted.<p>

<p>
<blockquote><pre>// shapes.i
%module shapes
%{
#include "shapes.h"
%}

class Shape {
public:
	virtual double area() = 0;
	virtual double perimeter() = 0;
	void    set_location(double x, double y);
};
class Circle : public Shape {
public:
	Circle(double radius);
	~Circle();
	double area();
	double perimeter();
};
class Square : public Shape {
public:
	Square(double size);
	~Square();
	double area();
	double perimeter();
}
</pre></blockquote>

<p>
When wrapped into Perl5, we can now perform the following operations
:<p>

<p>
<blockquote><pre>beazley@slack% perl5.003
use shapes;
$circle = shapes::new_Circle(7);
$square = shapes::new_Square(10);
print shapes::Circle_area($circle),"\n";
# Notice use of base class below
print shapes::Shape_area($circle),"\n";
print shapes::Shape_area($square),"\n";
shapes::Shape_set_location($square,2,-3);
print shapes::Shape_perimeter($square),"\n";
&lt;ctrl-d&gt;
153.93804004599999757
153.93804004599999757
100.00000000000000000
40.00000000000000000
 
</pre></blockquote>
In our example, we have created Circle and Square objects. We can call
member functions on each object by making calls to
<tt>Circle_area</tt>, <tt>Square_area</tt>, and so on. However, we can
can accomplish the same thing by simply using the <tt>Shape_area</tt>
function on either object.<p>

<h3> Templates</h3>

SWIG does not support template definitions--that is, it does not
support anything that would be declared in C++ using the
`<tt>template</tt>' keyword. If a template definition is found, SWIG
will issue a warning message and attempt to ignore the contents of the
entire declaration. For example, a template class such as the
following would be ignored by SWIG :<p>
<p>
<blockquote><pre>// File : list.h
#define MAXITEMS 100
template&lt;class T&gt; class List { 						// Entire class is ignored by SWIG
private:
    T *data;
    int nitems;
public:
    List() {
      data = new T [MAXITEMS];
      nitems = 0;
    }
    ~List() {
      delete [] data;
    };
    void append(T obj) {
      if (nitems &lt; MAXITEMS) {
        data[nitems++] = obj;
      }
    }
    int length() {
      return nitems;
    }
    T get(int n) {
      return data[n];
    }
};

</pre></blockquote>

However, SWIG can support instantiations of a template and types
involving templates. For example, the following interface file would
be legal :<p>

<p>
<blockquote><pre>// SWIG interface involving a template
%module example
%{
#include "list.h"				// Get Template definition 
%}

// Now a function involving templates
extern void PrintData(List&lt;double&gt; &amp;l);

</pre></blockquote>

The type "<tt>List&lt;double</tt>&gt;" becomes the datatype for the
function parameter. In, Python it might appear like this :<p>
<p>
<blockquote><pre>&gt;&gt;&gt; print cl
_80a2df8_List&lt;double&gt;_p
&gt;&gt;&gt;

</pre></blockquote>
To create specific objects, you may need to supply helper functions
such as the following :<p>

<blockquote><pre>
%inline %{
// Helper function to create a List&lt;double&gt;
List&lt;double&gt; *new_DoubleList() {
	return new List&lt;double&gt;;
}
%}
</pre></blockquote>
<p>
Specific templates can also be wrapped in a clever way using
<tt>typedef.</tt> For example, the following would also work :<p>
<p>
<blockquote><pre>%module example
%{
#include "list.h"
typedef List&lt;double&gt; DoubleList;
%}

class DoubleList {
public:
	DoubleList();
	~DoubleList();
	void append(double);
	int length();
	double get(int n);
};

</pre></blockquote>

In this case, SWIG thinks that there is a class "<tt>DoubleList</tt>"
with the methods supplied. It generates the appropriate code and
everything works like you would expect (of course, in reality there is
no such class). When the SWIG module is compiled, all of the methods
get supplied by the original template class. A key thing to keep in
mind when working with templates is that SWIG can only handle
particular instantiations of a template (such as a list of
double). More general support is not yet provided (but may be added
someday).<p>

<h3> Renaming</h3>

C++ member functions and data can be renamed with the <tt>%name</tt>
directive. The <tt>%name</tt> directive only replaces the member
function name. For example :<p>

<p>
<blockquote><pre>class List {
public:
  List();
%name(ListSize) List(int maxsize);
  ~List();
  int  search(char *value); 
%name(find)    void insert(char *); 
%name(delete)  void remove(char *); 
  char *get(int n);
  int  length;
static void print(List *l);
};

</pre></blockquote>

This will create the functions <tt>List_find</tt>,
<tt>List_delete</tt>, and a function named <tt>new_ListSize</tt> for
the overloaded constructor.<p>
<p>
The <tt>%name </tt>directive can be applied to all members including
constructors, destructors, static functions, data members, and
enumeration values.<p>
<p>
The class name prefix can be changed by specifying <p>
<p>
<blockquote><pre>%name(newname) class List {
...
}
</pre></blockquote>

<h3> Adding new methods</h3>

New methods can be added to a class using the <tt>%addmethods</tt>
directive. This directive is primarily used in conjunction with shadow
classes to add additional functionality to an existing class. For
example :<p>
<p>
<blockquote><pre>%module vector
%{
#include "vector.h"
%}

class Vector {
public:
	double x,y,z;
	Vector();
	~Vector();
	... bunch of C++ methods ...
	%addmethods {
		char *__str__() {
			static char temp[256];
			sprintf(temp,"[ %g, %g, %g ]", v-&gt;x,v-&gt;y,v-&gt;z);
			return &amp;temp[0];
		}
	}
};
</pre></blockquote>
<p>

This code adds a<tt> __str__</tt> method to our class for producing a
string representation of the object. In Python, such a method would
allow us to print the value of an object using the <tt>print</tt>
command. <p>

<p>
<blockquote><pre>&gt;&gt;&gt;
&gt;&gt;&gt; v = Vector();
&gt;&gt;&gt; v.x = 3
&gt;&gt;&gt; v.y = 4
&gt;&gt;&gt; v.z = 0
&gt;&gt;&gt; print(v)
[ 3.0, 4.0, 0.0 ]
&gt;&gt;&gt;

</pre></blockquote>

The<tt> %addmethods</tt> directive follows all of the same conventions
as its use with C structures.<p>

<h3> Partial class definitions</h3>

Since SWIG is still somewhat limited in its support of C++, it may be
necessary to only use partial class information in an interface
file. This should not present a problem as SWIG does not need the
exact C++ specification. As a general rule, you should strip all
classes of operator overloading, friends, and other declarations
before giving them to SWIG (although SWIG will generate only warnings
for most of these things).<p>

<p>
As a rule of thumb, running SWIG on raw C++ header or source files is
currently discouraged. Given the complexity of C++ parsing and
limitations in SWIG's parser it will still take some time for SWIG's
parser to evolve to a point of being able to safely handle most raw
C++ files.<p>

<h3> SWIG, C++, and the Legislation of Morality</h3>

As languages go, C++ is quite possibly one of the most immense and
complicated languages ever devised. It is certainly a far cry from the
somewhat minimalistic nature of C. Many parts of C++ are designed to
build large programs that are "safe" and "reliable." However, as a
result, it is possible for developers to overload operators, implement
smart pointers, and do all sorts of other insane things (like
expression templates). As far as SWIG is concerned, the primary goal
is attaching to such systems and providing a scripting language
interface. There are many features of C++ that I would not have the
slightest idea how to support in SWIG (most kinds of templates for
example). There are other C++ idioms that may be unsafe to use with
SWIG. For example, if one implements "smart" pointers, how would they
actually interact with the pointer mechanism used by SWIG? <p>

<p>
Needless to say, handling all of the possible cases is probably
impossible. SWIG is certainly not guaranteed to work with every
conceivable type of C++ program (especially those that use C++ in a
maximal manner). Nor is SWIG claiming to build C++ interfaces in a
completely "safe" manner. The bottom line is that effective use of C++
with SWIG requires that you know what you're doing and that you have a
certain level of "moral flexibility" when it comes to the issue of
building a useful scripting language interface.<p>

<h3> The future of C++ and SWIG</h3>

SWIG's support of C++ is best described as an ongoing project. It will
probably remain evolutionary in nature for the foreseeable future. In
the short term, work is already underway for supporting nested classes
and function overloading. As always, these developments will take
time. Feedback and contributions are always welcome.<p>

<h2> Conditional compilation</h2>

SWIG does not run the C preprocessor, but it does support conditional
compilation of interface files in a manner similar to the C
preprocessor. This can be done by placed <tt>#ifdef</tt>,
<tt>#ifndef</tt>, <tt>#if</tt>, <tt>#else</tt>, <tt>#elif</tt>, and
<tt>#endif</tt> directives in your interface file. These directives
can be safely nested. This allows one to conditionally compile out
troublesome C/C++ code if necessary. For example, the following file
can serve as both a C header file and a SWIG interface file :<p>

<p>
<blockquote><pre>#ifdef SWIG
%module mymodule
%{
#include "header.h"
%}

%include wish.i
#endif

... normal C declarations here ...

</pre></blockquote>

<p>
Similarly, conditional compilation can be used to customize an
interface. The following interface file can be used to build a Perl5
module that works with either static or dynamic linking :<p>

<p>
<blockquote><pre>
%module mymodule
%{
#include "header.h"
%}

... Declarations ...

#ifdef STATIC
%include perlmain.i 				// Include code for static linking
#endif

</pre></blockquote>
However, it is not safe to use conditional compilation in the middle
of a declaration. For example :<p>
<p>
<blockquote><pre>double foo(
#ifdef ANSI_ARGS
double a, double b
#endif
);

</pre></blockquote>

This fails because the SWIG parser is not equipped to handle
conditional compilation directives in an arbitrary location (like the
C preprocessor). For files that make heavy use of the C preprocessor
like this, it may be better to run the header file through the C
preprocessor and use the output as the input to SWIG.<p>

<h3> Defining symbols</h3>

To define symbols, you can use the <tt>-D</tt> option as in :<p>

<blockquote><pre>
swig -perl5 -static -DSTATIC interface.i

</pre></blockquote>

Symbols can also be defined using <tt>#define</tt> with no
arguments. For example :<p>

<p>
<blockquote><pre>%module mymodule
#define STATIC 

... etc ...
</pre></blockquote>

<p>
For the purposes of conditional compilation, one should not assign
values to symbols. If this is done, SWIG interprets the #define as
providing the definition of a scripting language constant. <p>

<h3> The #if directive</h3>

The <tt>#if</tt> directive can only be used in the following context :<p>
<blockquote><pre>
#if defined(SYMBOL)
...
#elif !defined(OTHERSYMBOL)
...
#endif
</pre></blockquote>

<p>
The C preprocessor version supports any constant integral expression
as an argument to <tt>#if</tt>, but SWIG does not yet contain an
expression evaluator so this is not currently supported. As a result,
declarations such as the following don't yet work :<p>
<p>
<blockquote><pre>#if (defined(foo) || defined(bar))
...
#endif

</pre></blockquote>

<h3> Predefined Symbols</h3>
One or more of the following symbols will be defined by SWIG when it
is processing an interface file :<p>

<p>
<blockquote><pre>SWIG				Always defined when SWIG is processing a file
SWIGTCL				Defined when using Tcl
SWIGTCL8				Defined when using Tcl8.0
SWIGPERL				Defined when using Perl
SWIGPERL4				Defined when using Perl4
SWIGPERL5				Defined when using Perl5
SWIGPYTHON				Defined when using Python
SWIGGUILE				Defined when using Guile
SWIGWIN				Defined when running SWIG under Windows
SWIGMAC				Defined when running SWIG on the Macintosh

</pre></blockquote>
Interface files can look at these symbols as necessary to change the
way in which an interface is generated or to mix SWIG directives with
C code. These symbols are also defined within the C code generated by
SWIG (except for the symbol `<tt>SWIG</tt>' which is only defined
within the SWIG compiler).<p>

<h2> Code Insertion</h2>

Sometimes it is necessary to insert special code into the resulting
wrapper file generated by SWIG.  For example, you may want to include
additional C code to perform initialization or other operations.
There are four ways to insert code, but it's useful to know how the
output of SWIG is structured first.<p>

<h3> The output of SWIG</h3>

SWIG creates a single C source file containing wrapper functions,
initialization code, and support code. The structure of this file is
as follows :<p>

<center><img src="ch3.1.png"></center>

<p>
<p>
The headers portion typically contains header files, supporting code,
helper functions, and forward declarations. If you look at it, you'll
usually find a hideous mess since this also contains the SWIG run-time
pointer type-checker and internal functions used by the wrapper
functions. The "wrapper" portion of the output contains all of the
wrapper functions. Finally, the initialization function is a single C
function that is created to initialize your module when it is
loaded.<p>

<h3> Code blocks</h3>

A code block is enclosed by a <tt>%{, %}</tt> and is used to insert
code into the header portion of the resulting wrapper file. Everything
in the block is copied verbatim into the output file and will appear
before any generated wrapper functions.  Most SWIG input files have at
least one code block that is normally used to include header files and
supporting C code.  Additional code blocks may be placed anywhere in a
SWIG file as needed. <p>

<blockquote><pre>
%module mymodule
%{
#include "my_header.h"
%}

... Declare functions here
%{

... Include Tcl_AppInit() function here ...

%}
</pre></blockquote>

<p>
Code blocks are also typically used to write "helper" functions. These
are functions that are used specifically for the purpose of building
an interface and are generally not visible to the normal C
program. For example :<p>
<p>
<blockquote><pre>%{

/* Create a new vector */
static Vector *new_Vector() {
	return (Vector *) malloc(sizeof(Vector));
}

%}

// Now wrap it 
Vector *new_Vector();

</pre></blockquote>

<h3> Inlined code blocks</h3>

Because the process of writing helper functions is fairly common,
there is a special inlined form of code block that is used as follows
:<p>
<p>
<blockquote><pre>%inline %{
/* Create a new vector */
Vector *new_Vector() {
	return (Vector *) malloc(sizeof(Vector));
}
%}

</pre></blockquote>

The <tt>%inline</tt> directive inserts all of the code that follows
verbatim into the header portion of an interface file. The code is
then fed into the SWIG parser and turned into an interface. Thus, the
above example creates a new command <tt>new_Vector</tt> using only one
declaration. Since the code inside an <tt>%inline %{ ... %}</tt> block
is given to both the C compiler and SWIG, it is illegal to include any
SWIG directives inside the <tt>%{ ... %}</tt> block.<p>

<h3> Initialization blocks</h3>

Code may also be inserted using an initialization block, as shown
below :<p>
<p>
<blockquote><pre>%init %{

	init_variables();
%}
</pre></blockquote>

<p>
This code is inserted directly into SWIG's initialization function.
You can use it to perform additional initialization and operations.
Since this code is inserted directly into another function, it should
not declare functions or include header files.  Primarily this can be
used to add callouts to widgets and other packages that might also
need to be initialized when your extension is loaded.<p>

<h3> Wrapper code blocks</h3>

Code may be inserted in the wrapper code section of an output file
using the <tt>%wrapper</tt> directive as shown :<p>
<p>
<blockquote><pre>%wrapper %{
	... a bunch of code ...
%}

</pre></blockquote>

This directive, for almost all practical purposes, is identical to
just using a <tt>%{,%}</tt> block, but may be required for more
sophisticated applications. It is mainly only used for advanced
features in the SWIG library. As a general rule, you should avoid
using this directive unless you absolutely know what you are doing.<p>

<h2> A general interface building strategy</h2>

This section describes the general approach for building interface
with SWIG. The specifics related to a particular scripting language
are found in later chapters.<p>

<h3> Preparing a C program for SWIG</h3>

SWIG doesn't require modifications to your C code, but if you feed it
a collection of raw C header files or source code, the results might
not be what you expect---in fact, they might be awful. Here's a series
of steps you can follow to make an interface for a C program :<p>

<p>
<ul>
<li>Identify the functions that you want to wrap. It's probably not
necessary to access every single function in a C program--thus, a
little forethought can dramatically simplify the resulting scripting
language interface. C header files are particularly good source for
finding things to wrap.

<li>Create a new interface file to describe the scripting language
interface to your program.

<li>Copy the appropriate declarations into the interface file or use
SWIG's <tt>%include</tt> directive to process an entire C
source/header file. Either way, this step is fairly easy.

<li>Make sure everything in the interface file uses ANSI C/C++syntax.

<li>Check to make sure there aren't any functions involving function
pointers, or variable length arguments since SWIG doesn't like these
very much.

<li>Eliminate unnecessary C preprocessor directives. SWIG will
probably remove most of them, but better safe than sorry. Remember,
SWIG does not run the C preprocessor.

<li>Make sure all necessary `<tt>typedef</tt>' declarations and
type-information is available in the interface file.

<li>If your program has a main() function, you may need to rename it
(read on).

<li>Run SWIG and compile.
</ul>
<p>
While this may sound complicated, the process turns out to be
relatively easy in practice--for example, making an interface to the
entire OpenGL library only takes about 5-10 minutes.<p>
<p>
In the process of building an interface, you are encouraged to use
SWIG to find problematic declarations and specifications. SWIG will
report syntax errors and other problems along with the associated file
and line number. <p>

<h3> The SWIG interface file</h3>

The preferred method of using SWIG is to generate separate interface
file. Suppose you have the following C header file :<p>

<blockquote><pre>
/* File : header.h */

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

extern int foo(double);
extern double bar(int, int);
extern void dump(FILE *f);

</pre></blockquote>

A typical SWIG interface file for this header file would look like the
following :<p>

<blockquote><pre>
/* File : interface.i */
%module mymodule
%{
#include "header.h"
%}
extern int foo(double);
extern double bar(int, int);
extern void dump(FILE *f);

</pre></blockquote>
Of course, in this case, our header file is pretty simple so we could
have made an interface file like this as well:<p>

<p>
<blockquote><pre>/* File : interface.i */
%module mymodule
%include header.h
</pre></blockquote>
<p>
Naturally, your mileage may vary.<p>

<h3> Why use separate interface files?</h3>

While SWIG can parse many header files, it is more common to write a
special <tt>.i</tt> file defining the interface to a package. There
are several reasons for doing this :<p>
<p>
<ul>
<li>It is rarely necessary to access every single function in a large
package. Many C functions might have little or no use in a scripted
environment. Therfore, why wrap them?

<li>Separate interface files provide an opportunity to provide more
precise rules about how an interface is to be constructed.

<li>Interface files can provide structure and organization. For
example , you can break the interface up into sections, provide
documentation, and do other things that you might not normally do with
an ordinary .h file.

<li>SWIG can't parse certain definitions that appear in header
files. Having a separate file allows you to eliminate or work around
these problems.

<li>Interface files provide a precise definition of what the interface
is. Users wanting to extend the system can go to the interface file
and immediately see what is available without having to dig it out of
header files.
</ul>

<h3> Getting the right header files</h3>

Sometimes, it is necessary to use certain header files in order for
the code generated by SWIG to compile properly. You can have SWIG
include certain header files by using a <tt>%{,%}</tt> block as
follows :<p>

<blockquote><pre>
%module graphics
%{
#include &lt;GL/gl.h&gt;
#include &lt;GL/glu.h&gt;
%}

// Put rest of declarations here
...
</pre></blockquote>

<h3> What to do with main()</h3>

If your program defines a <tt>main()</tt> function, you may need to
get rid of it or rename it in order to use a scripting language. Most
scripting languages define their own <tt>main()</tt> procedure that
must be called instead. <tt>main()</tt> also makes no sense when
working with dynamic loading. There are a few approaches to solving
the <tt>main()</tt> conflict :<p>
<p>
<ul>
<li>Get rid of <tt>main()</tt> entirely. This is the brute force
approach.

<li>Rename <tt>main()</tt> to something else. You can do this by
compiling your C program with an option like <tt>-Dmain=oldmain</tt>.

<li>Use conditional compilation to only include <tt>main()</tt> when
not using a scripting language.
</ul>

<p>
Getting rid of <tt>main()</tt> may cause potential initialization
problems of a program. To handle this problem, you may consider
writing a special function called <tt>program_init()</tt> that
initializes your program upon startup. This function could then be
called either from the scripting language as the first operation, or
when the SWIG generated module is loaded.<p>

<p>
As a general note, many C programs only use the <tt>main()</tt>
function to parse command line options and to set parameters. However,
by using a scripting language, you are probably trying to create a
program that is more interactive. In many cases, the old
<tt>main()</tt> program can be completely replaced by a Perl, Python,
or Tcl script.<p>

<h3> Working with the C preprocessor</h3>

If you have a header file that makes heavy use of macros and C
preprocessor directives, it may be useful to run it through the C
preprocessor first. This can usually be done by running the C compiler
with the -E option. The output will be completely hideous, but macros
and other preprocessor directives should now be expanded as needed. If
you want to wrap a C preprocessor macro with SWIG, this can be done by
giving a function declaration with the same name and usage as the
macro. When writing the macro as a function declaration, you are
providing SWIG with type-information--without that, SWIG would be
unable to produce any sort of wrapper code. <p>

<h3> How to cope with C++</h3>

Given the complexity of C++, it will almost always be necessary to
build a special interface file containing suitably edited C++
declarations. If you are working with a system involving 400 header
files, this process will not be trivial. Perhaps the best word of
advice is to think hard about what you want this interface to
be. Also, is it absolutely critical to wrap every single function in a
C++ program? SWIG's support of C++ will improve with time, but I'll be
the first to admit that SWIG works much better with pure ANSI C code
when it comes to large packages.<p>

<h3> How to avoid creating the interface from hell</h3>

SWIG makes it pretty easy to build a big interface really fast. In
fact, if you apply it to a large enough package, you'll find yourself
with a rather large chunk of code being produced in the resulting
wrapper file. To give you an idea, wrapping a 1000 line C header file
with a large number of structure declarations may result in a wrapper
file containing 20,000-30,000 lines of code. I can only imagine what
wrapping a huge C++ class hierarchy would generate. Here's a few rules
of thumb for making smaller interfaces :<p>
<p>
<ul>
<li>Ask yourself if you really need to access particular functions. It
is usually not necessary to wrap every single function in a
package. In fact, you probably only need a relatively small subset.

<li>SWIG does not require structure definitions to operate. If you are
never going to access the members of a structure, don't wrap the
structure definition.

<li>Eliminate unneeded members of C++ classes.

<li>Think about the problem at hand. If you are only using a subset of
some library, there is no need to wrap the whole thing.

<li>Write support or helper functions to simplify common
operations. Some C functions may not be easy to use in a scripting
language environment. You might consider writing an alternative
version and wrapping that instead.
</ul>

<p>
Writing a nice interface to a package requires work. Just because you
use SWIG it doesn't mean that you're going to end up with a good
interface. SWIG is primarily designed to eliminate the tedious task of
writing wrapper functions. It does not eliminate the need for proper
planning and design when it comes to building a useful application. In
short, a little forethought can go a long way.<p>
<p>
Of course,if you're primarily interested in just slapping something
together for the purpose of debugging, rapid application development,
and prototyping, SWIG will gladly do it for you (in fact, I use SWIG
alot for this when developing other C/C++ applications).<p>
<p>

<p><hr>

<address>SWIG 1.3 - Last Modified : August 17, 2001</address>
</body>
</html>
