<html>
<head>
<title>Exception Handling</title>
</head>

<body bgcolor="#ffffff">
<h1>7 Exceptions, Features, and other Customization</h1>

In many cases, it is desirable to change the default wrapping of
particular declarations in an interface.  For example, you might want
to provide hooks for catching C++ exceptions, add assertions, or provide hints to the
underlying code generator.  This chapter describes some of these customization
techniques.  First, a discussion of exception handling is presented.  Then, a more
general-purpose customization technique is described.

<h2>The %exception directive</h2>

The <tt>%exception</tt> directive allows you to define a general purpose exception
handler. For example, you can specify the following:

<p>
<blockquote><pre>%exception {
    try {
        $action
    }
    catch (RangeError) {
        PyErr_SetString(PyExc_IndexError,"index out-of-bounds");
        return NULL;
    }
}
</pre></blockquote>
<p>

When defined, the code enclosed in braces is inserted directly into the low-level wrapper
functions.  The special symbol <tt>$action</tt> gets replaced with the actual operation
to be performed (a function call, method invocation, attribute access, etc.).  An exception handler
remains in effect until it is explicitly deleted.  This is done by using <tt>%except</tt> with
no code. For example:
<p>
<blockquote><pre>%exception;   // Deletes any previously defined handler
</pre></blockquote>

<h3> Handling exceptions in C code</h3>

C has no formal exception handling mechanism so there are several approaches that might be
used.  A somewhat common technique is to simply set a special error code.  For example:

<p>
<blockquote><pre>

/* File : except.c */

static char error_message[256];
static int error_status = 0;

void throw_exception(char *msg) {
	strncpy(error_message,msg,256);
	error_status = 1;
}

void clear_exception() {
	error_status = 0;
}
char *check_exception() {
	if (error_status) return error_message;
	else return NULL;
}

</pre></blockquote>

To use these functions, functions simply call
<tt>throw_exception()</tt> to indicate an error occurred. For example
:<p>
<p>
<blockquote><pre>double inv(double x) {
	if (x != 0) return 1.0/x;
	else {
		throw_exception("Division by zero");
		return 0;
	}
}

</pre></blockquote>

To catch the exception, you can write a simple exception handler such
as the following (shown for Perl5) :<p>

<p>
<blockquote><pre>%exception {
    char *err;
    clear_exception();
    $action
    if ((err = check_exception())) {
       croak(err);
    }
}
</pre></blockquote>
<p>
In this case, when an error occurs, it is translated into a Perl error.

<h3> Exception handling with longjmp()</h3>

Exception handling can also be added to C code using the
<tt>&lt;setjmp.h&gt;</tt> library.  Here is a minimalistic implementation that
relies on the C preprocessor :

<blockquote><pre>
/* File : except.c
   Just the declaration of a few global variables we're going to use */

#include &lt;setjmp.h&gt;
jmp_buf exception_buffer;
int exception_status;

/* File : except.h */
#include &lt;setjmp.h&gt;
extern jmp_buf exception_buffer;
extern int exception_status;

#define try if ((exception_status = setjmp(exception_buffer)) == 0)
#define catch(val) else if (exception_status == val)
#define throw(val) longjmp(exception_buffer,val)
#define finally else

/* Exception codes */

#define RangeError     1
#define DivisionByZero 2
#define OutOfMemory    3

</pre></blockquote>

Now, within a C program, you can do the following :<p>

<p>
<blockquote><pre>double inv(double x) {
	if (x) return 1.0/x;
	else throw(DivisionByZero);
}

</pre></blockquote>

Finally, to create a SWIG exception handler, write the following :<p>

<p>
<blockquote><pre>%{
#include "except.h"
%}

%exception {
	try {
		$action
	} catch(RangeError) {
		croak("Range Error");
	} catch(DivisionByZero) {
		croak("Division by zero");
	} catch(OutOfMemory) {
		croak("Out of memory");
	} finally {
		croak("Unknown exception");
	}
}
</pre></blockquote>

Note: This implementation is only intended to illustrate the general idea.  To make it work better, you'll need to
modify it to handle nested <tt>try</tt> declarations.

<h3> Handling C++ exceptions</h3>

Handling C++ exceptions is generally straightforward.  For example: 

<p>
<blockquote><pre>%exception {
	try {
		$action
	} catch(RangeError) {
		croak("Range Error");
	} catch(DivisionByZero) {
		croak("Division by zero");
	} catch(OutOfMemory) {
		croak("Out of memory");
	} catch(...) {
		croak("Unknown exception");
	}
}

</pre></blockquote>

The exception types need to be declared as classes elsewhere, possibly
in a header file :<p>

<p>
<blockquote><pre>class RangeError {};
class DivisionByZero {};
class OutOfMemory {};

<h3>Defining different exception handlers</h3>

By default, the <tt>%exception</tt> directive creates an exception
handler that is used for all wrapper functions that follow it.
Creating one universal exception handler for all functions may be
unwieldy and promote excessive code bloat since the handler will be
inlined into each wrapper function created. 
<p>

There are several ways to fix this.  First,  you can selectively place
<tt>%exception</tt> directives around critical pieces of code. For example:

<p>
<blockquote><pre>%exception {
	... your exception handler ...
}
/* Define critical operations that can throw exceptions here */

%exception;

/* Define non-critical operations that don't throw exceptions */
</pre></blockquote>

<h3>Exception handling for specific declarations</h3>

More precise control over exception handling can be obtained by attaching an exception handler
to specific declaration name. For example:

<blockquote>
<pre>
%exception allocate {
    try {
        $action
    } 
    catch (MemoryError) {
        croak("Out of memory");
    }
}
</pre>
</blockquote>

In this case, the exception handler is only attached to declarations named "allocate".  This would include both global and
member functions.   The names supplied to <tt>%exception</tt> follow the same rules as for <tt>%rename</tt>.  For example, if
you wanted to define an exception handler for a specific class, you might write this:

<blockquote>
<pre>
%exception Object::allocate {
    try {
        $action
    } 
    catch (MemoryError) {
        croak("Out of memory");
    }
}
</pre>
</blockquote>

When a class prefix is supplied, the exception handler is applied to the corresponding declaration in the
specified class as well as for identically named functions appearing in derived classes.  

<p>
<tt>%exception</tt> can even be used to pinpoint a precise declaration when overloading is used. For example:

<blockquote>
<pre>
%exception Object::allocate(int) {
    try {
        $action
    } 
    catch (MemoryError) {
        croak("Out of memory");
    }
}
</pre>
</blockquote>

Attaching exceptions to specific declarations is a good way to reduce code bloat.  It can also be a useful way to attach
exceptions to specific parts of a header file. For example:

<blockquote>
<pre>
%module example
%{
#include "someheader.h"
%}

// Define a few exception handlers for specific declarations
%exception Object::allocate(int) {
    try {
        $action
    } 
    catch (MemoryError) {
        croak("Out of memory");
    }
}
%exception Object::getitem {
    try {
       $action
    }
    catch (RangeError) {
       croak("Index out of range");
    }
}
...
// Grab a header file
%include "someheader.h"
</pre>
</blockquote>

<h3> Applying exception handlers to specific datatypes.</h3>

An alternative approach to using the <tt>%exception</tt> directive is to
use the "except" typemap.  This allows you to attach an error handler
to specific datatypes and function name.  The typemap is applied to
the return value of a function.  For example :<p>

<p>
<blockquote><pre>%typemap(except) void *malloc {
    $action
    if (!$1) {
	PyExc_SetString(PyExc_MemoryError,"Out of memory in $symname");
        return NULL;
    }
}

void *malloc(int size);

</pre></blockquote>

When applied, this automatically checks the return value of
<tt>malloc()</tt> and raises an exception if it's invalid.  For example
:<p>

<p>
<blockquote><pre>
&gt;&gt;&gt; from example import *
&gt;&gt;&gt; a = malloc(2048)
&gt;&gt;&gt; b = malloc(1500000000)
Traceback (innermost last):
  File "&lt;stdin&gt;", line 1, in ?
MemoryError: Out of memory in malloc
&gt;&gt;&gt;
</pre></blockquote>

When "except" typemaps are used, they override any exception handler defined with
<tt>%exception</tt>.<p>

<h2> Using The SWIG exception library</h2>

The <tt>exception.i</tt> library file provides support for creating
language independent exceptions in your interfaces.  To use it, simply
put an "<tt>%include exception.i</tt>" in your interface file.  This
creates a function<tt> SWIG_exception()</tt> that can be used to raise
scripting language exceptions in a portable manner.  For example :<p>

<p>
<blockquote><pre>// Language independent exception handler
%include exception.i       

%exception {
    try {
        $action
    } catch(RangeError) {
        SWIG_exception(SWIG_ValueError, "Range Error");
    } catch(DivisionByZero) {
        SWIG_exception(SWIG_DivisionByZero, "Division by zero");
    } catch(OutOfMemory) {
        SWIG_exception(SWIG_MemoryError, "Out of memory");
    } catch(...) {
        SWIG_exception(SWIG_RuntimeError,"Unknown exception");
    }
}

</pre></blockquote>

As arguments, <tt>SWIG_exception()</tt> takes an error type code (an
integer) and an error message string.  The currently supported error
types are :<p>

<p>
<blockquote><pre>SWIG_MemoryError
SWIG_IOError
SWIG_RuntimeError
SWIG_IndexError
SWIG_TypeError
SWIG_DivisionByZero
SWIG_OverflowError
SWIG_SyntaxError
SWIG_ValueError
SWIG_SystemError
SWIG_UnknownError
</pre></blockquote>
<p>

Since the <tt>SWIG_exception()</tt> function is defined at the C-level
it can be used elsewhere in SWIG. This includes typemaps and helper
functions.  The exception library provides a language-independent
exception handling mechanism, so many of SWIG's library files now rely
upon this library as well.<p>

<p><hr>

<address>SWIG 1.3 - Last Modified : August 18, 2001</address>
</body>
</html>
