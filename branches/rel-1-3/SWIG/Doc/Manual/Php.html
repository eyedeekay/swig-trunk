<!-- Hand crafted HTML -->
<html>
<head>
<title>SWIG and PHP4</title>
</head>

<body bgcolor="#ffffff">
<a name="n0"></a><h1>SWIG and PHP4</h1>

<b>Caution: This chapter (and module!) is still under construction</b>

<p>
<ul>
<li> <a href="#n1">Preliminaries</a>
<li> <a href="#n2">Building PHP Extensions</a>
<li> <a href="#n3">Building a loadable extension</a>
<li> <a href="#n4">Building extension into php</a>
<li> <a href="#n5">Modules and classes </a> (TODO)
<li> <a href="#n6">Basic PHP4 interface</a> (TODO)
<li> <a href="#n7">Simple Example</a> (TODO)
<li> <a href="#n8">Arrays and other objects</a> (TODO)
<li> <a href="#n9">Remapping datatypes with typemaps</a> (TODO)
<li> <a href="#n10">Constants</a>
<li> <a href="#n11">PHP4 Pragmas</a>
</ul>

In this chapter, we discuss SWIG's support of PHP4. The PHP4 module is 
still under development so some of the features below may not work properly
(or at all!.)

<a name="n1"></a><h2> Preliminaries</h2>
In order to use this module, you will need to have a copy of the PHP 4.0 (or
above) include files to compile the SWIG generated files. You can find these
files by running <tt>'php-config --includes'</tt>. To test the modules you will
need either the php binary or the Apache php module. If you want to build your
extension into php directly (without having the overhead of loading it into
each script), you will need the complete PHP source tree available.

<a name="n2"></a><h2> Building PHP4 Extensions</h2>
To build a PHP4 extension, run swig using the <tt>-php4</tt> option as follows :
<p>
<blockquote><pre>
swig -php4 example.i

</pre></blockquote>
This will produce 3 files by default. The first file, <tt>example_wrap.c</tt>
contains all of the C code needed to build a PHP4 extension. The second file,
<tt>php_example.h</tt> contains the header information needed to link the
extension into PHP. The third file, <tt>example.php</tt> can be included by
your php scripts.  It will attempt to dynamically load your extension, and is
a place-holder for extra code specified in the interface file.  If you want to
build your extension using the <tt>phpize</tt> utility, or if you want to 
build your module into PHP directly, you can specify the <tt>-phpfull</tt> 
command line argument to swig.
<p>
The <tt>-phpfull</tt> will generate three extra files.
The first extra file, <tt>config.m4</tt> contains the shell code needed to
enable the extension as part of the PHP4 build process. The second extra file,
<tt>Makefile.in</tt> contains the information needed to build the final
Makefile after substitutions. The third and final extra file, <tt>CREDITS</tt>
should contain the credits for the extension.
<p>
To finish building the extension, you have two choices. You can either build 
the extension as a seperate object file which will then have to be explicitly
loaded by each script. Or you can rebuild the entire php source tree and build
the extension into the php executable/library so it will be available in every
script.  The first choice is the default, however it can be changed by passing
the '-phpfull' command line switch to select the second build method.  

<a name="n3"></a><h3>Building a loadable extension</h3>

To build a dynamic module for PHP, you have two options.  You can use the
<tt>phpize</tt> utility, or you can do it manually.
To build with phpize, after you have run swig you will need
to run the 'phpize' command (installed as part of php) in the same
directory. This re-creates the php build environment in that directory. It also
creates a configure file which includes the shell code from the config.m4 that
was generated by SWIG, this configure script will accept a command line argument
to enable the extension to be run ( by default the command line argument is 
--enable-modulename, however you can edit the config.m4 file before running 
phpize to accept --with-modulename. You can also add extra tests in config.m4 
to check that a correct library version is installed or correct header files
are included, etc, but you must edit this file before running phpize. )
<p>
Before running the generated configure file, you may need to edit the <tt>
Makefile.in</tt> file. This contains the names of the source files to compile 
(just the wrapper file by default) and any additional libraries needed to be
linked in. If there are extra C files to compile, you will need to add them
to the Makefile.in, or add the names of libraries if they are needed.
<p>
You then run the configure script with the command line argument needed
to enable the extension. Then run make, which builds the extension.
The extension object file will be left in the modules sub directory, you can
move it to wherever it is convenient to call from your php script. 
<p>
To build manually, use a compile string similar to this (different for each
OS):
<blockquote><pre>
	cc -I.. $(PHPINC) -fpic -c example_wrap.c
	cc -shared example_wrap.o -o libexample.so
</pre></blockquote>
<p>
To test the extension from a PHP script, you need to load it first. You do
this by putting the line,
<blockquote><pre>
	dl("/path/to/modulename.so");	// Load the module
</pre></blockquote>
at the start of each PHP file.  SWIG also generates a php module, which
attempts to do the <tt>dl()</tt> call for you:
<blockquote><pre>
	include("example.php");
</pre></blockquote>

<a name="n4"></a><h3>Building extension into php</h3>

This method, selected with the '-phpfull' command line switch, involves
rebuilding the entire php source tree. Whilst more complicated to build,
it does mean that the extension is then available without having to load it 
in each script. 
<p>
After running swig with the -phpfull switch, you will be left with a shockingly
similiar set of files to the previous build process. However you will then need
to move these files to a subdirectory within the php source tree, this subdirectory you will need to create under the ext directory, with the name of the extension ( e.g mkdir php-4.0.6/ext/modulename .)
<p>
After moving the files into this directory, you will need to run the 'buildall'
script in the php source directory. This rebuilds the configure command
and includes the extra command line arguments from the module you have added. 
<p>
Before running the generated configure file, you may need to edit the <tt>
Makefile.in</tt>. This contains the names of the source files to compile (
just the wrapper file by default) and any additional libraries needed to
link in. If their are extra C files to complile you will need to add them
to the Makefile, or add the names of libraries if they are needed.
<p>
You then need to run the configure command and pass the necessary command
line arguments to enable your module ( by default this is --enable-modulename,
but this can be changed by editing the config.m4 file in the modules directory
before running the buildall script. In addition, extra tests can be added to
the config.m4 file to ensure the correct libraries and header files are 
installed.)
<p>
Once configure has completed, you can run make to build php. If this all
compiles correctly, you should end up with a php executable/library
which contains your new module. You can test it with a php script which
does not have the 'dl' command as used above.

<a name="n10"></a><h3> Constants</h3>

These work in much the same way as in C/C++, constants can be defined by using
either the normal C pre-processor declarations, or the '%constant' SWIG 
directive.  These will then be available from your PHP script as a variable,
however you do not need to put the dollar sign before the constant name. 
For example, with a swig file like this,
<p>
<blockquote><pre>
%module example

#define PI 3.14159

%constant int E  = 2.84

</pre>
</blockquote>
<p>
you can access from in your php script like this,
<blockquote><pre>
&lt;?
dl("example.so");	# If extension built as shared object, load it now.

echo "Pi = ", PI, "\n";

echo "E = ", E, "\n";

?&gt;
</pre>
</blockquote>

<p>
There are two peculiarities with using constants in PHP4. The first is that
if you try to use an undeclared constant, it will evaulate to a string
set to the constants name. For example,
<p>
<blockquote><pre>
%module example

#define EASY_TO_MISPELL	1

</pre>
</blockquote>
accessed incorrectly in PHP,
<p>
<blockquote>
<pre>
&lt;?
dl("example.so");	#  If extension built as shared object, load it now.

if(EASY_TO_MISPEL) {
	....
} else {
	....
}

?&gt;
</pre>
</blockquote>
<p>

will issue a warning about the undeclared constant, but will then evalute
it and turn it into a string ('EASY_TO_MISPEL'), which will cause the if test to evalute to true rather than false. This is a feature.
<p>
The second oddity is that although constants are case sensitive (by default),
you cannot declare a constant twice with alternative cases. E.g.,
<p>
<blockquote>
<pre>
%module example

#define TEST	Hello
#define Test	World

</pre>
</blockquote>
accessed from PHP,
<p>
<pre>
<blockquote>
&lt;?
dl("example.so");	#  If extension built as shared object, load it now.

echo TEST, Test;

?&gt;
</blockquote>
</pre>
<p>
will output "Hello Test" rather than "Hello World". This is because internally,
all constants are stored in a hash table by their lower case name, so 'TEST' and
'Test' will map to the same hash element ('Test'). But, because we declared them case sensitive, the Zend engine will test if the case matches with the case the
constant was declared with first. 
<p>
So, in the example above, the TEST constant was declared first, and will be stored under the hash element 'test'. The 'Test' constant will also map to the same hash element 'test', but will not overwrite it. When called from the script, the TEST constant will again be mapped to the hash element 'test' so the constant will be retrieved. The case will then be checked, and will match up, so the value ('Hello') will be returned. When 'Test' is evaulated, it will also map to the same hash element 'test'. The same constant will be retrieved, this time though the case check will fail as 'Test' != 'TEST'. So PHP will assume that Test is a undeclared constant, and as explained above, will return it as a string set to the constant name ('Test'). Hence the script above will print 'Hello Test'. If
they were declared non-case sensitive, the output would be 'Hello Hello', as
both point to the same value, without the case test taking place.
</pre>
</blockquote>

<a name="n10"></a><h3>PHP4 Pragmas</h3>

There are a few pragmas understood by the PHP4 module.  The first, 
<b>include</b> adds a file to be included by the generated PHP module.  The
second, <b>code</b> adds literal code to the generated PHP module.  The third,
<b>phpinfo</b> inserts code to the function called when PHP's phpinfo()
function is called.


<blockquote><pre>
	/* example.i */

	%pragma(php4) include="foo.php"
	%pragma(php4) code="
	  function foo($bar) {
		/* do something */
	  }
	"
	%pragma(php4) phpinfo="
	  zend_printf("An example of PHP support through SWIG\n");
	  php_info_print_table_start();
	  php_info_print_table_header(2, \"Directive\", \"Value\");
	  php_info_print_table_row(2, \"Example support\", \"enabled\");
	  php_info_print_table_end();
	"

	%include "example.h"
</pre></blockquote>



<a name="h5"></a><h3>To be furthered...</h3>
</body>
</html>
