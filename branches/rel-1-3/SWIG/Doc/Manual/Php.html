<!-- Hand crafted HTML -->
<html>
<head>
<title>SWIG and PHP4</title>
</head>

<body bgcolor="#ffffff">
<a name="n0"></a><h1>SWIG and PHP4</h1>

<b>Caution: This chapter (and module!) is still under construction</b>

<p>
<ul>
<li> <a href="#n1">Preliminaries</a>
<li> <a href="#n2">Building PHP Extensions</a>
<li> <a href="#n3">Building a loadable extension</a>
<li> <a href="#n4">Building extension into php</a>
<li> <a href="#n5">Modules and classes</a>
<li> <a href="#n6">Basic PHP4 interface</a>
<li> <a href="#n7">Simple Example</a>
<li> <a href="#n8">Arrays and other objects</a>
<li> <a href="#n9">Remapping datatypes with typemaps</a>
<li> <a href="#n10">Constants</a>
</ul>

In this chapter, we discuss SWIG's support of PHP4. The PHP4 module is 
still under development so some of the features below may not work properly
(or at all!.)

<a name="n1"></a><h2> Preliminaries</h2>
In order to use this module, you will need to have a copy of the PHP 4.0 (or above) include files to compile the SWIG generated files. To test the modules
you will need either the php binary or the Apache php module. If you want to
build your extension into php directly (without having the overhead of loading
it into each script), you will need the complete PHP source tree available.

<a name="n2"></a><h2> Building PHP4 Extensions</h2>
To build a PHP4 extension, run swig using the <tt>-php4</tt> option as follows :
<p>
<blockquote><pre>
swig -php4 example.i

</pre></blockquote>
This will produce 5 files by default. The first file, <tt>example_wrap.c</tt> contains all of the C code needed to build a PHP4 extension. The second file, <tt>php_example.h</tt> contains the header information needed to link the extension into PHP.
The third file, <tt>config.m4</tt> contains the shell code needed to enable 
the extension as part of the PHP4 build process. The fourth file, <tt>Makefile.in</tt> contains the information needed to build the final Makefile after substitutions. The fifth and final file, <tt>CREDITS</tt> should contain the credits for
the extension. The last three files are only needed for the build process and
you can stop then from being generated by passing the '-noextra' command line
switch.
<p>
To finish building a extension, you have two choices. You can either build the 
extension as a seperate object file which will then have to be explicitly loaded
by each script. Or you can rebuild the entire php source tree and build the 
extension into the php executable/library so it will be available in every 
script.  The first choice is the default, however it can be changed by passing 
the '-phpall' command line switch to select the second build method.

<a name="n3"></a><h3>Building a loadable extension</h3>

In order to complete the compilation, after you have run swig you will need
to run the 'phpize' command (installed as part of php ) in the same
directory. This re-creates the php build environment in that directory. It also
creates a configure file which includes the shell code from the config.m4 that
was generated by SWIG, this configure script will accept a command line argument
to enable the extension to be run ( by default the command line argument is 
--enable-modulename, however you can edit the config.m4 file before running 
phpize to accept --with-modulename. You can also add extra tests in config.m4 
to check that a correct library version is installed or correct header files
are included, etc, but you must edit this file before running phpize. )
<p>
Before running the generated configure file, you may need to edit the <tt>
Makefile.in</tt> file. This contains the names of the source files to compile 
(just the wrapper file by default) and any additional libraries needed to be
linked in. If there are extra C files to compile, you will need to add them
to the Makefile.in, or add the names of libraries if they are needed.
<p>
You then run the configure script with the command line argument needed
to enable the extension. Then run make, which builds the extension.
The extension object file will be left in the modules sub directory, you can
move it to wherever it is convenient to call from your php script. To test
the extension from a PHP script, you need to load it first. You do this
by putting the line,
<blockquote><pre>
	dl("/path/to/modulename.so");	// Load the module
</pre></blockquote>

at the start of each PHP file.

<a name="n4"></a><h3>Building extension into php</h3>

This method, selected with the '-phpall' command line switch, involves
rebuilding the entire php source tree. Whilst more complicated to build,
it does mean that the extension is then available without having to load it 
in each script. 
<p>
After running swig with the -phpall switch, you will be left with a shockingly
similiar set of files to the previous build process. However you will then need
to move these files to a subdirectory within the php source tree, this subdirectory you will need to create under the ext directory, with the name of the extension ( e.g mkdir php-4.0.6/ext/modulename .)
<p>
After moving the files into this directory, you will need to run the 'buildall'
script in the php source directory. This rebuilds the configure command
and includes the extra command line arguments from the module you have added. 
<p>
Before running the generated configure file, you may need to edit the <tt>
Makefile.in</tt>. This contains the names of the source files to compile (
just the wrapper file by default) and any additional libraries needed to
link in. If their are extra C files to complile you will need to add them
to the Makefile, or add the names of libraries if they are needed.
<p>
You then need to run the configure command and pass the necessary command
line arguments to enable your module ( by default this is --enable-modulename,
but this can be changed by editing the config.m4 file in the modules directory
before running the buildall script. In addition, extra tests can be added to
the config.m4 file to ensure the correct libraries and header files are 
installed.)
<p>
Once configure has completed, you can run make to build php. If this all
compiles correctly, you should end up with a php executable/library
which contains your new module. You can test it with a php script which
does not have the 'dl' command as used above.



<a name="h10"></a><h3> Constants</h3>

These work in much the same way as in C/C++, constants can be defined by using
either the normal C pre-processor declarations, or the '%constant' SWIG 
directive.  These will then be available from your PHP script as a variable,
however you do not need to put the dollar sign before the constant name. 
For example, with a swig file like this,
<p>
<blockquote><pre>
%module example

#define PI 3.14159

%constant int E  = 2.84

</pre>
</blockquote>
<p>
you can access from in your php script like this,
<blockquote><pre>
&lt;?
dl("example.so");	# If extension built as shared object, load it now.

echo "Pi = ", PI, "\n";

echo "E = ", E, "\n";

?&gt;
</pre>
</blockquote>

<p>
There are two peculiarities with using constants in PHP4. The first is that
if you try to use an undeclared constant, it will evaulate to a string
set to the constants name. For example,
<p>
<blockquote><pre>
%module example

#define EASY_TO_MISPELL	1

</pre>
</blockquote>
accessed incorretly in php,
<p>
<pre>
<blockquote>
&lt;?
dl("example.so");	#  If extension built as shared object, load it now.

if(EASY_TO_MISPEL) {
	....
} else {
	....
}

?&gt;
</blockquote>
</pre>
<p>

will issue a warning about the undeclared constant, but will then evalute
it and turn it into a string ('EASY_TO_MISPEL'), which will cause the if test to evalute to true rather than false. This is a feature.
<p>
The second oddity is that by default constants are case sensitive, (although
this can be altered using the third parameter to the define statement in PHP),
but you cannot declare a constant twice with alternative cases. E.g.,
<p>
<pre>
<blockquote>
%module example

#define TEST	Hello
#define Test	World

</blockquote>
</pre>
accessed from PHP,
<p>
<pre>
<blockquote>
&lt;?
dl("example.so");	#  If extension built as shared object, load it now.

echo TEST, Test;

?&gt;
</blockquote>
</pre>
<p>
will output "Hello Test" rather than "Hello World". This is because internally,
all constants are stored in a hash table by their lower case name, so 'TEST' and
'Test' will map to the same hash element. But, because we declared them case
sensitive, the Zend engine will test if the case matches with the case the
constant was declared with first. So, in the example above, the TEST constant 
was declared first, and will be stored under the hash element 'test'. The
'Test' declaration will also map to the same hash element 'test', but will not 
overwrite it. When called from the script, the TEST constant will again be
mapped to the hash element 'test' so the constant will be retrieved. The case
will then be checked, and will match up, so the value ('Hello') will be
returned. When 'Test' is evaulated, it will also map to the same hash element
'test'. The same constant will be retrieved, this time though the case check
will fail as 'Test' != 'TEST'. So PHP will assume that Test is a undeclared
constant, and as explained above, will return it as a string set to the
constant name ('Test'). Hence the script above will print 'Hello Test'. If
they were declared non-case sensitive, the output would be 'Hello Hello', as
both point to the same value, without the case test taking place.
</pre>
</blockquote>


<a name="h5"></a><h3>To be furthered...</h3>
</body>
</html>
