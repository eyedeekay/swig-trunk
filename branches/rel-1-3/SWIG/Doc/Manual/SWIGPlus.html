<html>
<head>
<title>SWIG and C++</title>
</head>

<body bgcolor="#ffffff">
<h1>4 SWIG and C++</h1>

This chapter describes SWIG's support for wrapping C++.  As a prerequisite,
you should first read the chapter <a href="SWIG.html">SWIG Basics</a> to see
how SWIG wraps ANSI C.  Support for C++ is mostly an extension of ANSI C
wrapping and that material will be useful in understanding this chapter.

<h2>Comments on C++ Wrapping</h2>

Because of its sheer complexity, and the fact that C++ can be
difficult to integrate with itself let alone other languages, SWIG is
only able to provide support for a subset of C++ features.  

<p>
In part, the problem with C++ wrapping is that there is no
semantically obvious (or automatic ) way to map many of its advanced
features into other languages.  As a simple example, consider the
problem of wrapping C++ multiple inheritance to a target language with
no such support.  Similarly, the use of overloaded operators and
overloaded functions can be problematic when no such capability exists
in a target language.

<p>
A more subtle issue with C++ has to do with the way that some C++
programmers think about programming libraries.  In the world of SWIG,
what you are really trying to do is to create binary-level software
components for use in other languages.  In order for this to work, a
"component" has to contain real executable instructions and there has
to be some kind of binary linking mechanism for accessing its
functionality.  In contrast, C++ has increasingly relied upon generic
programming and templates for much of its functionality.  Although
templates are a powerful feature, they are largely orthogonal to the
whole notion of binary components and libraries.  For example, an STL
<tt>vector</tt> does not define any kind of binary object for which
SWIG can just create a wrapper.  To further complicate matters, these
libraries often utilize a lot of behind the scenes magic in which the
semantics of seemingly basic operations (e.g., pointer dereferencing,
procedure call, etc.) can be changed in dramatic and sometimes
non-obvious ways.  Although this "magic" may present few problems in a
C++-only universe, it greatly complicates the problem of crossing
language boundaries and provides many opportunities to shoot yourself
in the foot.  You will have to be careful.

<p>
To wrap C++, SWIG takes a deliberately conservative, low-level, and
non-intrusive approach.  For one, SWIG generates all of its C++
wrappers so that they have standard ANSI C linkage.  This low-level
interface is then used as a basis for building the resulting scripting
language module (which may or may not utilize OO features).  Second, SWIG does not encapsulate C++ classes inside
special adaptor or proxy classes, it does not rely upon additional
template magic, nor does it use C++ inheritance.  The last thing that
most C++ programs need is even more compiler magic.  Therefore, SWIG
tries to maintain a very strict and clean separation between the
implementation of your C++ application and the resulting wrapper
code. You might say that SWIG has been written to follow the principle
of least surprise--it does not play sneaky tricks with the C++ type
system, it doesn't mess with your class hierarchies, and it doesn't
introduce new semantics.  Although this approach might not provide the
most seamless integration with C++, it is safe, simple, portable, and
debuggable.

<h2>Supported C++ features</h2>

SWIG currently supports the following C++ features :<p>
<p>
<ul>
<li>Simple classes.
<li>Constructors and destructors
<li>Virtual functions
<li>Public inheritance (including multiple inheritance)
<li>Static functions
<li>Function and method overloading (with renaming)
<li>Operator overloading for most standard operators
<li>References
<li>Simple templates
<li>Pointers to members
</ul>

<p>
The following C++ features are not currently supported :<p>

<p>
<ul>
<li>Automatic function and method overloading
<li>Nested classes
<li>Namespaces
<li>Template specialization
<li>Overloaded versions of certain operators (new, delete, etc.)
</ul>

<p>
SWIG's C++ support is always improving so some of these limitations may be lifted
in future releases.  However, we make no promises.

<h2> A simple C++ example</h2>
The following code shows a SWIG interface file for a simple C++
class.<p>

<p>
<blockquote><pre>%module list
%{
#include "list.h"
%}

// Very simple C++ example for linked list

class List {
public:
  List();
  ~List();
  int  search(char *value);
  void insert(char *);
  void remove(char *);
  char *get(int n);
  int  length;
static void print(List *l);
};
</pre></blockquote>

<p>
When compiling C++ code, it is critical that SWIG be called with the
`<tt>-c++</tt>' option. This changes the way a number of critical
features such as memory management are handled. It
also enables the recognition of C++ keywords. Without the <tt>-c++</tt>
flag, SWIG will either issue a warning or a large number of syntax
errors if it encounters C++ code in an interface file.<p>

<h3>Constructors and destructors</h3>

C++ constructors and destructors are translated into accessor
functions such as the following :<p>

<p>
<blockquote><pre>List * new_List(void) {
	return new List;
}
void delete_List(List *l) {
	delete l;
}

</pre></blockquote>
If a C++ class does not define any public constructors or
destructors, SWIG will automatically create a default constructor or 
destructor.   However, there are a few rules that define this behavior:

<ul>
<li>A default constructor is not created if a class already defines a constructor with arguments.

<p>
<li>Default constructors are not generated for classes with pure virtual methods.

<p>
<li>A default constructor is not created unless all bases classes support a 
default constructor. 

<p>
<li>Default constructors and destructors are not created if a class
defines constructors or destructors in a <tt>private</tt> or <tt>protected</tt> section.

<p>
<li>Default constructors and destructors are not created if any base
class defines a private default constructor or a private destructor.
</ul>

SWIG should never generate a constructor or destructor for a class in which
it is illegal to do so.   However, if it is necessary to disable the
default constructor/destructor creation, the <tt>%nodefault</tt> directive
can be used:

<blockquote>
<pre>
%nodefault;   // Disable creation of constructor/destructor
class Foo {
...
};
%makedefault;
</pre>
</blockquote>

<b>Compatibility Note:</b> The generation of default
constructors/destructors was made the default behavior in SWIG
1.3.7. This may break certain older modules, but the old behavior can
be easily restored using <tt>%nodefault</tt> or the
<tt>-nodefault</tt> command line option.  Furthermore, in order for
SWIG to properly generate (or not generate) default constructors, it
must be able to gather information from both the <tt>private</tt> and
<tt>protected</tt> sections (specifically, it needs to know if a private or
protected constructor/destructor is defined).   In older versions of
SWIG, it was fairly common to simply remove or comment out
the private and protected sections of a class due to parsing limitations.
However, this removal may now cause SWIG to erroneously generate constructors
for classes that define a constructor in those sections.  Consider restoring
those sections in the interface or using <tt>%nodefault</tt> to fix the problem.

<h3> Member functions</h3>

All member functions are roughly translated into accessor functions like this :<p>
<p>
<blockquote><pre>int List_search(List *obj, char *value) {
	return obj-&gt;search(value);
}

</pre></blockquote>

This translation is the same even if the member function has been
declared as <tt>virtual</tt>.

<p>
It should be noted that SWIG does not actually create a C accessor
function in the code it generates.  Instead, member access such as
<tt>obj-&gt;search(value)</tt> is directly inlined into the generated
wrapper functions.  However, the name and calling convention of the
wrappers match the accessor function prototype described above.

<h3> Static members</h3>

Static member functions are called directly without making any special
transformations. For example, the static member function
<tt>print(List *l)</tt> directly invokes <tt>List::print(List *l)</tt>
in the generated wrapper code.

<p>
Usually, static members are accessed as functions with names in which the class name has been
prepended with an underscore. For example, <tt>List_print</tt>.

<h3> Member data</h3>

Member data is handled in exactly the same manner as for C
structures. A pair of accessor functions will be created. For example
:<p>

<p>
<blockquote><pre>int List_length_get(List *obj) {
	return obj-&gt;length;
}
int List_length_set(List *obj, int value) {
	obj-&gt;length = value;
	return value;
}

</pre></blockquote>

A read-only member can be created using the <tt>%readonly</tt> and
<tt>%readwrite</tt> directives. For example, we probably wouldn't want
the user to change the length of a list so we could do the following
to make the value available, but read-only.<p>

<p>
<blockquote><pre>class List {
public:
...
%readonly
	int length;
%readwrite
...
};
</pre></blockquote>

Similarly, all data attributes declared as <tt>const</tt> are wrapped as read-only members.

<h2>Protection</h2>

SWIG can only wrap class members that are declared public. Anything
specified in a private or protected section will simply be ignored (although
the internal code generator sometimes looks at the contents of the private and protected
sections so that it can properly generate code for default constructors and destructors). 

<p>
By default, members of a class definition are assumed to be private
until you explicitly give a `<tt>public:</tt>' declaration (This is
the same convention used by C++).<p>

<h2>Enums and constants</h2>

Enumerations and constants placed in a class definition are mapped
into constants with the classname as a prefix. For example :<p>
<p>
<blockquote><pre>class Swig {
public:
	enum {ALE, LAGER, PORTER, STOUT};
};

</pre></blockquote>
Generates the following set of constants in the target scripting language :<p>
<p>
<blockquote><pre>Swig_ALE = Swig::ALE
Swig_LAGER = Swig::LAGER
Swig_PORTER = Swig::PORTER
Swig_STOUT = Swig::STOUT

</pre></blockquote>

Members declared as <tt>const</tt> are wrapped as read-only members and do not create constants.

<h2>References and pointers</h2>

C++ references are supported, but SWIG transforms them back into pointers. For example,
a declaration like this :<p>
<p>
<blockquote><pre>class Foo {
public:
	double bar(double &amp;a);
}
</pre></blockquote>
<p>
is accessed using a function similar to this:<p>
<p>
<blockquote><pre>double Foo_bar(Foo *obj, double *a) {
	obj-&gt;bar(*a);
}
</pre></blockquote>

Functions that return a reference are remapped to return a pointer instead.
For example:

<blockquote><pre>
class Bar {
public:
     double &spam();
};
</pre>
</blockquote>

Generates code like this:

<blockquote>
<pre>
double *Bar_spam(Bar *obj) {
   double &result = obj->spam();
   return &result;
}
</pre>
</blockquote>
Don't return references to objects allocated as local variables on the
stack.  SWIG doesn't make a copy of the objects so this will probably
cause your program to crash.

<h2>Pass and return by value</h2>

Occasionally, a C++ program will pass and return class objects by value.  For example, a function
like this might appear:

<blockquote>
<pre>
Vector cross_product(Vector a, Vector b);
</pre>
</blockquote>

If no information is supplied about <tt>Vector</tt>, SWIG creates a wrapper function similar to the
following:

<blockquote>
<pre>
Vector *wrap_cross_product(Vector *a, Vector *b) {
   Vector x = *a;
   Vector y = *b;
   Vector r = cross_product(x,y);
   return new Vector(r);
}</pre>
</blockquote>

In order for the wrapper code to compile, <tt>Vector</tt> must define a copy constructor and have a default
constructor.

<p>
If <tt>Vector</tt> is defined as class in the interface, SWIG changes the wrapper code by rewriting the
arguments as C++ references.  This means that the function is handled as if were declared exactly like this:

<blockquote>
<pre>
Vector cross_product(Vector &a, Vector &b);
</pre>
</blockquote>

Then, a wrapper such as the following is created:

<blockquote>
<pre>
Vector *wrap_cross_product(Vector *a, Vector *b) {
   Vector r = cross_product(*a,*b);
   return new Vector(r);
}
</pre>
</blockquote>

This transformation to references is made so that uninitialized
arguments of type <tt>Vector</tt> do not appear in the wrapper code
(thus avoiding compiler errors related to missing default constructors).

<h2>Inheritance</h2>

SWIG supports C++ public inheritance of classes and allows both
single and multiple inheritance. The SWIG type-checker knows about the
relationship between base and derived classes and allows pointers
to any object of a derived class to be used in functions of a base
class. The type-checker properly casts pointer values and is safe to
use with multiple inheritance.

<p> SWIG does not support private or protected inheritance (it is
parsed, but it has no effect on the generated code).  Note: private
and protected inheritance do not define an "isa" relationship between
classes so it would have no effect on type-checking anyways.

<p>
The following example shows how SWIG handles inheritance. For clarity,
the full C++ code has been omitted.<p>

<p>
<blockquote><pre>// shapes.i
%module shapes
%{
#include "shapes.h"
%}

class Shape {
public:
        double x,y;
	virtual double area() = 0;
	virtual double perimeter() = 0;
	void    set_location(double x, double y);
};
class Circle : public Shape {
public:
	Circle(double radius);
	~Circle();
	double area();
	double perimeter();
};
class Square : public Shape {
public:
	Square(double size);
	~Square();
	double area();
	double perimeter();
}
</pre></blockquote>

<p>
When wrapped into Python, we can now perform the following operations
:<p>

<p>
<blockquote><pre>$ python
&gt;&gt;&gt; import shapes
&gt;&gt;&gt; circle = shapes.new_Circle(7)
&gt;&gt;&gt; square = shapes.new_Square(10)
&gt;&gt;&gt; print shapes.Circle_area(circle)
153.93804004599999757
&gt;&gt;&gt; print shapes.Shape_area(circle)
153.93804004599999757
&gt;&gt;&gt; print shapes.Shape_area(square)
100.00000000000000000
&gt;&gt;&gt; shapes.Shape_set_location(square,2,-3)
&gt;&gt;&gt; print shapes.Shape_perimeter(square)
40.00000000000000000
&gt;&gt;&gt;
</pre></blockquote>

In this example,  Circle and Square objects have been created.  Member
functions can be invoked on each object by making calls to
<tt>Circle_area</tt>, <tt>Square_area</tt>, and so on. However, the same
results can be accomplished by simply using the <tt>Shape_area</tt>
function on either object.<p>

<p>
One important point concerning inheritance is that the low-level
accessor functions are only generated for classes in which they are
actually declared.  For instance, in the above example, the method
<tt>set_location()</tt> is only accessible as
<tt>Shape_set_location()</tt> and not as
<tt>Circle_set_location()</tt> or <tt>Square_set_location()</tt>.  Of
course, the <tt>Shape_set_location()</tt> function will accept any
kind of object derived from Shape.  Similarly, accessor functions for
the attributes <tt>x</tt> and <tt>y</tt> are generated as
<tt>Shape_x_get()</tt>, <tt>Shape_x_set()</tt>,
<tt>Shape_y_get()</tt>, and <tt>Shape_y_set()</tt>.  Functions such as
<tt>Circle_x_get()</tt> are not available--instead you should use
<tt>Shape_x_get()</tt>.

<p>
Although the low-level C-like interface is functional, most language
modules also produce a higher level OO interface using a technique
known as shadow classing.  This approach is described shortly and can be
used to provide a more natural C++ interface.

<p>
<b>Compatibility Note:</b> Starting in version 1.3.7, SWIG only
generates low-level accessor wrappers for the declarations that are
actually defined in each class.  This differs from SWIG1.1 which used
to inherit all of the declarations defined in base classes and
regenerate specialized accessor functions such as
<tt>Circle_x_get()</tt>, <tt>Square_x_get()</tt>,
<tt>Circle_set_location()</tt>, and <tt>Square_set_location()</tt>.
This old behavior results in huge amounts of replicated code for large
class hierarchies and makes it awkward to build applications spread
across multiple modules (since accessor functions are duplicated in
every single module).   It is also unnecessary to have such wrappers
when advanced features like shadow-classing are used.  Future versions
of SWIG may apply further optimizations such as not regenerating 
wrapper functions for virtual members that are already defined in a base class.

<h2>Renaming</h2>

C++ member functions and data can be renamed with the <tt>%name</tt>
directive. The <tt>%name</tt> directive only replaces the member
function name. For example :<p>

<p>
<blockquote><pre>class List {
public:
  List();
%name(ListSize) List(int maxsize);
  ~List();
  int  search(char *value); 
%name(find)    void insert(char *); 
%name(delete)  void remove(char *); 
  char *get(int n);
  int  length;
static void print(List *l);
};

</pre></blockquote>

This will create the functions <tt>List_find</tt>,
<tt>List_delete</tt>, and a function named <tt>new_ListSize</tt> for
the overloaded constructor.<p>
<p>
The <tt>%name </tt>directive can be applied to all members including
constructors, destructors, static functions, data members, and
enumeration values.<p>
<p>
The class name prefix can also be changed by specifying <p>
<p>
<blockquote><pre>%name(newname) class List {
...
}
</pre></blockquote>

Although the <tt>%name()</tt> directive can be used to help deal with
overloaded methods, it really doesn't work very well because it
requires a lot of additional markup in your interface.  Keep reading
for a better solution.

<h2>Wrapping Overloaded Functions and Methods</h2>

This section describes the problem of wrapping overloaded C++
functions and methods.  This has long been a limitation of SWIG that
has only recently been addressed (primarily because we couldn't quite
figure out how to do it without causing a head-explosion or
serious reliability problems).  However, in order to understand the reasoning
behind the current solution, it is important to better understand the
problem.

<p>
In C++, functions and methods can be overloaded by declaring them with
different type signatures.  For example:

<blockquote>
<pre>
void foo(int);
void foo(double);
void foo(Bar *b, Spam *s, int );
</pre>
</blockquote>

Later, when a call to function <tt>foo()</tt> is made, the
determination of which function to invoke is made by looking at the types
of the arguments.  For example:

<blockquote>
<pre>
int x;
double y;
Bar *b;
Spam *s;
int z;
...
foo(x);        // Calls foo(int)
foo(y);        // Calls foo(double)
foo(b,s,z);    // Calls foo(Bar *, Spam *, int)
</pre>
</blockquote>

It is important to note that the selection of the overloaded method or
function is made by the C++ compiler and occurs at <b>compile
time</b>.  It does not occur as your program runs.

<p>
Internal to the C++ compiler, overloaded functions are mapped to unique
identifiers using a name-mangling technique where the arguments are used to create
a unique type signature that is appended to the name.  This produces 
three unique function names that might look like this:

<blockquote>
<pre>
void foo__Fi(int);
void foo__Fd(double);
void foo__FP3BarP4Spami(Bar *, Spam *, int);
</pre>
</blockquote>

Calls to <tt>foo()</tt> are then mapped to an appropriate version depending on
the types of arguments passed.

<p>
The implementation of overloaded methods in C++ is difficult to
translate directly to a scripting language environment because it
relies on static type-checking and compile-time binding of
methods--neither of which map to the dynamic
environment of an interpreter.  For example,
in Python, Perl, and Tcl, it is simply impossible to define three entirely different
versions of a function with exactly the same name within the same scope.    The repeated
definitions simply replace previous definitions.

<p>
Therefore, to solve the overloading problem, let's first look at
several approaches that have been proposed as solutions, but which are
<b>NOT</b> used to solve the overloading problem in SWIG.

<ul>
<li><b>Explicit renaming</b>.  In earlier versions of SWIG, the only
way to handle overloading was to explicitly rename overloaded methods
to a unique name using the <tt>%name</tt> directive.  For example:

<blockquote>
<pre>
void foo(int);
%name(foo_d) foo(double);
%name(foo_barspam) foo(Bar *, Spam *, int);
</pre>
</blockquote>

Although this certainly works, it is extremely annoying to explicitly
annotate every class with a bunch of <tt>%name</tt> directives like that.  It fact,
it's so annoying that this really isn't a viable solution at all (except in
cases where there is very little overloading).  Dave sincerely apologizes for ever
thinking that this approach was good enough--however, let's try to forget the past and move on.

<p>
<li><b>Name Mangling</b>.  Another approach to overloading would be to
automatically generate name-mangled versions of the functions.
Although this would definitely work, it would also make the scripting
language interface extremely annoying to use.  For instance, does anyone
really want to type things like this in their program?

<blockquote>
<pre>
foo__FP3BarP4Spami(b,s,i);
</pre>
</blockquote>

Needless to say, this approach is not used by SWIG nor has it ever been seriously considered.

<p>
<li><b>Simplified Name Mangling</b>.  An alternative name mangling
approach would be to generate a simplified name mangling.  For
example, maybe you could just take the first letter of each type and
use it as the signature.  For example:

<blockquote>
<pre>
void foo(int);                  // becomes foo_i(int)
void foo(double);               // becomes foo_d(int)
void foo(Bar *, Spam *, int);   // becomes foo_BSi(int)
</pre>
</blockquote>

Although a lot more readable than the fully mangled version, this now has the
problem of naming clashes.  For instance, what is supposed to happen with these
two functions?

<blockquote>
<pre>
void foo(int i);               // ?????
void foo(instance *obj);       // ?????
</pre>
</blockquote>

Also, what happens if the mangled version happens to match a legitimate identifier
name used elsewhere in the program?  One could use the <tt>%name</tt> directive to
resolve such a conflict, but this tends to defeat the whole point.  Although this
might work in simple cases, there are still a number of obvious problems.

<p>
<li><b>Numbering</b>.  Another simple solution might be to number all of
the overloaded methods in order of definition. For example:

<blockquote>
<pre>
void foo(int);                  // becomes foo_1(int)
void foo(double);               // becomes foo_2(int)
void foo(Bar *, Spam *, int);   // becomes foo_3(int)
</pre>
</blockquote>

Unfortunately, the numbering doesn't give any clues about what the
actual function is.  Also, if the order changes or a new function is
added, all of the numbers might change--breaking all of the programs
written against the interface.  There is also a tiny problem
of naming methods with multiple inheritance:

<blockquote>
<pre>
class X {
public:
   virtual void foo(int);                // X_foo_1
   virtual void foo(double);             // X_foo_2
};

class Y {
public:
   virtual void foo(long);               // Y_foo_1
   virtual void foo(Bar *, Spam *, int); // Y_foo_2
};

class Z : public X, public Y {
public:
   virtual void foo(double);             // Z_foo_1 ??? Mismatch X_foo_2
   virtual void foo(Bar *, Spam *, int); // Z_foo_2 ??? 
  // What happens to X_foo_1 and Y_foo_1 here?
};
</pre>
</blockquote>

In this case, the member functions have different names in the base class than they
do in a derived class!  Clearly this is just bizarre and not particularly 
obvious to someone who has to maintain the resulting code.
Again, this doesn't seem to be a viable solution except in very simple cases.

<p>
<li><b>Dynamic dispatch</b>.  By far, the most powerful approach to the problem
would be to implement some kind of dynamic dispatch mechanism in the
code generator.  For example, you might generate some code roughly 
equivalent to this pseudocode:

<blockquote>
<pre>
wrap_foo(args):
   if len(args) == 3:
        if (args[0].type == Bar and 
           args[1].type == Spam and
           args[2].type == int):
               foo((Bar *) arg[0], (Spam *) arg[1], (int) arg[2])
   else if len(args) == 1:
        if args[0].type == int:
               foo((int) args[0])
        else if args[0].type == double:
               foo((double) args[0])
   else:
        raise "Bad arguments to foo"
</pre>
</blockquote>

Unfortunately there are serious problems with this approach as
well. First, the addition of dynamic dispatch code introduces a
performance hit on the execution time of overloaded methods since the
arguments to each method call have to first be examined to figure out
which function to dispatch.  Although the sample code above doesn't
look too bad, this procedure may involve interaction with the SWIG
type-checker, typemaps (a SWIG customization scheme), and other more
advanced parts of the interpreter.  A more nasty problem has to do
with functions that can accept the same type of scripting object.  For
example, if you have this,

<blockquote>
<pre>
void foo(int);
void foo(double);
</pre>
</blockquote>

the <tt>foo(double)</tt> function will probably accept both a
scripting language integer and a floating point number as an argument.
As a result, it's possible for the <tt>foo(double)</tt> function to
hide the integer function <tt>foo(int)</tt> if arguments aren't
checked in the correct order.  For instance, if you switch the order
of the two functions in the interface file, does <tt>foo(int)</tt> suddenly become
unavailable?  To deal with this problem, you might decide to make all
of the overloaded functions additionally available through name mangling.  However,
that now introduces all of the problems of name mangling plus all of
the problems of dynamic dispatch!  

<p>
The bottom line is that even though some kind of dynamic dispatch
scheme may be the "best" way to support overloading, it is 
difficult to implement and it has some serious shortcomings including
performance, hiding of functions, and possibly poor interaction with some of
SWIG's customization features.

<p>
<li><b>Trial Execution</b>.  An approach that is somewhat similar to dynamic dispatch
would be to implement a trial execution scheme.   In this case, each overloaded
function would generate a unique wrapper function, possibly with a name-mangled name. 
For example, something like this:

<blockquote>
<pre>
wrap_foo_i(args) {
    ...
    foo((int) arg[0]);
    ...
}
wrap_foo_d(args) {
    ...
    foo((double) arg[0]);
    ...
}
wrap_foo_BSi(args) {
    ...
    foo((Bar *) arg[0], (Spam *) arg[1], (int) arg[2]);
    ...
}
</pre>
</blockquote>

Next, a top-level wrapper could be written like this:

<blockquote>
<pre>
wrap_foo(args) {
   if (wrap_foo_i(args) == SUCCESS) return SUCCESS;
   if (wrap_foo_d(args) == SUCCESS) return SUCCESS;
   if (wrap_foo_BSi(args) == SUCCESS) return SUCCESS;
   return ERROR, "No matching function foo";
}
</pre>
</blockquote>
Like dynamic dispatch, this solution suffers from a 
performance penalty from trying to start the execution of each
possible function.  In fact, the impact may be worse since the only
way to determine the proper function is to try all possibilities until
no errors occur (dynamic dispatch could make more intelligent
choices).  Another problem is that a function might throw an ERROR for
a different reason than improper arguments (maybe the arguments were
okay, but something happened during execution).  Therefore, you would
need to have some kind of special error condition to indicate an error
in argument conversion.  A more subtle problem arises with languages such as
Ruby and Perl that handle errors by executing a <tt>longjmp()</tt> to return control
back to the interpreter (in which case, the above approach won't work like we want). 
Finally, making this approach work with inheritance and all
of SWIG's customization options is also problematic.


<p>
Of all of the schemes mentioned, trial execution is the most likely
feature that might be added to SWIG in the future.  However, no such
support is planned at this time.

<p>
<li><b>Don't allow overloading</b>.  Easy to implement and extremely annoying to
C++ programmers, but not particularly useful.
</ul>

Alas, what to do about overloading?

<p>
Although it would be nice to support an advanced wrapping technique
such as dynamic dispatch or trial execution, both of these techniques
are difficult (if not impossible) to implement in a completely general
manner that would work in all situations and with all combinations of
SWIG customization features.  Therefore, rather than generate wrappers
that only work some of the time, SWIG takes a slightly different
approach.

<p>
Starting with SWIG-1.3.7, a very simple enhancement has been added to
the <tt>%rename</tt> directive to help disambiguate overloaded
functions and methods.  Normally, the <tt>%rename</tt> directive is
used to rename a declaration everywhere in an interface file.  For
example, if you write this,

<blockquote>
<pre>
%rename(foo) bar;
</pre>
</blockquote>

all occurences of "bar" will be renamed to "foo" (this feature was
described a little earlier in this chapter in the section "Renaming
Declarations").  By itself, this doesn't do anything to help fix
overloaded methods.  However, the <tt>%rename</tt> directive can now be
parameterized as shown in this example:

<blockquote>
<pre>
/* Forward renaming declarations */
%rename(foo_i) foo(int); 
%rename(foo_d) foo(double);
...
void foo(int);           // Becomes 'foo_i'
void foo(char *c);       // Stays 'foo' (not renamed)

class Spam {
public:
   void foo(int);      // Becomes 'foo_i'
   void foo(double);   // Becomes 'foo_d'
   ...
};
</pre>
</blockquote>

Since, the <tt>%rename</tt> declaration is used to declare a renaming in advance, it can be
placed at the start of an interface file.  This makes it possible to apply a consistent name
resolution without having to modify header files. For example:

<blockquote>
<pre>
%module foo

/* Rename these overloaded functions */
%rename(foo_i) foo(int); 
%rename(foo_d) foo(double);

%include "header.h"
</pre>
</blockquote>

When used in this simple form, the renaming is applied to all global functions and member functions
that match the prototype.   If you only want the renaming to apply to a certain scope, the C++
scope resolution operator (::) can be used.  For example:

<blockquote>
<pre>
%rename(foo_i) ::foo(int);      // Only rename foo(int) in the global scope.
                                // (will not rename class members)

%rename(foo_i) Spam::foo(int);  // Only rename foo(int) in class Spam
</pre>
</blockquote>

When a renaming operator is applied to a class as in <tt>Spam::foo(int)</tt>, it is applied to
that class and all derived classes.   This can be used to apply a consistent renaming across
an entire class hierarchy with only a few declarations.  For example:

<blockquote>
<pre>
%rename(foo_i) Spam::foo(int);
%rename(foo_d) Spam::foo(double);

class Spam {
public:
   virtual void foo(int);      // Renamed to foo_i
   virtual void foo(double);   // Renamed to foo_d
   ...
};

class Bar : public Spam {
public:
   virtual void foo(int);      // Renamed to foo_i
   virtual void foo(double);   // Renamed to foo_d
...
};

class Grok : public Bar {
public:
   virtual void foo(int);      // Renamed to foo_i
   virtual void foo(double);   // Renamed to foo_d
...
};
</pre>
</blockquote>

Depending on your application, it may make more sense to include <tt>%rename</tt> specifications
in the class definition. For example:

<blockquote>
<pre>
class Spam {
%rename(foo_i) foo(int);
%rename(foo_d) foo(double);
public:
   virtual void foo(int);      // Renamed to foo_i
   virtual void foo(double);   // Renamed to foo_d
   ...
};

class Bar : public Spam {
public:
   virtual void foo(int);      // Renamed to foo_i
   virtual void foo(double);   // Renamed to foo_d
...
};
</pre>
</blockquote>

In this case, the <tt>%rename</tt> directives still get applied across the entire 
inheritance hierarchy, but it's no longer necessary to explicitly specify the
class prefix <tt>Spam::</tt>. 

<p>
A special form of <tt>%rename</tt> can be used to apply a renaming just to class
members (of all classes):

<blockquote>
<pre>
%rename(foo_i) *::foo(int);   // Only rename foo(int) if it appears in a class.
</pre>
</blockquote>

Note: the <tt>*::</tt> syntax is non-standard C++, but the '*' is meant to be a
wildcard that matches any class name (we couldn't think of a better
alternative so if you have a better idea, send email to
swig-dev@cs.uchicago.edu).

<p>
Although the <tt>%rename</tt> approach does not automatically solve the overloading
problem for you (you have to supply a name), SWIG's error messages have been improved to help.
For example, consider this interface file:

<blockquote>
<pre>
%module foo

class Spam {
public:
   void foo(int);
   void foo(double);
   void foo(Bar *, Spam *, int);
};
</pre>
</blockquote>

If you run SWIG on this file, you will get the following error messages:

<blockquote>
<pre>
foo.i:6. Overloaded declaration ignored.  Spam::foo(double )
foo.i:5. Previous declaration is Spam::foo(int )
foo.i:7. Overloaded declaration ignored.  Spam::foo(Bar *,Spam *,int )
foo.i:5. Previous declaration is Spam::foo(int )
</pre>
</blockquote>

The error messages indicate the problematic functions along with their
type signature.  In addition, the previous definition is supplied.
Therefore, you can just look at these errors and decide how you want
to handle the overloaded functions.  For example:

<blockquote>
<pre>
%module foo
%rename(foo_d)         Spam::foo(double);               // name foo_d
%rename(foo_barspam)   Spam::foo(Bar *, Spam *, int);   // name foo_barspam
...
class Spam { 
...
};
</pre>
</blockquote>

And again, for a class hierarchy, you may be able to solve all of the
problems by just renaming members in the base class--those renamings
automatically propagate to all derived classes.

<p>
Another way to resolve overloaded methods is to simply eliminate conflicting definitions.
An easy way to do this is to use the <tt>%ignore</tt> directive.  <tt>%ignore</tt>
works exactly like <tt>%rename</tt> except that it forces a declaration to disappear.
For example:

<blockquote>
<pre>
%ignore foo(double);          // Ignore all foo(double)
%ignore Spam::foo;            // Ignore foo in class Spam
%ignore Spam::foo(double);    // Ignore foo(double) in class Spam
%ignore *::foo(double);       // Ignore foo(double) in all classes
</pre>
</blockquote>

When applied to a base class, <tt>%ignore</tt> forces all definitions in derived clases
to disappear. For example, <tt>%ignore Spam::foo(double)</tt> will eliminate <tt>foo(double)</tt> in
<tt>Spam</tt> and all classes derived from <tt>Spam</tt>.

<p>
A few implementation notes about the enhanced <tt>%rename</tt> directive and <tt>%ignore</tt>:

<ul>
<li>The scope qualifier (::) can also be used on simple names.  For example:
<blockquote>
<pre>
%rename(bar) ::foo;       // Rename foo to bar in global scope only
%rename(bar) Spam::foo;   // Rename foo to bar in class Spam only
%rename(bar) *::foo;      // Rename foo in classes only
</pre>
</blockquote>

<p>
<li>Name matching tries to find the most specific match that is
defined.  A qualified name such as <tt>Spam::foo</tt> always has
higher precedence than an unqualified name <tt>foo</tt>.
<tt>Spam::foo</tt> has higher precedence than <tt>*::foo</tt> and
<tt>*::foo</tt> has higher precedence than <tt>foo</tt>.  A
parameterized name has higher precedence than an unparameterized name
within the same scope level.  However, an unparameterized name with a
scope qualifier has higher precedence than a parameterized name in
global scope (e.g., a renaming of <tt>Spam::foo</tt> takes precedence
over a renaming of <tt>foo(int)</tt>).

<p>
<li>
The order in which <tt>%rename</tt> directives are defined does not matter
as long as they appear before the declarations to be renamed.  Thus, there is no difference
between saying:

<blockquote>
<pre>
%rename(bar) foo;
%rename(foo_i) Spam::foo(int);
%rename(Foo) Spam::foo;
</pre>
</blockquote>

and this

<blockquote>
<pre>
%rename(Foo) Spam::foo;
%rename(bar) foo;
%rename(foo_i) Spam::foo(int);
</pre>
</blockquote>

(the declarations are not stored in a linked list and order has no
importance).  Of course, a repeated <tt>%rename</tt> directive will
change the setting for a previous <tt>%rename</tt> directive if exactly the 
same name, scope,  and parameters are supplied.

<p>
<li>For multiple inheritance where renaming rules are defined for multiple base classes,
the first renaming rule found on a depth-first traversal of the class hierarchy 
is used.

<p>
<li>The name matching rules are applied to both qualified and non-qualified members.
For example, if you have a class like this:

<blockquote>
<pre>
class Foo {
public:
   ...
   void bar() const;
   ...
};
</pre>
</blockquote>

the declaration <tt>%rename(name) Foo::bar()</tt> applies to the qualified member <tt>bar() const</tt>.
However, an often overlooked C++ feature is that classes can define two different overloaded members
that differ only in their qualifiers, like this:

<blockquote>
<pre>
class Foo {
public:
   ...
   void bar();         // Unqualified member
   void bar() const;   // Qualified member (OK)
   ...
};
</pre>
</blockquote>

Even when renaming is used, this still generates an error (both
<tt>bar()</tt> methods will be renamed to the same thing).  However,
if you want to silence the errors, <tt>%rename</tt> and
<tt>%ignore</tt> can be further specialized with qualifiers. For
example, the following directive would tell SWIG to ignore the
<tt>const</tt> version of <tt>bar()</tt> above:

<blockquote>
<pre>
%ignore Foo::bar() const;   // Ignore bar() const, but leave other bar() alone
</pre>
</blockquote>
</ul>

<h2>Wrapping overloaded operators</h2>

Starting in SWIG-1.3.10, C++ overloaded operator declarations can be wrapped. 
For example, consider a class like this:

<blockquote>
<pre>
class Complex {
private:
  double rpart, ipart;
public:
  Complex(double r = 0, double i = 0) : rpart(r), ipart(i) { }
  Complex(const Complex &c) : rpart(c.rpart), ipart(c.ipart) { }
  Complex &operator=(const Complex &c) {
    rpart = c.rpart;
    ipart = c.ipart;
    return *this;
  }
  Complex operator+(const Complex &c) const {
    return Complex(rpart+c.rpart, ipart+c.ipart);
  }
  Complex operator-(const Complex &c) const {
    return Complex(rpart-c.rpart, ipart-c.ipart);
  }
  Complex operator*(const Complex &c) const {
    return Complex(rpart*c.rpart - ipart*c.ipart,
		   rpart*c.ipart + c.rpart*ipart);
  }
  Complex operator-() const {
    return Complex(-rpart, -ipart);
  }
  double re() const { return rpart; }
  double im() const { return ipart; }
};
</pre>
</blockquote>

When operator declarations appear, they are handled in
<em>exactly</em> the same manner as regular methods.  However, the
names of these methods are set to strings like "<tt>operator +</tt>"
or "<tt>operator -</tt>".  The problem with these names is that they
are illegal identifiers in most scripting languages.  For instance,
you can't just create a method called "<tt>operator +</tt>" in
Python--there won't be any way to call it.

<p>
Some language modules already know how to automatically handle certain
operators (mapping them into operators in the target language).
However, the underlying implementation of this is really managed in a
very general way using the <tt>%rename</tt> directive.  For example,
in Python a declaration similar to this is used:

<blockquote>
<pre>
%rename(__add__) Complex::operator+;
</pre>
</blockquote>

This binds the + operator to a method called <tt>__add__</tt> (which
is conveniently the same name used to implement the Python + operator). 
Internally, the generated wrapper code for a wrapped operator will look
something like this pseudocode:

<blockquote>
<pre>
_wrap_Complex___add__(args) {
   ... get args ...
   obj->operator+(args);
   ...
}
</pre>
</blockquote>

When used in the target language, it may now be possible to use the overloaded
operator normally. For example:

<blockquote>
<pre>
>>> a = Complex(3,4)
>>> b = Complex(5,2)
>>> c = a + b           # Invokes __add__ method
</pre>
</blockquote>

It is important to realize that there is nothing magical happening here.  The <tt>%rename</tt> directive
really only picks a valid method name.   If you wrote this:

<blockquote>
<pre>
%rename(add) operator+;
</pre>
</blockquote>

The resulting scripting interface might work like this:

<blockquote>
<pre>
a = Complex(3,4)
b = Complex(5,2)
c = a.add(b)      # Call a.operator+(b)
</pre>
</blockquote>

All of the techniques described to deal with overloaded functions also apply to operators.
For example:

<blockquote>
<pre>
%ignore Complex::operator=;             // Ignore = in class Complex
%ignore *::operator=;                   // Ignore = in all classes
%ignore operator=;                      // Ignore = everywhere.

%rename(__sub__) Complex::operator-; 
%rename(__neg__) Complex::operator-();  // Unary - 
</pre>
</blockquote>

The last part of this example illustrates how multiple definitions of the <tt>operator-</tt> method
might be handled.

<p>
Handling operators in this manner is mostly straightforward.  However, there are a few subtle
issues to keep in mind:

<ul>
<li>In C++, it is fairly common to define different versions of the operators to account for
different types.  For example, a class might also include a friend function like this:

<blockquote>
<pre>
class Complex {
public:
  friend Complex operator+(Complex &, double);
};
Complex operator+(Complex &, double);
</pre>
</blockquote>

SWIG simply ignores all <tt>friend</tt> declarations.   Furthermore, it doesn't know how to associate the
associated <tt>operator+</tt> with the class (because it's not a member of the class).

<p>
It's still possible to make a wrapper for this operator, but you'll have to handle it like a normal
function. For example:

<blockquote>
<pre>
%rename(add_complex_double) operator+(Complex &, double);
</pre>
</blockquote>

<p>
<li>Certain operators are ignored by default. For instance, <tt>new</tt> and <tt>delete</tt> operators
are ignored as well as conversion operators.

<p>
<li>The semantics of certain C++ operators may not match those in the target language.
</ul>

<h2>Adding new methods</h2>

New methods can be added to a class using the <tt>%addmethods</tt>
directive. This directive is primarily used in conjunction with shadow
classes to add additional functionality to an existing class. For
example :<p>
<p>
<blockquote><pre>%module vector
%{
#include "vector.h"
%}

class Vector {
public:
	double x,y,z;
	Vector();
	~Vector();
	... bunch of C++ methods ...
	%addmethods {
		char *__str__() {
			static char temp[256];
			sprintf(temp,"[ %g, %g, %g ]", v-&gt;x,v-&gt;y,v-&gt;z);
			return &amp;temp[0];
		}
	}
};
</pre></blockquote>
<p>

This code adds a<tt> __str__</tt> method to our class for producing a
string representation of the object. In Python, such a method would
allow us to print the value of an object using the <tt>print</tt>
command. <p>

<p>
<blockquote><pre>&gt;&gt;&gt;
&gt;&gt;&gt; v = Vector();
&gt;&gt;&gt; v.x = 3
&gt;&gt;&gt; v.y = 4
&gt;&gt;&gt; v.z = 0
&gt;&gt;&gt; print(v)
[ 3.0, 4.0, 0.0 ]
&gt;&gt;&gt;

</pre></blockquote>

The<tt> %addmethods</tt> directive follows all of the same conventions
as its use with C structures.<p>

<h2>Templates</h2>

In all versions of SWIG, template type names may appear anywhere a type
is expected in an interface file.  For example:

<blockquote>
<pre>
void foo(vector&lt;int&gt; *a, int n);
</pre>
</blockquote>

Starting with SWIG-1.3.7, simple C++ template declarations can also be
wrapped.  Before discussing this any further, there are a few things
you need to know about template wrapping.  First, a bare C++ template
does not define any sort of runnable object-code for which SWIG can
normally create a wrapper.  Therefore, in order to wrap a template,
you need to give SWIG information about a particular template
instantiation (e.g., <tt>vector&lt;int&gt;</tt>,
<tt>array&lt;double&gt;</tt>, etc.).  Second, an instantiation name
such as <tt>vector&lt;int&gt;</tt> is generally not a valid identifier
name in most target languages.  Thus, you will need to give the
template instantiation a more suitable name such as <tt>intvector</tt>
when creating a wrapper.

<p>
To illustrate, consider the following (and admittedly lame) template
class declaration:

<p>
<blockquote><pre>// File : list.h
template&lt;class T&gt; class List {
private:
    T *data;
    int nitems;
    int maxitems;
public:
    List(int max) {
      data = new T [max];
      nitems = 0;
      maxitems = max;
    }
    ~List() {
      delete [] data;
    };
    void append(T obj) {
      if (nitems &lt; maxitems) {
        data[nitems++] = obj;
      }
    }
    int length() {
      return nitems;
    }
    T get(int n) {
      return data[n];
    }
};
</pre></blockquote>

By itself, this template declaration is useless--SWIG simply ignores it
because it doesn't know how to generate any code until unless a definition of
<tt>T</tt> is provided.

<p>
To create wrappers for a specific template instantiation, use the <tt>%template</tt> directive like this:

<blockquote>
<pre>
/* Instantiate a few different versions of the template */
%template(intList) List&lt;int&gt;;
%template(doubleList) List&lt;double&gt;;
</pre>
</blockquote>

The argument to <tt>%template()</tt> is the name of the
instantiation in the target language.  Most target languages do not
recognize identifiers such as <tt>List&lt;int&gt;</tt>.  Therefore,
each instantiation of a template has to be associated with a nicely
formatted identifier such as <tt>intList</tt> or <tt>doubleList</tt>.
Furthermore, due to the details of the underlying implementation, the
name you select has to be unused in both C++ and the target scripting
language (e.g., the name must not match any existing C++ typename,
class name, or declaration name).

<p>
Since most C++ compilers are nothing more than glorified preprocessors (sic) 
<em>and</em> C++ purists really hate macros, SWIG internally handles
templates by converting them into macros and performing expansions
using the preprocessor (well, actually it's somewhat more complicated than this, but
the preprocessor is used for part of it).  Specifically, the <tt>%template(intList)
List&lt;int&gt;</tt> declaration results in a macro expansion that
generates code roughly like this (which is then parsed to create the
interface):

<blockquote>
<pre>
// Example of how templates are internally expanded by SWIG
%{
// Define a nice name for the instantiation
typedef List&lt;int&gt; intList;
%}
// Provide a simple class definition with types filled in
class intList {
private:
    int *data;
    int nitems;
    int maxitems;
public:
    intList(int max) {
      data = new int [max];
      nitems = 0;
      maxitems = max;
    }
    ~intList() {
      delete [] data;
    };
    void append(int obj) {
      if (nitems &lt; maxitems) {
        data[nitems++] = obj;
      }
    }
    int length() {
      return nitems;
    }
    int get(int n) {
      return data[n];
    }
};
</pre>
</blockquote>

SWIG can also generate wrappers for function templates using a similar technique.
For example:

<blockquote>
<pre>
// Function template
template<class T> T max(T a, T b) { return a > b ? a : b; }

// Make some different versions of this function
%template(maxint) max&lt;int&gt;;
%template(maxdouble) max&lt;double&gt;;
</pre>
</blockquote>

In this case, <tt>maxint</tt> and <tt>maxdouble</tt> become unique names for specific 
instantiations of the function.

<p>
When a template is instantiated using <tt>%template</tt>, information about that class is
saved by SWIG and used elsewhere in the program.  For example, if you wrote code like this,

<blockquote>
<pre>
...
%template(intList) List&lt;int&gt;;
...
class UltraList : public List&lt;int&gt; {
   ...
};
</pre>
</blockquote>

then SWIG knows that <tt>List&lt;int&gt;</tt> was already wrapped as a class called 
<tt>intList</tt> and arranges to handle the inheritance correctly.    If, on the other hand,
nothing is known about <tt>List&lt;int&gt;</tt>, you will get a warning message similar to this:

<blockquote>
<pre>
example.h:42. Nothing known about class 'List&lt;int &gt;' (ignored). 
example.h:42. Maybe you forgot to instantiate 'List&lt;int &gt;' using %template. 
</pre>
</blockquote>

<p>
If a template class inherits from another template class, you need to
make sure that base classes are instantiated before derived classes.
For example:

<blockquote>
<pre>
template&lt;class T&gt; class Foo {
...
};

template&lt;class T&gt; class Bar : public Foo&lt;T&gt; {
...
};

// Instantiate base classes first 
%template(intFoo) Foo&lt;int&gt;;
%template(doubleFoo) Foo&lt;double&gt;;

// Now instantiate derived classes
%template(intBar) Bar&lt;int&gt;;
%template(doubleBar) Bar&lt;double&gt;;
</pre>
</blockquote>

The order is important since SWIG uses the instantiation names to
properly set up the inheritance hierarchy in the resulting wrapper
code (and base classes need to be wrapped before derived classes).
Don't worry--if you get the order wrong, SWIG will generate an warning message.

<p>
If you have to instantiate a lot of different classes for many different types,
you might consider writing a SWIG macro.  For example:

<blockquote>
<pre>
%define TEMPLATE_WRAP(T,prefix) 
%template(prefix ## Foo) Foo&lt;T&gt;;
%template(prefix ## Bar) Bar&lt;T&gt;;
...
%enddef

TEMPLATE_WRAP(int, int)
TEMPLATE_WRAP(double, double)
TEMPLATE_WRAP(char *, String)
...
</pre>
</blockquote>

<p>
If your goal is to make someone's head explode more than usual, SWIG
directives such as <tt>%rename</tt> and <tt>%addmethods</tt> can be
included directly in template definitions.  Not only that, since SWIG
has the advantage of using the preprocessor for template expansion,
standard C preprocessor operators such as <tt>#</tt> and <tt>##</tt>
can be applied to template parameters (an obvious oversight of the C++
standard that SWIG now corrects). For example:

<p>
<blockquote><pre>// File : list.h
template&lt;class T&gt; class List {
   ...
public:
    %rename(__getitem__) get(int);
    List(int max);
    ~List();
    ...
    T get(int index);
    %addmethods {
        char *__str__() {
            /* Make a string representation */
            ...
        }
        /* Return actual type of template instantiation as a string */
        char *ttype() {
            return #T;
        }
    }
};
</pre></blockquote>

In this example, the extra SWIG directives are propagated to <em>every</em> template 
instantiation.  

<p>
In addition, the <tt>%addmethods</tt> directive can be used to add
additional methods to a specific instantiation. For example:

<blockquote>
<pre>
%template(intList) List&lt;int&gt;;

%addmethods intList {
    void blah() {
          printf("Hey, I'm an intList!\n");
    }
};
</pre>
</blockquote>

Needless to say, SWIG's template support provides plenty of
opportunities to break the universe.  That said, an important final
point is that <b>SWIG performs no extensive error checking of
templates!</b> Specifically, SWIG does not perform type checking nor
does it check to see if the actual contents of the template
declaration make any sense.  Since the C++ compiler will hopefully
check this when it compiles the resulting wrapper file, there is no
practical reason for SWIG to duplicate this functionality (besides,
none of the SWIG developers are masochistic enough to want to
implement this right now).

<p>
Finally, there are a few limitations in SWIG's current support for templates:

<ul>
<li>Template specialization or partial specialization is not supported.  For example:

<blockquote>
<pre>
class List&lt;int&gt; {
  ...
};
</pre>
</blockquote>

<p>
<li>Class templates may not be defined as the argument of another template.   If you are
doing this on purpose, we're all really impressed, but please stop.

<p>
<li>Member templates aren't supported.  

<p>
<li>Template support in SWIG is still relatively immature.  Although
the current implementation is probably enough to handle simple stuff,
wrapping something like the STL would probably be rough going.  If you
succeed at this, we'd definitely like to know about it!  If you tried
and failed, we would also like to get feedback so that we can try to
address the problems you encountered.

</ul>


<h2>Pointers to Members</h2>

Starting with SWIG1.3.7, there is limited parsing support for pointers to C++ class members.
For example:

<blockquote>
<pre>
double do_op(Object *o, double (Object::*callback)(double,double));
extern double (Object::*fooptr)(double,double);
%constant double (Object::*FOO)(double,double) = &Object::foo;
</pre>
</blockquote>

Although these kinds of pointers can be parsed and represented by the
SWIG type system, few language modules know how to handle them due to
implementation differences from standard C pointers.  Readers are
<em>strongly</em> advised to consult an advanced text such as the "The
Annotated C++ Manual" for specific details.

<p>
When pointers to members are supported, the pointer value might appear as a special
string like this:

<blockquote>
<pre>
&gt;&gt;&gt; print example.FOO
_ff0d54a800000000_m_Object__f_double_double__double
&gt;&gt;&gt;
</pre>
</blockquote>

In this case, the hexadecimal digits represent the entire value of the
pointer which is usually the contents of a small C++ structure on most
machines.

<p>
SWIG's type-checking mechanism is also more limited when working with
member pointers.  Normally SWIG tries to keep track of inheritance
when checking types.  However, no such support is currently provided
for member pointers.

<h2>Partial class definitions</h2>

Since SWIG is still limited in its support of C++, it may be necessary
to use partial class information in an interface file.  However, since
SWIG does not need the entire class specification to work, conditional
compilation can be used to comment out problematic parts.  For example, if you had a nested
class definition, you might do this:

<blockquote>
<pre>
class Foo {
public:
#ifndef SWIG
   class Bar {
   public:
     ...
   };
#endif
   Foo();
  ~Foo();
   ...
};
</pre>
</blockquote>

<p>
Also, as a rule of thumb, SWIG should not be used on raw C++ source
files. 

<h2>A brief rant about const-correctness</h2>

A common issue when working with C++ programs is dealing with all
possible ways in which the <tt>const</tt> qualifier (or lack thereof)
will break your program, all programs linked against your program, and
all programs linked against those programs.  In fact, many C++ books
actively encourage using <tt>const</tt> whenever possible (perhaps in
an effort to maximize correctness through annoyance or by observing 
that an uncompilable program always runs correctly).

<p>
Although SWIG knows how to correctly deal with <tt>const</tt> in its
internal type system and it knows how to generate wrappers that are
free of const-related warnings, SWIG does not make any attempt to preserve 
const-correctness in the target language.  Thus, it is possible to
pass <tt>const</tt> qualified objects to non-const methods and functions.
For example, consider the following code in C++:

<blockquote>
<pre>
const Object * foo();
void bar(Object *);

...
// C++ code
void blah() {
   bar(foo());         // Error: bar discards const
};
</pre>
</blockquote>

Now, consider the behavior when wrapped into a Python module:

<blockquote>
<pre>
>>> bar(foo())         # Okay
>>> 
</pre>
</blockquote>

Although this is clearly a violation of the C++ type-system, fixing
the problem doesn't seem to be worth the added implementation
complexity that would be required to support it in the SWIG run-time type
system.  There are no plans to change this in future releases
(although we'll never rule anything out entirely).

<p>
The bottom line is that this particular issue does not appear to be a problem
for most SWIG projects.    Of course, you might want to consider
using another tool if maintaining constness is the most important part
of your project.

<h2>Where to go for more information</h2>

<p><hr>

<address>SWIG 1.3 - Last Modified : December 30, 2001</address>
</body>
</html>




