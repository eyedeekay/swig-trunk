Version 1.3.16 (In progress)
==================================
09/20/2002: ttn
	    [Methodology] Reworked "make clean" and "make install"
			  to be more table driven.
	    [Docs] Explain how to extend "make install" w/ extra-install.list.

09/15/2002: beazley
            Deprecation of the "ignore" typemap.   The "ignore" typemap has
            been deprecated in favor of a generalization of the "in" typemap.
            To ignore an argument, use something like this instead:

                %typemap(in,numinputs=0) int *output (int temp) {
                     $1 = &temp;
                }

            This change fixes a number of subtle bugs related to the interaction
            of the "in" and "ignore" typemaps (which were supposed to be
            mutually exclusive).

            The use of the numinputs argument is reserved for future expansion.
            Currently, values >1 will generate an error.  However, future
            releases of SWIG may utilize that to support multi-input typemaps.

            %typemap(ignore) still works, but generates a warning message and is
            translated to %typemap(in,numinputs=0).

            *** POTENTIAL INCOMPATIBILITY ***
            *** NEW FEATURE ***

09/15/2002: beazley
            Fixed segmentation fault for unnamed structures.  For example:

               typedef struct {
               } *blah;


            Reported by Roger Gibson.
            Note: we might be able to generate wrappers in special cases.

09/13/2002: beazley
            Minor modification to generated wrapper functions.  Pointer arguments are now
            always set to an initial value of 0.   Simplifies typemap writing and cleanup
            code (since you can rely on zero-value initialization).   This also greatly
            reduces the need to ever write an "arginit" typemap.

09/12/2002: beazley
            Minor enhancement to smart-pointer support.  If operator->()
            is part of an ignored base class like this,

                 %ignore Bar;

                 class Foo {
                 public:
                     int blah();
                 };

                 class Bar {         /* Ignored */
                 public:
                     ...
                     Foo *operator->();
                     ...
                 };

                 class Spam : public Bar { };

            then methods from Foo are still available.  For example,

                 >>> s = Spam()
                 >>> s.blah()
                 0
                 >>>

             The only catch is that the operator->() itself is not available
             (since it wasn't wrapped).   Therefore, there won't be any
             __deref__() operation unless it is explicitly added to Spam
             (either using %extend or just placing operator->() in the
             definition of Spam).

09/11/2002: ttn
	    [Methodology] Reworked "make check" to be more table driven.
	    [Docs] Docuemented methodology in Manual/Extending.html.

09/11/2002: ttn
	    [Docs] Prefixed Manual/*.html with "<!DOCTYPE html ...>" to
	    pander dotingly to (over-)sensitive editors.

09/10/2002: ttn
	    [Guile] Converted Examples/guile/simple "make check"
	    behavior to actually check execution results.  Reduced
	    iteration counts so that the test doesn't take too long.

09/10/2002: beazley
            SWIG-1.3.15 released.

