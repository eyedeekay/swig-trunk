Version 1.3.15 (In progress)
================================
09/09/2002: beazley
            Fixed nasty runtime type checking bug with subtypes and inheritance
            and templates. 

09/09/2002: cheetah (William Fulton)
            [Java] Java exception classes for a method's throws clause can be generated by 
            specifying them in a comma separated list in the throws attribute in any one
            of the following typemaps: in, out, check, freearg, argout and throws. A classic
            example would be to convert C++ exceptions into a standard Java exception:

                %typemap("throw", throws="java.io.IOException") file_exception {
                    jclass excep = jenv->FindClass("java/io/IOException");
                    if (excep)
                        jenv->ThrowNew(excep, _e.what());
                    return $null; // or use SWIG_fail
                }

                class file_exception {...};
                void open(const char *filename) throw(file_exception);

            The Java method will then be declared with a throws clause:

                public static void open(String filename) throws java.io.IOException {...}

09/08/2002: mkoeppe
	  * [Guile] Improved the documentation system.  The arglist no
	    longer gets cluttered with type specification, making it
	    more readable.  (Also the ILISP function C-u M-x
	    `arglist-lisp' RET works better this way.)  The types of
	    arguments are explained in an extra sentence after the
	    arglist. 
	    
	    There are now two documentation-related typemap arguments:

	        %typemap(in, doc="$NAME is a vector of integers", 
			 arglist="$name")  int *VECTOR { ... }
			 
            The "arglist" texts of all arguments of a function make up
	    its arglist in the documentation.  The "doc" texts of all
	    arguments are collected to make a sentence that describes
	    the types of the arguments.  Reasonable defaults are
	    provided. 

	    As usual, $name is substituted by the name of the
	    argument. The new typemap variable $NAME is like $name,
	    but marked-up as a variable.  This means that it is
	    upper-cased; in TeXinfo mode ("-procdocformat texinfo") it
	    comes out as @var{name}. 
	    
	    The directives %values_as_list, %values_as_vector,
	    %multiple_values now also have an effect on the
	    documentation. (This is achieved via the new pragmas
	    return_nothing_doc, return_one_doc, return_multi_doc.)

	    Documentation has also improved for variables that are
	    wrapped as procedures-with-setters (command-line switch
	    "-emit-setters").

          * [Guile] Emit constants as _immutable_ variables.  (This
            was broken recently.)

09/07/2002: mkoeppe
	    [Guile] Updated the typemaps in list-vector.i.

09/07/2002: mkoeppe
	    Short-circuit the typechecks for overloaded functions.
	    (The changes in code generation are visible in the new
	    testcase "overload_complicated".)

09/06/2002: cheetah (William Fulton)
            [Java] Solution for [ 596413 ]
            New typemap so that the Java proxy classes and type wrapper classes
            wrapper constructor modifier can be tailored by users. The default value is 
            protected. Normally SWIG generates a constructor like this which can only 
            be accessed within one package:

              protected Bar(long cPtr, boolean cMemoryOwn) {
              ...
              }
            
            If you are using SWIG across multiple packages or want to use this constructor
            anyway, it can now be accessed outside the package. To modify use for example:

              %typemap(javaptrconstructormodifiers) SWIGTYPE "public"

            to change to public for all proxy classes and similarly for all type wrapper classes:
            
              %typemap(javaptrconstructormodifiers) SWIGTYPE, SWIGTYPE *, SWIGTYPE &, SWIGTYPE [] "public"

09/06/2002: cheetah (William Fulton)
            [Java] Added "throw" typemaps for the Java module. C++ exceptions get converted into
            java.lang.RuntimeException Java exceptions. 
            
            Warning: This may change from java.lang.Runtime exception in the future.

09/05/2002: cheetah (William Fulton)
            [Java] Fix for variables declared as references.

09/05/2002: beazley
            Fixed [ 605162 ] Typemap local variables. Reported by Lyle Johnson.

09/05/2002: ljohnson (Lyle Johnson)
            [Ruby] More updates to the Ruby module documentation, including
	    a new typemap example that demonstrates how to collect key-value
	    pairs from an argument list into a Hash.

09/05/2002: beazley
            Fixed bug with template expansion and constructors.

                template<class T> class Foo {
                public:
                    Foo<T>() { }
                };

            The extra <T> in the constructor was carried through in the
            name--causing runtime problems in generated modules.
            Reported by Jordi Arnabat Benedicto.
 
09/05/2002: mkoeppe
	    [Guile] Support overloading.

09/04/2002: ljohnson (Lyle Johnson)
            [Ruby] Updated typemaps for long long and unsigned long long types
	    to use Ruby 1.7 support for these types when available.

09/04/2002: ljohnson (Lyle Johnson)
            [Ruby] Added output typemaps for const reference to primitive
	    types.

09/04/2002: mkoeppe
	    [Guile] Fix pass-by-value typemaps.  Reported by Arno
	    Peters via Debian bugtracking (#156902), patch by Torsten
	    Landschoff <torsten@debian.org>.

09/03/2002: samjam (Sam Liddicott)
	    Better reference support.
	    Functions that want a void** can take a NULL by reference and
	    the void* will be made for you and then passed-by-reference

	    Also all integer-class native types can be passed by reference
	    where an int* or int& etc is needed

09/03/2002: beazley
            Changed the evaluation order of preprocessor macro arguments.
            Arguments are now expanded by the preprocessor *before* they
            are passed to macro expansion.  This fixes a subtle expansion
            bug reported by Anthony Heading.

09/03/2002: beazley
            Fixed the file include order (again, apparently). See 2/27/99.

09/02/2002: beazley
            [Perl] Better exception handling support.  Since Perl error handling
            relies on setjmp/longjmp, wrapper functions have been modified slightly
            to provide an extra block scope:

                XS(foo) {
                   char _swigmsg[SWIG_MAX_ERRMSG] = "";
                   const char *_swigerr = _swigmsg;
                   {
                      /* Normal wrapper function here */
                      ...
                      SWIG_croak("An error occurred\n");
                      ...
                      XSRETURN(argvi);      /* Successful return */
                      fail:
                        /* cleanup code */
                   }
                   croak(_swig_err);
                }

            The macro SWIG_croak(x) sets the value of _swigerr to x and
            executes a "goto fail".  The whole wrapper function is enclosed
            block scope to provide proper cleanup of C++ objects.  Since
            croak executes a longjmp(), there is no way to properly reclaim
            resources if this executes in the same scope as the wrapper
            function.

            The _swigmsg[] variable is normally unused, but can be used
            to store small error messages using sprintf or snprintf. It
            has a capacity of at least 256 bytes (SWIG_MAX_ERRMSG).
            
09/02/2002: beazley
            [Tcl] Added better support for exceptions.  Instead of returning TCL_ERROR,
            use the macro SWIG_fail to return with an error.  This ensures that
            arguments are properly cleaned up.  Exception specifiers are now
            handled by default.

09/02/2002: ljohnson (Lyle Johnson)
            [Ruby] The type-checking system for the Ruby module has had a flaw
	    in that some types which should be considered equivalent
	    weren't. This bug was best demonstrated by the inherit_missing.i
	    test suite case, which defines a base class "Foo" that is
	    subclassed by "Bar". The "Foo" class isn't actually wrapped (i.e.
	    it's not directly accessible from Ruby) but we'd still like to be
	    able to pass "Bar" instances to functions expecting Foos and have
	    that work; it wasn't. The revised implementation (similar to that
	    used for some other language modules) adds a new instance variable
	    (__swigtype__) to each object that indicates its SWIG type;
	    that is, each "Bar" instance will now have a string instance
	    variable called "__swigtype__" whose value is "_p_Bar".

            Unless developers were taking advantage of this low-level
	    implementation detail, they shouldn't notice any compatibility
	    problems; nevertheless, I'm marking it as a "potential
	    incompatibility".

            *** POTENTIAL INCOMPATIBILITY ***

09/01/2002: ljohnson (Lyle Johnson)
            [Ruby] Fixed SF Bug #603199.

08/08/2002: cheetah (William Fulton)
            [Java] Added OUTPUT, INPUT and INOUT typemaps in typemaps.i for C++ 
            references.

08/27/2002: mkoeppe
	    [Guile] Fixed error in "lib_std_vector" testcase and
	    compiler warning in "lib_cdata" testcase.

08/27/2002: ljohnson (Lyle Johnson)
            [Ruby] Added the "%mixin" directive, which allows the user to
	    specify a comma-separated list of module names to mix-in to a
	    class. So, for example, if you'd like to specify that Ruby's
	    Enumerable module should be mixed-in to your class Foo, you'd
	    write:
	    
	        %mixin Foo "Enumerable";
		
            or to specify that the modules Fee, Fie and Fo should be mixed
	    in to Foo:
	    
	        %mixin Foo "Fee,Fie,Fo";
		
	    *** NEW FEATURE ***

08/27/2002: ljohnson (Lyle Johnson)
            [Ruby] Modified the %alias directive so that multiple aliases
	    can be specified for an instance method by using a comma-separated
	    list of aliases.

08/27/2002: ljohnson (Lyle Johnson)
            [Ruby] Added "throw" typemaps for the Ruby module.

08/26/2002: beazley
            Two new command line options for printing dependencies.
            'swig -M' lists all file dependencies.  'swig -MM' lists
            dependencies, but excludes files in the SWIG library. 
            Example:

               % swig -M -python example.i
               example_wrap.cxx: \
                /u0/beazley/Projects/lib/swig1.3/swig.swg \
                /u0/beazley/Projects/lib/swig1.3/python/python.swg \
                example.i \
                example.h 

               % swig -MM -python example.i
               example_wrap.cxx: \
                example.i \
                example.h 

            *** NEW FEATURE ***

08/26/2002: beazley
            Fixed [ 597599 ] union in class: incorrect scope.
            Reported by Art Yerkes.

08/26/2002: beazley
            Fixed [ 600132 ] Default argument with namespace. 
            Reported by Shibukawa Yoshiki.
 
08/24/2002: beazley
            Automatic C++ exception handling enabled for all language modules.    This is
            pretty simple.  If you have a class like this:

                class Foo {
                };
                class Bar {
                public:
                    void blah() throw(Foo);
                }

            then the generated wrapper code looks like this:

                  wrap_Bar_blah() {
                       ...
                       try {
                           arg1->blah();
                       } 
                       catch (Foo &_e) {
                           /* "throw" typemap code inserted. $1 = _e */
                       }
                       catch (...) {
                          throw;
                       }
                  }
            The "throw" typemap can be used to raise an error in the target 
            language.  It can do anything.  Here is a very simple example:

                 %typemap("throw") Foo {
                     PyErr_SetString(PyExc_RuntimeError, "Foo exception");
                     return NULL;
                 }

            To make this work in each language module, simply define a few default
            "throw" typemaps for SWIGTYPE, SWIGTYPE *, int, const char *, and a
            few common exception types.   That's all there is to it.

            Automatic exception handling can be disabled using -noexcept or
            setting the NoExcept global variable to 1.
            *** NEW FEATURE ***

08/23/2002: beazley
            [ Python ]
            Automatic translation of C++ exception specifications into error handling code.
            For example:
 
                class Foo {
                };
                class Bar {
                public:
                    void blah() throw(Foo);
                }

            In this case, Foo is wrapped as a classic-style class (compatible
            with exception handling).  Furthermore, you can write Python code
            like this:

                b = Bar()
                try:
                    b.blah();
                except Foo,e:     # Note use of exception class here!
                    # Handle Foo error
                    ...

            The object "e" in the exception handler is just a wrapped Foo
            object.  Access it like a normal object.

            If an exception is not wrapped as a class, a RuntimeError
            exception is raised.  The argument to this exception is
            the exception object.  For example:
 
                class Bar {
                public:
                    void blah() throw(int);
                }

                b = Bar()
                try:
                   b.blah();
                except RuntimeError,e:
                   print e.args[0]       # Integer exception value

            Comments:

                -  If a class is used as an exception, it *must* be wrapped
                   as a Python classic-style class (new classes don't work).

                -  Automatic exception handling is compatible with %exception.

                -  Use -noexcept to turn off this feature.

                -  The newly introduced "throw" typemap is used to raise
                   Python errors (naturally).

            *** EXPERIMENTAL NEW FEATURE ***

08/23/2002: beazley
            Information from throw() specifiers is now stored in the parse
            tree.  For example:

                class Foo {
                public:
                     int blah() throw(spam,bar);
                }

            The stored information is fully corrected for namespaces and works
            with templates.  Uses will follow.
            
08/22/2002: beazley
            Exception handling code is no longer applied to member access
            function.  For example, in this code

                %exception {
                   try {
                      $action
                   } catch(whatever) {
                      ...
                   }
                }

                class Foo {
                public:
                    int x;
                    ...
                }

            The exception handling code is not applied to accessor functions
            for Foo::x.   This should reduce the amount of extra code
            generated.

            Caveat:  Exception handling code *is* used when attributes are
            accessed through a smart-pointer or a synthesized attributed
            added with %extend is used.

08/22/2002: beazley
            Made more patches to hopefully eliminate problems when compiling SWIG 
            as a 64-bit executable.

08/22/2002: beazley
            Fixed a bug with const reference members, variables, and static members.
            For example:

                  class Foo {
                  public:
                       static const int &ref;
                  };

            SWIG was trying to generate "set" functions which wouldn't compile. 

08/21/2002: beazley
            Made the warning message for "Class X might abstract" off by default.
            Enable with -Wall.

08/21/2002: beazley
            Refined handling of const and non-const overloaded methods.  If
            a class defines a method like this:

                class Foo {
                public:
                    int bar(int);
                    int bar(int) const;
                }

            Then the non-const method is *always* selected in overloading and
            the const method silently discarded.  If running with -Wall, a warning
            message will be generated.

08/19/2002: beazley
            Better support for using declarations and inheritance.   Consider this:

                class Foo {
                public:
                      int blah(int x);
                };

                class Bar {
                public:
                      double blah(double x);
                };

                class FooBar : public Foo, public Bar {
                public:
                      char *blah(char *x);
                      using Foo::blah;
                      using Bar::blah;
                };

            Now SWIG wraps FooBar::blah as an overloaded method that uses all
            accessible versions of blah().  See section 15.2.2 in Stroustrup, 3rd Ed.

            SWIG also supports access change through using declarations.  For example:

                class Foo {
                protected:
                     int x;
                     int blah(int x);
                };

                class Bar : public Foo {
                public:
                     using Foo::x;
                     using Foo::blah;
                };


            Caveat:   SWIG does not actually check to see if declarations imported
            via 'using' are in the inheritance hierarchy.  If this occurs, the
            wrapper code won't compile anyways---not sure it's worth worrying about.
          
08/18/2002: beazley
            Modified overloading dispatch to not include nodes with an "error" attribute.
            A language module can set this if a node couldn't be wrapped and you don't want
            it included in the dispatch function.

08/18/2002: beazley
            Enhancement to overloaded function dispatch.   The dispatcher is now aware of
            inheritance relationships.   For example:

                   class Foo { };
                   class Bar : public Foo { };
                    
                   void spam(Foo *f);
                   void spam(Bar *b);

            In this case, the dispatcher re-orders the functions so that spam(Bar *b) is
            checked first---it is more specific than spam(Foo *f).

08/17/2002: beazley
            Added -Werror command line option.   If supplied, warning messages are treated
            as errors and SWIG will return a non-zero exit code.

08/17/2002: beazley
            Fixed [ 596135 ] Typedef of reference can't compile.  For example:

                 typedef int &IntRef;
                 void foo(IntRef i);

            SWIG-1.3.14 generated code that wouldn't compile.
