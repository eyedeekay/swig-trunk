%{
/* -----------------------------------------------------------------------------
 * parser.yxx
 *
 *     YACC parser for SWIG1.1.   This grammar is a broken subset of C/C++.
 *     This file is in the process of being deprecated.
 *
 * Author(s) : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (C) 1998-2001.  The University of Chicago
 * Copyright (C) 1995-1998.  The University of Utah and The Regents of the
 *                           University of California.
 *
 * See the file LICENSE for information on usage and redistribution.
 * ----------------------------------------------------------------------------- */

#define yylex yylex

static char cvsroot[] = "$Header$";

#include "internal.h"
extern "C" {
#include "preprocessor.h"
}

/* We do this for portability */
#undef alloca
#define alloca malloc

/* -----------------------------------------------------------------------------
 *                               Externals
 * ----------------------------------------------------------------------------- */

extern "C" int yylex();
extern void  yyerror (const char *s);

/* scanner.cxx */

extern int  line_number;
extern int  start_line;
extern void skip_brace(void);
extern void skip_define(void);
extern void skip_decl(void);
extern int  skip_cond(int);
extern void skip_to_end(void);
extern void skip_template(void);
extern void scanner_check_typedef(void);
extern void scanner_ignore_typedef(void);
extern void scanner_clear_start(void);
extern void start_inline(char *, int);

/* cplus.cxx */

extern void cplus_open_class(char *name, char *rname, char *ctype);
extern void cplus_member_func(char *, char *, SwigType *, ParmList *, int);
extern void cplus_constructor(char *, char *, ParmList *);
extern void cplus_destructor(char *, char *);
extern void cplus_variable(char *, char *, SwigType *);
extern void cplus_static_func(char *, char *, SwigType *, ParmList *);
extern void cplus_declare_const(char *, char *, SwigType *, char *);
extern void cplus_class_close(char *);
extern void cplus_inherit(int, char **);
extern void cplus_cleanup(void);
extern void cplus_static_var(char *, char *, SwigType *);
extern void cplus_register_type(char *);
extern void cplus_register_scope(void *);
extern void cplus_inherit_scope(int, char **);
extern void cplus_add_pragma(char *, char *, char *);
extern void cplus_set_class(char *);
extern void cplus_unset_class();
extern void cplus_abort();

/* -----------------------------------------------------------------------------
 *                              Variables
 * ----------------------------------------------------------------------------- */

       char  *typemap_lang = 0;    /* Current language setting */
static int     module_init = 0;    /* Indicates whether the %module name was given */
static int     lang_init = 0;      /* Indicates if the language has been initialized */

       int            Error = 0;
static char           temp_name[128];
static SwigType      *temp_typeptr = 0, *temp_type = 0;
static char           yy_rename[256];
static int            Rename_true = 0;
static SwigType      *Active_type = 0;         // Used to support variable lists
static int            Active_extern = 0;       // Whether or not list is external
static int            Active_static = 0;
static SwigType      *Active_typedef = 0;     // Used for typedef lists
static Hash           *name_hash = 0;          // Hash table containing renamings
static Hash           *symbols = 0;
static int             cplus_mode;
static int             InClass = 0;

/* C++ modes */

#define  CPLUS_PUBLIC    1
#define  CPLUS_PRIVATE   2
#define  CPLUS_PROTECTED 3

/* Storage classes */

#define  STORAGE_EXTERN     1
#define  STORAGE_EXTERN_C   2
#define  STORAGE_STATIC     3

/* -----------------------------------------------------------------------------
 *                           Assist functions
 * ----------------------------------------------------------------------------- */

/* Create a C++ constant */
static void 
my_cplus_declare_const(char *name, char *iname, SwigType *type, char *value) {
  String *tval;
  if (value) {
    tval = NewStringf("%(escape)s",value);
    cplus_declare_const(name,iname,type,Char(tval));
    Delete(tval);
  } else {
    cplus_declare_const(name,iname,type,value);
  }
}

/* Create a new typemap parameter */
static TMParm *NewTMParm() {
  TMParm *tmp = (TMParm *) malloc(sizeof(TMParm));
  tmp->next = 0;
  return tmp;
}

/* --------------------------------------------------------------------------
 * swig_pragma()
 *
 * Handle swig pragma directives.  
 * -------------------------------------------------------------------------- */

void swig_pragma(char *lang, char *name, char *value) {
  if (strcmp(lang,"swig") == 0) {
    if (strcmp(name,"make_default") == 0) {
      GenerateDefault = 1;
    } else if (strcmp(name,"no_default") == 0) {
      GenerateDefault = 0;
    } else if (strcmp(name,"readonly") == 0) {
      Status = Status | STAT_READONLY;
    } else if (strcmp(name,"readwrite") == 0) {
      Status = Status & ~STAT_READONLY;
    }
  }
}


/* -----------------------------------------------------------------------------
 * emit_extern_func()
 * 
 * Emit an external function declaration.
 * ----------------------------------------------------------------------------- */

static void emit_extern_func(char *decl, SwigType *t, ParmList *L, int extern_type, DOHFile *f) {

  switch(extern_type) {
  case 0:
    Printf(f,"%s", SwigType_str(t,0));
    Printf(f,"%s(%s);\n", decl, ParmList_protostr(L));
    break;
  case STORAGE_EXTERN:
    Printf(f,"extern %s", SwigType_str(t,0));
    Printf(f,"%s(%s);\n", decl, ParmList_protostr(L));
    break;
  case STORAGE_EXTERN_C:
  /* A C++ --- > C Extern */
    Printf(f,"extern \"C\" %s", SwigType_str(t,0));
    Printf(f,"%s(%s);\n", decl, ParmList_protostr(L));
    break;
  case 3:
    Printf(f,"%s", SwigType_str(t,0));
    Printf(f,"%s(%s)\n", decl, ParmList_str(L));
    break;
  default:
    break;
  }
}

/* -----------------------------------------------------------------------------
 * init_language()
 * 
 * Initialize the target language.  Does nothing if the function
 * is called more than once.
 * ----------------------------------------------------------------------------- */

static void init_language() {
  if (!lang_init) {
    lang->initialize();
  }
  lang_init = 1;
}

/* -----------------------------------------------------------------------------
 * add_symbol()
 * 
 * Add a symbol to the symbol table 
 * ----------------------------------------------------------------------------- */

int add_symbol(char *name) {
   if (!symbols) symbols = NewHash();
   if (Getattr(symbols,name)) return -1;
   Setattr(symbols,name,name);
   return 0;
}

/* Perform type-promotion for binary operators */

static int promote(int t1, int t2) {
  if ((t1 == T_ERROR) || (t2 == T_ERROR)) return T_ERROR;
  if ((t1 == T_DOUBLE) || (t2 == T_DOUBLE)) return T_DOUBLE;
  if ((t1 == T_FLOAT) || (t2 == T_FLOAT)) return T_FLOAT;
  if ((t1 == T_ULONG) || (t2 == T_ULONG)) return T_ULONG;
  if ((t1 == T_LONG) || (t2 == T_LONG)) return T_LONG;
  if ((t1 == T_UINT) || (t2 == T_UINT)) return T_UINT;
  if ((t1 == T_INT) || (t2 == T_INT)) return T_INT;
  if ((t1 == T_USHORT) || (t2 == T_USHORT)) return T_SHORT;
  if ((t1 == T_SHORT) || (t2 == T_SHORT)) return T_SHORT;
  if ((t1 == T_UCHAR) || (t2 == T_UCHAR)) return T_UCHAR;
  if (t1 != t2) {
    Printf(stderr,"%s:%d. Type mismatch in constant expression\n",
	    input_file, line_number);
    FatalError();
  }
  return t1;
}

/* Generate the scripting name of an object using the %name directive */

static char *make_name(char *name) {
  /* Check to see if the name is in the hash */
  if (!name_hash) name_hash = NewHash();
  char *nn = GetChar(name_hash,name);

  if (nn) return nn;   
  if (Rename_true) {
    Rename_true = 0;
    return yy_rename;
  } else {
    /* Now check to see if the name contains a $ */
    if (strchr(name,'$')) {
      static DOHString *temp = 0;
      if (!temp) temp= NewString("");
      Clear(temp);
      Append(temp,name);
      Replace(temp,"$","_S_",DOH_REPLACE_ANY);
      return Char(temp);
    } else {
      return name;
    }
  }
}

/* ----------------------------------------------------------------------
 * create_function()
 *
 * Creates a function.
 * ---------------------------------------------------------------------- */

static void create_function(int ext, char *name, SwigType *t, ParmList *l) {
  if (Active_static) return;     // Static declaration. Ignore

  init_language();
  if (WrapExtern) return;        // External wrapper file. Ignore

  char *iname = make_name(name);

  // Check if symbol already exists

  if (add_symbol(iname)) {
    Printf(stderr,"%s:%d. Function %s multiply defined (2nd definition ignored).\n",
	    input_file, line_number, iname);
  } else {
    // If extern, make an extern declaration in the SWIG wrapper file
    if (ext)
      emit_extern_func(name, t, l, ext, f_header);
    else if (ForceExtern) {
      emit_extern_func(name, t, l, 1, f_header);
    }

    // If this function has been declared inline, produce a function
    lang->create_function(name, iname, t, l);
  }
  scanner_clear_start();
}

/* -------------------------------------------------------------------
 * create_variable()
 *
 * Create a link to a global variable.
 * ------------------------------------------------------------------- */

static void create_variable(int ext, char *name, SwigType *t) {

  int oldstatus = Status;

  if (WrapExtern) return;        // External wrapper file. Ignore
  if (Active_static) return;  // If static ignore

  if (SwigType_isconst(t)) {
    Status |= STAT_READONLY;
  }

  init_language();

  char *iname = make_name(name);
  if (add_symbol(iname)) {
    Printf(stderr,"%s:%d. Variable %s multiply defined (2nd definition ignored).\n",
	    input_file, line_number, iname);
  } else {

    // If externed, output an external declaration

    if (ext || ForceExtern) {
	Printf(f_header,"extern %s;\n", SwigType_str(t,name));
    }

    // Now dump it out
    lang->link_variable(name, iname, t);
  }
  scanner_clear_start();
  Status = oldstatus;
}

/* ------------------------------------------------------------------
 * create_constant()
 *
 * Creates a new constant.
 * ------------------------------------------------------------------- */

static void create_constant(char *name, SwigType *type, char *value) {

  if (Active_static) return;
  if (WrapExtern) return;        // External wrapper file. Ignore
  init_language();

  if (Rename_true) {
    Printf(stderr,"%s:%d. %%name directive ignored with #define\n",
	    input_file, line_number);
    Rename_true = 0;
  }

  if (!value) value = Swig_copy_string(name);
  sprintf(temp_name,"const:%s", name);
  if (add_symbol(temp_name)) {
    Printf(stderr,"%s:%d. Constant %s multiply defined. (2nd definition ignored)\n",
	    input_file, line_number, name);
  } else {
    if (!WrapExtern) {    // Only wrap the constant if not in %extern mode
      String *tval = NewStringf("%(escape)s",value);
      lang->declare_const(name, name, type, Char(tval));
      Delete(tval);
    }
  }
  scanner_clear_start();
}

/* Structures for handling code fragments built for nested classes */

struct Nested {
  String   *code;        // Associated code fragment
  int      line;         // line number where it starts
  char     *name;        // Name associated with this nested class
  SwigType *type;        // Datatype associated with the name
  Nested   *next;        // Next code fragment in list
};

/* Some internal variables for saving nested class information */

static Nested      *nested_list = 0;

/* Add a function to the nested list */

static void add_nested(Nested *n) {
  Nested *n1;
  if (!nested_list) nested_list = n;
  else {
    n1 = nested_list;
    while (n1->next) n1 = n1->next;
    n1->next = n;
  }
}

/* Dump all of the nested class declarations to the inline processor
 * However.  We need to do a few name replacements and other munging
 * first.  This function must be called before closing a class! */

static void dump_nested(char *parent) {
  Nested *n,*n1;
  n = nested_list;
  int oldstatus = Status;

  Status = STAT_READONLY;
  while (n) {
    char temp[256];
    // Token replace the name of the parent class
    Replace(n->code, "$classname", parent, DOH_REPLACE_ANY);

    // Fix up the name of the datatype (for building typedefs and other stuff)
    sprintf(temp,"%s_%s", parent,n->name);

    Append(n->type,parent);
    Append(n->type,"_");
    Append(n->type,n->name);

    // Add the appropriate declaration to the C++ processor
    cplus_variable(n->name,(char *) 0, n->type);

    // Dump the code to the scanner

    Printf(f_header,"\n%s\n", Char(n->code));
    start_inline(Char(n->code),n->line);

    n1 = n->next;
    Delete(n->code);
    free(n);
    n = n1;
  }
  nested_list = 0;
  Status = oldstatus;
}

 static List *typelist(Parm *p) {
   List *l = NewList();
   while (p) {
     Append(l,Gettype(p));
     p = Getnext(p);
   }
   return l;
 }

%}

/* The type of each node in the parse tree
   must be one of the elements of the union
   given below.  This is used to derive the
   C++ declaration for "yylval" that appears
   in parser.tab.h. */


%union {
  char  *id;
  struct InitList {
    char **names;
    int    count;
  } ilist;
  struct Define {
    String *val;
    int     type;
  } dtype;
  struct {
    char *type;
    char *filename;
    int   line;
    int   flag;
  } loc;
  struct {
    char      *id;
    SwigType  *type;
    String    *defarg;
    ParmList  *tmargs;
  } decl;
  SwigType     *type;
  String       *str;
  Parm         *p;
  TMParm       *tmparm;
  ParmList     *pl;
  int           ivalue;
};

%token <id> ID
%token <str> HBLOCK
%token <id> POUND 
%token <id> STRING
%token <loc> INCLUDE IMPORT WEXTERN INSERT
%token <str> NUM_INT NUM_FLOAT CHARCONST NUM_UNSIGNED NUM_LONG NUM_ULONG
%token <ivalue> TYPEDEF
%token <type> TYPE_INT TYPE_UNSIGNED TYPE_SHORT TYPE_LONG TYPE_FLOAT TYPE_DOUBLE TYPE_CHAR TYPE_VOID TYPE_SIGNED TYPE_BOOL TYPE_TYPEDEF TYPE_RAW
%token LPAREN RPAREN COMMA SEMI EXTERN INIT LBRACE RBRACE PERIOD
%token CONST STRUCT UNION EQUAL SIZEOF MODULE LBRACKET RBRACKET
%token ILLEGAL CONSTANT
%token NAME RENAME ADDMETHODS PRAGMA
%token ENUM
%token CLASS PRIVATE PUBLIC PROTECTED COLON STATIC VIRTUAL FRIEND OPERATOR THROW TEMPLATE
%token NATIVE INLINE
%token TYPEMAP EXCEPT ECHO NEW APPLY CLEAR
%token LESSTHAN GREATERTHAN
%token TYPES

%left  OR
%left  XOR
%left  AND
%left  LSHIFT RSHIFT
%left  PLUS MINUS
%left  STAR SLASH
%left  UMINUS NOT LNOT
%left  DCOLON

%type <ivalue>   storage_class;
%type <pl>       parms typemap_args ptail;
%type <p>        parm parm_type;
%type <tmparm>   typemap_parm tm_list tm_tail;
%type <id>       cpptype base_specifier access_specifier tm_method;
%type <type>     type type_right opt_signed opt_unsigned;
%type <ivalue>   cpp_vend;
%type <ilist>    base_list inherit;
%type <dtype>    definetype def_args;
%type <dtype>    etype;
%type <dtype>    expr;
%type <id>       ename ;
%type <id>       template_decl;
%type <id>       type_qualifier;
%type <id>       idstring;
%type <id>       pragma_lang;
%type <str>      pragma_arg;
%type <loc>      includetype;
%type <type>     pointer;
%type <decl>     declarator direct_declarator parameter_declarator typemap_parameter_declarator nested_decl;
%type <type>     abstract_declarator direct_abstract_declarator;
%type <id>       typemap_type;

%%

/* ======================================================================
 *                          High-level Interface file
 *
 * An interface is just a sequence of declarations which may be SWIG directives
 * or normal C declarations.
 * ====================================================================== */

program        :  interface {
                   cplus_cleanup();    /* Dump all of the C++ classes */
    
		   if (lang_init) {    /* Clean up the language module if initialized */
		     lang->close();
		   }
               }
               ;

interface      : interface declaration {
		     scanner_clear_start();
                     Error = 0;
                }
               | empty
               ;

declaration    : swig_directive
               | c_declaration 
               | cpp_declaration
               | SEMI
               | error {
		 if (!Error) {
		   static int last_error_line = -1;
		   if (last_error_line != line_number) {
		     Printf(stderr,"%s:%d. Syntax error in input.\n", input_file, line_number);
		     FatalError();
		     last_error_line = line_number;
		     skip_decl();
		   }
		   Error = 1;
		 }
               }
               ;


/* ======================================================================
 *                           SWIG DIRECTIVES 
 * ====================================================================== */
  
swig_directive :  addmethods_directive
               | apply_directive
               | clear_directive
               | constant_directive
               | echo_directive
               | except_directive
               | include_directive
               | inline_directive
               | insert_directive
               | module_directive
               | name_directive
               | native_directive
               | new_directive
               | pragma_directive
               | rename_directive
               | typemap_directive
               | types_directive
               ;

/* ------------------------------------------------------------
   %addmethods classname { ... } 
   ------------------------------------------------------------ */

addmethods_directive : ADDMETHODS ID LBRACE {
	       cplus_mode = CPLUS_PUBLIC;
	       cplus_set_class($2);
	       scanner_clear_start();
	       AddMethods = 1;
	       InClass = 1;
	     } cpp_members RBRACE {
	       InClass = 0;
	       cplus_unset_class();
	       AddMethods = 0;
	     }
             ;

/* ------------------------------------------------------------
   %apply
   ------------------------------------------------------------ */

apply_directive : APPLY typemap_parm LBRACE tm_list RBRACE {
		 TMParm *p;
		 p = $4;
		 while(p) {
		   Swig_typemap_apply(Gettype($2->p),Getname($2->p),Gettype(p->p),Getname(p->p));
		   p = p->next;
		 }
		 free($4);
		 Delete($2->args);
		 free($2);
               };

/* ------------------------------------------------------------
   %clear
   ------------------------------------------------------------ */

clear_directive : CLEAR tm_list SEMI {
		 TMParm *p;
		 p = $2;
		 while (p) {
		  Printf(stderr,"%s:%d. Warning. %%clear directive is temporarily disabled in this release. Ignored.\n", input_file, line_number);
/*		   Swig_typemap_clear_apply(Gettype(p->p), Getname(p->p)); */
		   p = p->next;
		 }
               }
               ;

/* ------------------------------------------------------------
   %constant name = value;
   %constant type name = value;
   ------------------------------------------------------------ */

constant_directive :  CONSTANT ID EQUAL definetype SEMI {
		   if (($4.type != T_ERROR) && ($4.type != T_SYMBOL)) {
		     init_language();
		     temp_typeptr = NewSwigType($4.type);
		     create_constant($2, temp_typeptr, Char($4.val));
		     Delete(temp_typeptr);
		   }
	       }

               | CONSTANT type declarator def_args SEMI {
		 if (($4.type != T_ERROR) && ($4.type != T_SYMBOL)) {
		   init_language();
		   SwigType_push($2,$3.type);
		   create_constant($3.id,$2,Char($4.val));
		 } 
               }

/* This is bogus. simplify later */

               | CONSTANT type LPAREN declarator RPAREN LPAREN parms RPAREN def_args SEMI {
		 init_language();
		 List *l = typelist($7);
		 SwigType_add_function($2,l);
		 SwigType_push($2,$4.type);
		 create_constant($4.id,$2,Char($9.val));
               }
               | CONSTANT type abstract_declarator LPAREN declarator RPAREN LPAREN parms RPAREN def_args SEMI {
		 init_language();
		 SwigType_push($2,$3);
		 List *l = typelist($8);
		 SwigType_add_function($2,l);
		 SwigType_push($2,$5.type);
		 create_constant($5.id,$2,Char($10.val));
               }
               ;

/* ------------------------------------------------------------
   %echo "text"
   %echo %{ ... %}
   ------------------------------------------------------------ */

echo_directive : ECHO HBLOCK {
		 char temp[64];
		 Replace($2,"$file",input_file, DOH_REPLACE_ANY);
		 sprintf(temp,"%d", line_number);
		 Replace($2,"$line",temp,DOH_REPLACE_ANY);
		 Printf(stderr,"%s\n", $2);
		 Delete($2);
	       }
               | ECHO STRING {
		 char temp[64];
		 String *s = NewString($2);
		 Replace(s,"$file",input_file, DOH_REPLACE_ANY);
		 sprintf(temp,"%d", line_number);
		 Replace(s,"$line",temp,DOH_REPLACE_ANY);
		 Printf(stderr,"%s\n", s);
		 Delete(s);
               }
               ;

/* ------------------------------------------------------------
   %except(lang) { ... }
   %except { ... }
   %except(lang);   
   %except;
   ------------------------------------------------------------ */

except_directive : EXCEPT LPAREN ID RPAREN LBRACE {
                    skip_brace();
		    if (strcmp($3,typemap_lang) == 0) {
		      Swig_except_register(CCode);
		    }
		    free($3);
	       }

               | EXCEPT LBRACE {
                    skip_brace();
		    Swig_except_register(CCode);
               }

               | EXCEPT LPAREN ID RPAREN SEMI {
		 Swig_except_clear();
               }

               | EXCEPT SEMI {
		 Swig_except_clear();
	       }
               ;

/* ------------------------------------------------------------
   %includefile "filename" { declarations } 
   %externfile  "filename" { declarations }
   %importfile  "filename" { declarations }
   ------------------------------------------------------------ */

include_directive: includetype STRING LBRACE {
		     $1.flag = WrapExtern;
                     $1.filename = Swig_copy_string(input_file);
		     $1.line = line_number;
		     input_file = Swig_copy_string($2);
		     line_number = 0;
		     if ((strcmp($1.type,"extern") == 0) || (strcmp($1.type,"import") == 0)) {
		       WrapExtern = 1;
		       if (strcmp($1.type,"import") == 0) {
			 lang->import($2);
		       }
		     }
               } interface RBRACE {
		     input_file = $1.filename;
		     line_number = $1.line;
		     WrapExtern = $1.flag;
               }
               ;

includetype    : INCLUDE { $$.type = (char *) "include"; }
               | WEXTERN { $$.type = (char *) "extern"; }
               | IMPORT  { $$.type = (char *) "import"; }
               ;

/* ------------------------------------------------------------
   %inline %{ ... %}
   ------------------------------------------------------------ */

inline_directive : INLINE HBLOCK {
		 if (!WrapExtern) {
		   File *f;
		   init_language();
		   f = Swig_filebyname("header");
		   if (f) {
		     Printf(f, "%s\n", $2);
		     /* Need to run through the preprocessor */
		     DOH *cpps;
		     Setline($2,start_line);
		     Setfile($2,input_file);
		     Seek($2,0,SEEK_SET);
		     cpps = Preprocessor_parse($2);
		     start_inline(Char(cpps), start_line);
		     Delete($2);
		     Delete(cpps);
		   }
		 }
	       }
               ;

/* ------------------------------------------------------------
   %{ ... %}
   %insert(section) "filename"
   %insert("section") "filename"
   %insert(section) %{ ... %}
   %insert("section") %{ ... %}
   ------------------------------------------------------------ */

insert_directive : HBLOCK {
		 if (!WrapExtern) {
		   File *f = Swig_filebyname("header");
		   if (f) {
		     Printf(f, "%s\n", $1);
		   }
		 }
		 Delete($1);
	       }
               | INSERT LPAREN idstring RPAREN STRING {
	         if (!WrapExtern) {
		   File *f = Swig_filebyname($3);
		   if (!f) {
		     Printf(stderr,"%s:%d: Unknown target '%s' for %%insert directive.\n", input_file, line_number, $3);
		   } else {
		     if (Swig_insert_file($5,f) < 0) {
		       Printf(stderr,"%s:%d: Couldn't find '%s'. Possible installation problem.\n", input_file, line_number, $5);
		       SWIG_exit (EXIT_FAILURE);
		     }
		   }
		 }
               }
               | INSERT LPAREN idstring RPAREN HBLOCK {
		 if (!WrapExtern) {
		   File *f;
		   f = Swig_filebyname($3);
		   if (!f) {
		     Printf(stderr,"%s:%d: Unknown target '%s' for %%insert directive.\n", input_file,line_number,$3);
		   } else {
		     Printf(f,"%s\n",$5);
		   }
		 }
		 Delete($5);
               }
               ;

/* ------------------------------------------------------------
    %module modname
    %module "modname"
   ------------------------------------------------------------ */

module_directive: MODULE idstring {
		 lang->set_module($2);
		 module_init = 1;
		 init_language();
	       }
               ;

/* ------------------------------------------------------------
   %name(newname)    declaration
   %name("newname")  declaration
   ------------------------------------------------------------ */

name_directive : NAME LPAREN idstring RPAREN {
		 strcpy(yy_rename,$3);
		 Rename_true = 1;
               }
               | NAME LPAREN RPAREN {
		   Printf(stderr,"%s:%d. Missing argument to %%name directive.\n",
			   input_file, line_number);
		   FatalError();
	       }
               ;


/* ------------------------------------------------------------
   %native(scriptname) name;
   %native(scriptname) type name (parms);
   ------------------------------------------------------------ */

native_directive : NATIVE LPAREN ID RPAREN storage_class ID SEMI {
		 if (!WrapExtern) {
		   init_language();
		   if (add_symbol($3)) {
		     Printf(stderr,"%s:%d. Name of native function %s conflicts with previous declaration (ignored)\n",
			     input_file, line_number, $3);
		   } else {
		     lang->add_native($3,$6,0,0);
		   }
		 }
	       }
               | NATIVE LPAREN ID RPAREN storage_class type declarator LPAREN parms RPAREN SEMI {
		 if (!WrapExtern) {
		   init_language();
		   SwigType_push($6,$7.type);
		   if (add_symbol($3)) {
		     Printf(stderr,"%s:%d. Name of native function %s conflicts with previous declaration (ignored)\n",
			     input_file, line_number, $3);
		   } else {
		     if ($5) {
		       emit_extern_func($7.id, $6, $9, $5, f_header);
		     }
		     lang->add_native($3,$7.id,$6,$9);
		   }
		 }
		 Delete($6);
		 Delete($7.type);
		 Delete($9);
	       }
               ;


/* ------------------------------------------------------------ 
   %new declaration
   ------------------------------------------------------------ */

new_directive : NEW {
		 NewObject = 1;
	       } declaration {
		 NewObject = 0;
               }
               ;


/* ------------------------------------------------------------
   %pragma(lang) name=value
   %pragma(lang) name
   %pragma name = value
   %pragma name
   ------------------------------------------------------------ */

pragma_directive : PRAGMA pragma_lang ID EQUAL pragma_arg {
		 if (!WrapExtern) {
		   swig_pragma($2,$3,Char($5));
		   if (InClass) {  /* Hack. Fix me */
		     cplus_add_pragma($2,$3,Char($5));
		   } else {
		     lang->pragma($2,$3,Char($5));
		   }
		 }
	       }
              | PRAGMA pragma_lang ID {
		if (!WrapExtern) {
		  swig_pragma($2,$3,0);
		  if (InClass) {    /* Hack. Fix me */
		    cplus_add_pragma($2,$3,0); 
		  } else {
		    lang->pragma($2,$3,0);
		  }
		}
	      }
              ;

pragma_arg    : STRING { $$ = NewString($1); }
              | HBLOCK { $$ = $1; }
              ;

pragma_lang   : LPAREN ID RPAREN { $$ = $2; }
              | empty { $$ = (char *) "swig"; }
              ;

/* ------------------------------------------------------------
   %rename identifier newname;
   %rename identifier "newname";
   ------------------------------------------------------------ */

rename_directive : RENAME ID idstring SEMI {
		 if (!name_hash) name_hash = NewHash();
		 Setattr(name_hash,$2,$3);
	       }
               ;

/* ------------------------------------------------------------
   %typemap(method) type { ... }
   %typemap(method) type "..."
   %typemap(method) type;    - typemap deletion
   %typemap(method) type1,type2,... = type;    - typemap copy
   ------------------------------------------------------------ */

typemap_directive : TYPEMAP LPAREN typemap_type RPAREN tm_list LBRACE {
		   TMParm *p;
                   skip_brace();
		   if ($3) {
		     p = $5;
		     while (p) {
		       Swig_typemap_register($3,Gettype(p->p),Getname(p->p), CCode, p->args);
		       p = p->next;
		     }
                   }
	       }

               | TYPEMAP LPAREN typemap_type RPAREN tm_list STRING {
		   TMParm *p;
		   if ($3) {
		     p = $5;
		     while (p) {
		       Swig_typemap_register($3,Gettype(p->p),Getname(p->p), $6, p->args);
		       p = p->next;
		     }
		   }
	       }

               | TYPEMAP LPAREN typemap_type RPAREN tm_list SEMI {
		 TMParm *p;
		 if ($3) {
		   p = $5;
		   while (p) {
	             Printf(stderr,"%s:%d. Warning. Typemap deletion is temporary disabled in this release.\n", input_file, line_number);
		     /*	Swig_typemap_clear($3,Gettype(p->p),Getname(p->p)); */
		     p = p->next;
		   }
		 }
	       }
               | TYPEMAP LPAREN typemap_type RPAREN tm_list EQUAL typemap_parm SEMI {
                   TMParm *p;
		   if ($3) {
		     p = $5;
		     while (p) {
		       Swig_typemap_copy($3,Gettype($7->p),Getname($7->p),Gettype(p->p),Getname(p->p));
		       p = p->next;
		     }
		   }
	       }
               ;

/* typemap method type (lang,method) or (method) */

typemap_type   : ID COMMA tm_method {
                 if (strcmp($1,typemap_lang) == 0) {
		   $$ = $3;
		 } else {
		   $$ = 0;
		 }
               }
               | tm_method { $$ = $1; }
               ;

tm_method      : ID { $$ = $1;  }
               | CONST { $$ = Swig_copy_string((char*)"const"); }
               ;

tm_list        : typemap_parm tm_tail {
                 $$ = $1;
                 $$->next = $2;
		}
               ;

tm_tail        : COMMA typemap_parm tm_tail {
                 $$ = $2;
                 $$->next = $3;
                }
               | empty { $$ = 0;}
               ;

typemap_parm   : type typemap_parameter_declarator {
                  $$ = NewTMParm();
		  SwigType_push($1,$2.type);
		  $$->p = NewParm($1,$2.id);
		  $$->args = $2.tmargs;
		}
		;

typemap_args    : LPAREN parms RPAREN { $$ = $2; }
                | empty { $$ = 0; }
                ;


/* ------------------------------------------------------------
   %types(parmlist); 
   ------------------------------------------------------------ */

types_directive : TYPES LPAREN parms RPAREN SEMI {
	            Parm *p = $3;
                    while (p) {
		      SwigType *t = Gettype(p);
		      SwigType_remember(t);
		      p = Getnext(p);
		    }
		    Delete($3);
               }
               ;

/* ======================================================================
 *                              C Parsing
 * ====================================================================== */

c_declaration   : c_variable_decl
                | c_function_decl
                | c_enum_decl
                | c_typedef_decl

/* A an extern C type declaration.  Does nothing, but is ignored */

               | EXTERN STRING LBRACE interface RBRACE { }

                ;

/* ------------------------------------------------------------
   C variable declarations
   ------------------------------------------------------------ */

c_variable_decl : storage_class type declarator def_args {
                    init_language();
		    if ($1 == STORAGE_STATIC) {
		    Active_static = 1;
		    } else {
		    if (Active_type) Delete(Active_type);
		    Active_type = Copy($2);
		    Active_extern = $1;
		    SwigType_push($2,$3.type);
		    create_variable($1,$3.id,$2);
		    }
		 } stail { 
		    Active_static = 0;
		    Delete($2);
		    Delete($3.type);
		 }
                ;

/* ------------------------------------------------------------
   C function declarations
   ------------------------------------------------------------ */

c_function_decl : storage_class type declarator LPAREN parms RPAREN cpp_const {
		  init_language();
		  if ($1 == STORAGE_STATIC) {
		    Active_static = 1;
		  } else {
		    if (Active_type) Delete(Active_type);
		    Active_type = Copy($2);
		    Active_extern = $1;
		    SwigType_push($2,$3.type);
		    create_function($1, $3.id, $2, $5);
		  }
		  Delete($2);
		  Delete($3.type);
		  Delete($5);
		} stail { 
		  Active_static = 0;
		}

/* A function declaration with code after it */

                | storage_class type declarator LPAREN parms RPAREN func_end {
		  init_language();
		  if (($1 != STORAGE_STATIC) || ((($1 == STORAGE_STATIC) && (Inline) && (strlen(Char(CCode)))))) {
		    SwigType_push($2,$3.type);
		    create_function($1, $3.id, $2, $5);
		  }
		  Delete($2);
		  Delete($3.type);
	          Delete($5);
		}
 
               ;
         
/* ------------------------------------------------------------
   enums
 * ------------------------------------------------------------ */

c_enum_decl : storage_class ENUM ename LBRACE { scanner_clear_start(); } enumlist RBRACE SEMI {
		   init_language();
		   if ($3) {
		     if (temp_type) Delete(temp_type);
		     temp_type = NewStringf("enum %s", $3);
		     /*		     String *ts = NewSwigType(T_INT); */
		     SwigType_typedef(temp_type,$3);
		     lang->add_typedef(temp_type,$3);
		   }
	       }

/* A typdef'd enum.  Pretty common in C headers */

               | TYPEDEF ENUM ename LBRACE { scanner_clear_start(); } enumlist RBRACE ID {
		   init_language();
		   if (temp_type) Delete(temp_type);
		   temp_type = NewStringf("enum %s", $3);
		   /*		   temp_type= NewSwigType(T_INT);*/
		   Active_typedef = Copy(temp_type);
		   if ($3) {
		     SwigType_typedef(temp_type,$3);
		     lang->add_typedef(temp_type,$3);
		   }
		   if ($8) {
		     SwigType_typedef(temp_type,$8);
		     lang->add_typedef(temp_type,$8);
		   }
	       } typedeflist { }
               ;

/* ------------------------------------------------------------
   typedef
   ------------------------------------------------------------ */

c_typedef_decl   : TYPEDEF type declarator {
		   init_language();
		   /* Add a new typedef */
		   Active_typedef = Copy($2);
		   SwigType_push($2,$3.type);
		   SwigType_typedef($2, $3.id);
		   lang->add_typedef($2,$3.id);
		   cplus_register_type($3.id);
	       } typedeflist { };

/* A rudimentary typedef involving function pointers */

               | TYPEDEF type LPAREN parameter_declarator RPAREN LPAREN parms RPAREN SEMI {
		   init_language();
		   /* Typedef'd pointer */
		   DOHList *l = typelist($7);
		   SwigType_add_function($2,l);
		   SwigType_push($2,$4.type);
		   SwigType_typedef($2,$4.id);
		   lang->add_typedef($2,$4.id);
		   cplus_register_type($4.id);
		   Delete($2);
		   Delete($7);
		   Delete(l);
	       }

/* A typedef involving function pointers again */

               | TYPEDEF type abstract_declarator LPAREN parameter_declarator RPAREN LPAREN parms RPAREN SEMI {
		   init_language();
		   SwigType_push($2,$3);
		   DOHList *l = typelist($8);
		   SwigType_add_function($2,l);
		   SwigType_push($2,$5.type);
		   SwigType_typedef($2,$5.id);
		   lang->add_typedef($2,$5.id);
		   cplus_register_type($5.id);
		   Delete($2);
		   Delete($8);
		   Delete(l);
	       }
               ;

typedeflist   : COMMA declarator typedeflist {
		  if (Active_typedef) {
		    SwigType *t;
		    t = Copy(Active_typedef);
		    SwigType_push(t,$2.type);
		    SwigType_typedef(t,$2.id);
		    lang->add_typedef(t,$2.id);
		    cplus_register_type($2.id);
		    Delete(t);
		  }
              }
              | empty { }
              ;

/* Allow lists of variables and functions to be built up */

stail          : SEMI { }
               | COMMA declarator def_args {
		 init_language();
		 temp_typeptr = Copy(Active_type);
		 SwigType_push(temp_typeptr,$2.type);
		 create_variable(Active_extern, $2.id, temp_typeptr);
		 Delete(temp_typeptr);
	       } stail { }
               | COMMA declarator LPAREN parms RPAREN cpp_const {
		 init_language();
		 temp_typeptr = Copy(Active_type);
		 SwigType_push(temp_typeptr,$2.type);
		 create_function(Active_extern, $2.id, temp_typeptr, $4);
		 Delete(temp_typeptr);
		 Delete($4);
	       } stail { }
              ;


/* ======================================================================
 *                       C++ Support
 *                   (this is a mess right now)
 * ====================================================================== */

cpp_declaration : cpp_class_decl
                | cpp_forward_class_decl
                | cpp_other
             ;

cpp_class_decl  :

/* A class/struct/union  definition */
             storage_class cpptype ID inherit LBRACE {
	       char *iname;
	       init_language();
	       SwigType_new_scope();

	       sprintf(temp_name,"CPP_CLASS:%s\n",$3);
	       if (add_symbol(temp_name)) {
		 Printf(stderr,"%s:%d. Error. %s %s is multiply defined.\n", input_file, line_number, $2, $3);
		 FatalError();
	       }
	       if ((!CPlusPlus) && (strcmp($2,"class") == 0))
		 Printf(stderr,"%s:%d. *** WARNING ***. C++ mode is disabled (enable using -c++)\n", input_file, line_number);

	       iname = make_name($3);
	       if (iname == $3)
		 cplus_open_class($3, 0, $2);
	       else
	       cplus_open_class($3, iname, $2);
	       if (strcmp($2,"class") == 0)
		 cplus_mode = CPLUS_PRIVATE;
	       else
	       cplus_mode = CPLUS_PUBLIC;
	       scanner_clear_start();
	       nested_list = 0;
	       // Merge in scope from base classes
	       cplus_inherit_scope($4.count,$4.names);
	       InClass = 1;
              } cpp_members RBRACE {
	       InClass = 0;
	       if ($4.names) {
		 if (strcmp($2,"union") != 0)
		   cplus_inherit($4.count, $4.names);
		 else {
		   Printf(stderr,"%s:%d.  Inheritance not allowed for unions.\n",input_file, line_number);
		   FatalError();
		 }
	       }
	       // Clean up the inheritance list
	       if ($4.names) {
		 int j;
		 for (j = 0; j < $4.count; j++) {
		   if ($4.names[j]) free($4.names[j]);
		 }
		 free($4.names);
	       }

	       // Dumped nested declarations (if applicable)
	       dump_nested($3);

	       // Save and collapse current scope
	       SwigType_set_scope_name($3);
	       cplus_register_scope(SwigType_pop_scope());

	       cplus_class_close((char *) 0);
	       cplus_mode = CPLUS_PUBLIC;

	      }

/* Class with a typedef */

             | TYPEDEF cpptype ID inherit LBRACE {
	       char *iname;
	       init_language();
	       SwigType_new_scope();

	       sprintf(temp_name,"CPP_CLASS:%s\n",$3);
	       if (add_symbol(temp_name)) {
		 Printf(stderr,"%s:%d. Error. %s %s is multiply defined.\n", input_file, line_number, $2, $3);
		 FatalError();
	       }
	       if ((!CPlusPlus) && (strcmp($2,"class") == 0))
		 Printf(stderr,"%s:%d. *** WARNING ***. C++ mode is disabled (enable using -c++)\n", input_file, line_number);

	       iname = make_name($3);
	       if ($3 == iname)
		 cplus_open_class($3, 0, $2);
	       else
		 cplus_open_class($3, iname, $2);
	       if (strcmp($2,"class") == 0)
		 cplus_mode = CPLUS_PRIVATE;
	       else
		 cplus_mode = CPLUS_PUBLIC;
	       scanner_clear_start();
	       nested_list = 0;

	       // Merge in scope from base classes
	       cplus_inherit_scope($4.count,$4.names);
	       InClass = 1;
              } cpp_members RBRACE declarator {
		InClass = 0;
		if ($4.names) {
		  if (strcmp($2,"union") != 0)
		    cplus_inherit($4.count, $4.names);
		  else {
		    Printf(stderr,"%s:%d.  Inheritance not allowed for unions.\n",input_file, line_number);
		    FatalError();
		  }
		}
		// Create a datatype for correctly processing the typedef
		Active_typedef = NewStringf("%s %s", $2, $3);
		// Clean up the inheritance list
		if ($4.names) {
		  int j;
		  for (j = 0; j < $4.count; j++) {
		    if ($4.names[j]) free($4.names[j]);
		  }
		  free($4.names);
		}

		if ($9.type > 0) {
		  Printf(stderr,"%s:%d.  typedef struct { } %s not supported properly. Winging it...\n", input_file, line_number, SwigType_str($9.type,$9.id));

		}
		// Create dump nested class code
		if ($9.type) {
		  dump_nested($3);
		} else {
		  dump_nested($9.id);
		}

		// Collapse any datatypes created in the the class

		SwigType_set_scope_name($3);
		cplus_register_scope(SwigType_pop_scope());
		if ($9.type) {
		  cplus_class_close($3);
		} else {
		  cplus_class_close($9.id);
		}
		// Create a typedef in global scope
		if (!$9.type) {
		  SwigType_typedef(Active_typedef,$9.id);
		  lang->add_typedef(Active_typedef,$9.id);
		} else {
		  SwigType *t = Copy(Active_typedef);
		  SwigType_push(t,$9.type);
		  SwigType_typedef(t,$9.id);
		  lang->add_typedef(t,$9.id);
		  cplus_register_type($9.id);
		  Delete(t);
		}
		cplus_mode = CPLUS_PUBLIC;
	      } typedeflist { };

/* An unnamed struct with a typedef */

             | TYPEDEF cpptype LBRACE {
	       char *iname;
	       init_language();
	       SwigType_new_scope();
	       if ((!CPlusPlus) && (strcmp($2,"class") == 0))
		 Printf(stderr,"%s:%d. *** WARNING ***. C++ mode is disabled (enable using -c++)\n", input_file, line_number);

	       iname = make_name((char*)"");
	       if (strlen(iname))
		 cplus_open_class((char *)"", iname, $2);
	       else
		 cplus_open_class((char *) "",0,$2);
	       if (strcmp($2,"class") == 0)
		 cplus_mode = CPLUS_PRIVATE;
	       else
		 cplus_mode = CPLUS_PUBLIC;
	       scanner_clear_start();
	       nested_list = 0;
	       InClass = 1;
              } cpp_members RBRACE declarator {
		InClass = 0;
		if ($7.type) {
		  Printf(stderr,"%s:%d. typedef %s {} %s not supported correctly. Will be ignored.\n", input_file, line_number, SwigType_str($7.type,$7.id));
		  cplus_abort();
		} else {
		  sprintf(temp_name,"CPP_CLASS:%s\n",$7.id);
		  if (add_symbol(temp_name)) {
		    Printf(stderr,"%s:%d. Error. %s %s is multiply defined.\n", input_file, line_number, $2, $7.id);
		    FatalError();
		  }
		}
		// Create a datatype for correctly processing the typedef
		Active_typedef = NewString($7.id);

		// Dump nested classes
		if (!$7.type)
		  dump_nested($7.id);

		// Go back to previous scope

		cplus_register_scope(SwigType_pop_scope());
		if (!$7.type)
		  cplus_class_close($7.id);
		cplus_mode = CPLUS_PUBLIC;
	      } typedeflist { }
             ;

/* ------------------------------------------------------------
   class Name;
   ------------------------------------------------------------ */

cpp_forward_class_decl : storage_class cpptype ID SEMI {
	       char *iname;
	       init_language();
	       iname = make_name($3);
	       lang->cpp_class_decl($3,iname,$2);
	     }
             ;


/* Operator overloading catch */

cpp_other      : storage_class type declarator DCOLON OPERATOR {
	       Printf(stderr,"%s:%d. Operator overloading not supported (ignored).\n", input_file, line_number);
		skip_decl();
		Delete($2);
	     }


/* Template catch */
             | TEMPLATE {
	       Printf(stderr,"%s:%d. Templates not currently supported (ignored).\n",
		       input_file, line_number);
	       skip_decl();
	     }
             ;

cpp_members  : cpp_member cpp_members {}
             | ADDMETHODS LBRACE {
	           AddMethods = 1;
	     } cpp_members RBRACE {
	           AddMethods = 0;
	     } cpp_members { }
	     | error {
	       skip_decl();
		   {
		     static int last_error_line = -1;
		     if (last_error_line != line_number) {
		       Printf(stderr,"%s:%d. Syntax error in input.\n", input_file, line_number);
		       FatalError();
		       last_error_line = line_number;
		     }
		   }
	     } cpp_members { }
             | empty { }
             ;

cpp_member   :  type declarator LPAREN parms RPAREN cpp_end {
                char *iname;
		init_language();
		if (cplus_mode == CPLUS_PUBLIC) {
		  SwigType_push($1,$2.type);
		  iname = make_name($2.id);
		  if (iname == $2.id) iname = 0;
		  cplus_member_func($2.id, iname, $1,$4,0);
		}
		scanner_clear_start();
		Delete($1);
	        Delete($4);
              }

/* Virtual member function */

             |  VIRTUAL type declarator LPAREN parms RPAREN cpp_vend {
	       char *iname;
	       init_language();
	       if (cplus_mode == CPLUS_PUBLIC) {
		 SwigType_push($2,$3.type);
		 iname = make_name($3.id);
		 if (iname == $3.id) iname = 0;
		 cplus_member_func($3.id,iname,$2,$5,$7 ? PURE_VIRTUAL : PLAIN_VIRTUAL);
	       }
	       scanner_clear_start();
	       Delete($2);
	       Delete($5);
	     }

/* Possibly a constructor */
              | ID LPAREN parms RPAREN ctor_end {
		char *iname;
		init_language();
		if (cplus_mode == CPLUS_PUBLIC) {
		  iname = make_name($1);
		  if (iname == $1) iname = 0;
		  cplus_constructor($1,iname, $3);
		}
		scanner_clear_start();
		Delete($3);
	      }

/* A destructor (hopefully) */

              | NOT ID LPAREN parms RPAREN cpp_end {
		char *iname;
		init_language();
		if (cplus_mode == CPLUS_PUBLIC) {
		  iname = make_name($2);
		  if (iname == $2) iname = 0;
		  cplus_destructor($2,iname);
		}
		scanner_clear_start();
		Delete($4);
	      }

/* A virtual destructor */

              | VIRTUAL NOT ID LPAREN parms RPAREN cpp_vend {
 	        char *iname;
		init_language();
		if (cplus_mode == CPLUS_PUBLIC) {
		  iname = make_name($3);
		  if (iname == $3) iname = 0;
		  cplus_destructor($3,iname);
		}
		scanner_clear_start();
		Delete($5);
	      }

/* Member data */

              | type declarator def_args {
		char *iname;
		init_language();
		if (cplus_mode == CPLUS_PUBLIC) {
		  if (Active_type) Delete(Active_type);
		  Active_type = Copy($1);
		  SwigType_push($1,$2.type);
		  iname = make_name($2.id);
		  if (iname == $2.id) iname = 0;
		  int oldstatus = Status;
		  if (SwigType_isconst($1)) {
		    Status |= STAT_READONLY;
		  }
		  cplus_variable($2.id,iname,$1);
		  Status = oldstatus;
		}
		scanner_clear_start();
		Delete($1);
	      } cpp_tail { }

/* Static Member data */

              | STATIC type declarator def_args {
		char *iname;
		init_language();
		if (cplus_mode == CPLUS_PUBLIC) {
		  SwigType_push($2,$3.type);
		  iname = make_name($3.id);
		  if (iname == $3.id) iname = 0;
		  int oldstatus = Status;
		  if (SwigType_isconst($2)) {
		    Status |= STAT_READONLY;
		  }
		  cplus_static_var($3.id,iname,$2);
		  Status = oldstatus;
		  if (Active_type) Delete(Active_type);
		  Active_type = Copy($2);
		}
		scanner_clear_start();
		Delete($2);
	      } cpp_tail { }

/* Static member function */

              | STATIC type declarator LPAREN parms RPAREN cpp_end {
		char *iname;
		SwigType_push($2,$3.type);
		if (cplus_mode == CPLUS_PUBLIC) {
		  iname = make_name($3.id);
		  if (iname == $3.id) iname = 0;
		  cplus_static_func($3.id, iname, $2, $5);
		}
		scanner_clear_start();
		Delete($2);
		Delete($5);
	      }
/* Turn on public: mode */

              | PUBLIC COLON {
		cplus_mode = CPLUS_PUBLIC;
		scanner_clear_start();
	      }

/* Turn on private: mode */

              | PRIVATE COLON {
		cplus_mode = CPLUS_PRIVATE;
		scanner_clear_start();
	      }

/* Turn on protected mode */

              | PROTECTED COLON {
		cplus_mode = CPLUS_PROTECTED;
		scanner_clear_start();
	      }

/* This is the new style rename */

             | NAME LPAREN ID RPAREN {
	       strcpy(yy_rename,$3);
	       Rename_true = 1;
	     }

/* New mode */
             | NEW {
                 NewObject = 1;
             } cpp_member {
                 NewObject = 0;
             }

/* C++ Enum */
              | ENUM ename LBRACE {scanner_clear_start();} cpp_enumlist RBRACE SEMI {

		 // if ename was supplied.  Install it as a new integer datatype.
		init_language();
		if (cplus_mode == CPLUS_PUBLIC) {
		  if ($2) {
		    cplus_register_type($2);
		    if (temp_type) Delete(temp_type);
		    /*		    temp_type = NewSwigType(T_INT); */
		    temp_type = NewStringf("enum %s",$2);
		    SwigType_typedef(temp_type,$2);
		    lang->add_typedef(temp_type,$2);
		  }
		}
	      }

/* A friend :   Illegal */
              | FRIEND {
		Printf(stderr,"%s:%d. Friends are not allowed--members only! (ignored)\n", input_file, line_number);
		skip_decl();
		scanner_clear_start();
	      }

/* An operator: Illegal */
              | type abstract_declarator OPERATOR {
		Printf(stderr,"%s:%d. Operator overloading not supported (ignored).\n", input_file, line_number);
		skip_decl();
		scanner_clear_start();
	      }

/* A typedef inside a class */
              | c_typedef_decl { }

/* Pragma directive */

              | pragma_directive {
		scanner_clear_start();
	      }

/* A constant (includes #defines) inside a class */
              | constant_directive { }


/* ----------------------------------------------------------------------
   Nested structure.    This is a big ugly "hack".   If we encounter
   a nested structure, we're going to grab the text of its definition and
   feed it back into the scanner.  In the meantime, we need to grab
   variable declaration information and generate the associated wrapper
   code later.  Yikes!

   This really only works in a limited sense.   Since we use the
   code attached to the nested class to generate both C/C++ code,
   it can't have any SWIG directives in it.  It also needs to be parsable
   by SWIG or this whole thing is going to puke.
   ---------------------------------------------------------------------- */

/* A struct sname { } id;  declaration */

              | cpptype ID LBRACE { start_line = line_number; skip_brace();
	      } nested_decl SEMI {

		if (cplus_mode == CPLUS_PUBLIC) {
		  cplus_register_type($2);
		  if ($5.id) {
		    if (strcmp($1,"class") == 0) {
		      Printf(stderr,"%s:%d.  Warning. Nested classes not currently supported (ignored).\n", input_file, line_number);
		      /* Generate some code for a new class */
		    } else {
		      Nested *n = (Nested *) malloc(sizeof(Nested));
		      n->code = NewString("");
		      Printv(n->code, "typedef ", $1, " ",
			      Char(CCode), " $classname_", $5.id, ";\n", 0);
		      n->name = Swig_copy_string($5.id);
		      n->line = start_line;
		      n->type = NewString("");
		      SwigType_push(n->type, $5.type);
		      n->next = 0;
		      add_nested(n);
		    }
		  }
		}
	      }
/* An unnamed structure definition */
              | cpptype LBRACE { start_line = line_number; skip_brace();
              } declarator SEMI {
		if (cplus_mode == CPLUS_PUBLIC) {
		  if (strcmp($1,"class") == 0) {
		    Printf(stderr,"%s:%d.  Warning. Nested classes not currently supported (ignored)\n", input_file, line_number);
		    /* Generate some code for a new class */
		  } else {
		    /* Generate some code for a new class */

		    Nested *n = (Nested *) malloc(sizeof(Nested));
		    n->code = NewString("");
		    Printv(n->code, "typedef ", $1, " " ,
			    Char(CCode), " $classname_", $4.id, ";\n",0);
		    n->name = Swig_copy_string($4.id);
		    n->line = start_line;
		    n->type = NewString("");
		    SwigType_push(n->type,$4.type);
		    n->next = 0;
		    add_nested(n);

		  }
		}
	      }
/* An empty class declaration */
              | cpptype ID SEMI {
  		    if (cplus_mode == CPLUS_PUBLIC) {
                       cplus_register_type($2);
                    }
              }

/* Other miscellaneous stuff */

              | SEMI { }
              ;

nested_decl   : declarator { $$ = $1;}
              | empty { $$.id = 0; }
              ;

cpp_tail      : SEMI { }
               | COMMA declarator def_args {
		 init_language();
		 if (cplus_mode == CPLUS_PUBLIC) {
		   temp_typeptr = Copy(Active_type);
		   SwigType_push(temp_typeptr,$2.type);
		   int oldstatus = Status;
		   if (SwigType_isconst(temp_typeptr)) {
		     Status |= STAT_READONLY;
		   }
		   cplus_variable($2.id,(char *) 0, temp_typeptr);
		   Status = oldstatus;
		   Delete(temp_typeptr);
		 }
		 scanner_clear_start();
	       } cpp_tail { }
               ;

cpp_end        : cpp_const SEMI {
	            Clear(CCode);
               }
               | cpp_const LBRACE { skip_brace(); }
               ;

cpp_vend       : cpp_const SEMI { Clear(CCode); $$ = 0;  }
               | cpp_const EQUAL definetype SEMI { Clear(CCode); $$ = 1; }
               | cpp_const LBRACE { skip_brace(); $$ = 0; }
               ;

cpp_enumlist   :  cpp_enumlist COMMA cpp_edecl {}
               |  cpp_edecl {}
               ;

cpp_edecl      :  ID {
		 if (cplus_mode == CPLUS_PUBLIC) {
		   temp_typeptr = NewSwigType(T_INT);
		   my_cplus_declare_const($1, (char *) 0, temp_typeptr, (char *) 0);
		   Delete(temp_typeptr);
		   scanner_clear_start();
		 }
}
                 | ID EQUAL etype {
		   if (cplus_mode == CPLUS_PUBLIC) {
		     temp_typeptr = NewSwigType(T_INT);
		     my_cplus_declare_const($1,(char *) 0, temp_typeptr,(char *) 0);
		     // OLD : Bug with value     my_cplus_declare_const($1,(char *) 0, temp_typeptr,$3.id);
		     Delete(temp_typeptr);
		     scanner_clear_start();
		   }
		 }
                 | NAME LPAREN ID RPAREN ID {
		   if (cplus_mode == CPLUS_PUBLIC) {
		     temp_typeptr = NewSwigType(T_INT);
		     my_cplus_declare_const($5, $3, temp_typeptr, (char *) 0);
		     Delete(temp_typeptr);
		     scanner_clear_start();
		   }
		 }
                 | NAME LPAREN ID RPAREN ID EQUAL etype {
		     if (cplus_mode == CPLUS_PUBLIC) {
		       temp_typeptr = NewSwigType(T_INT);
		       my_cplus_declare_const($5,$3, temp_typeptr, (char *) 0);
		       Delete(temp_typeptr);
		       scanner_clear_start();
		     }
		 }
                 | empty { }
                 ;




/* ====================================================================== 
 *                       PRIMITIVES
 * ====================================================================== */

storage_class  : EXTERN {
	           $$ = STORAGE_EXTERN;
               }
               | EXTERN STRING {
                   if (strcmp($2,"C") == 0) {
		     $$ = STORAGE_EXTERN_C;
		   } else {
		     Printf(stderr,"%s:%d.  Unrecognized extern type \"%s\" (ignored).\n", input_file,line_number, $2);
		     $$ = 0;
		   }
               }
               | STATIC {
                   $$ = STORAGE_STATIC;
               }
               | empty {
                   $$ = 0;
               }
               ;

/* End of a function declaration.  Allows C++ "const" directive and inline code */

func_end       : cpp_const LBRACE { skip_brace(); }
               ;


/* ------------------------------------------------------------------------------
   Function parameter lists

   ------------------------------------------------------------------------------ */

parms          : parm ptail {
                  SwigType *pt = Gettype($1);
		  if (SwigType_type(pt) != T_VOID) {
		    Setnext($1,$2);
		    $$ = $1;
		  } else {
		    $$ = $2;
		  }
		}
               | empty { $$ = 0; }
               ;

ptail          : COMMA parm ptail {
                 Setnext($2,$3);
		 $$ = $2;
                }
               | empty { $$ = 0; }
               ;

parm           : parm_type {
                  $$ = $1;
               }


parm_type      : type parameter_declarator {
                   SwigType_push($1,$2.type);
		   $$ = NewParm($1,$2.id);
		   if ($2.defarg)
		     Setvalue($$,$2.defarg);
		}

                /* pointer to function */

                | type LPAREN parameter_declarator RPAREN LPAREN parms RPAREN def_args {
		  List *l = typelist($6);
                  SwigType_add_function($1,l);
		  SwigType_push($1,$3.type);
		  $$ = NewParm($1,$3.id);
		  if ($8.val) {
		    Setvalue($$,$8.val);
		  }
		  Delete(l);
		}

                | type abstract_declarator LPAREN parameter_declarator RPAREN LPAREN parms RPAREN def_args {
		  List *l = typelist($7);
		  SwigType_push($1,$2);
                  SwigType_add_function($1,l);
		  SwigType_push($1,$4.type);
		  $$ = NewParm($1,$4.id);
		  if ($9.val) {
		    Setvalue($$,$9.val);
		  }
		  Delete(l);
		}

                | PERIOD PERIOD PERIOD {
                  Printf(stderr,"%s:%d. Variable length arguments not supported (ignored).\n", input_file, line_number);
		  $$ = NewParm(NewSwigType(T_INT),(char *) "varargs");
		  FatalError();
		}
		;

def_args       : EQUAL definetype { 
                  $$ = $2; 
               }
               | EQUAL AND ID {
		 $$.val = NewStringf("&%s",$3);
		 $$.type = T_USER;
	       }
               | EQUAL LBRACE {
		 skip_brace();
		 $$.val = 0;
                 $$.type = T_INT;
	       }
               | COLON NUM_INT { /* bit field specifier. Ignored */ }
               | empty {$$.val = 0; $$.type = T_INT;}
               ;

/* [ 7/28/01 ]  This code added to clean up the handling of pointers and qualifiers */

parameter_declarator : declarator def_args {
                 $$ = $1;
		 $$.defarg = $2.val;
            }
            | abstract_declarator def_args {
              $$.type = $1;
	      $$.id = 0;
              $$.defarg = $2.val;
            }
            | def_args {
   	      $$.type = 0;
              $$.id = 0;
	      $$.defarg = $1.val;
            }
            ;

typemap_parameter_declarator : declarator typemap_args {
                 $$ = $1;
		 $$.tmargs = $2;
            }
            | abstract_declarator typemap_args {
              $$.type = $1;
	      $$.id = 0;
              $$.tmargs = $2;
            }
            | typemap_args {
   	      $$.type = 0;
              $$.id = 0;
	      $$.tmargs = $1;
            }
            ;


declarator :  pointer direct_declarator {
              $$ = $2;
              SwigType_push($1,$$.type);
	      Delete($$.type);
	      $$.type = $1;
           }
           | direct_declarator {
              $$ = $1;
           }
           ;

direct_declarator : ID { 
       	             $$.id = $1;
		     $$.type = 0;
                  }
                  | AND ID { 
                     $$.id = $2;
		     $$.type = NewString("");
		     SwigType_add_reference($$.type);
		  }
                  | direct_declarator LBRACKET RBRACKET { 
		    SwigType *t;
		    $$ = $1;
		    t = NewString("");
		    SwigType_add_array(t,(char*)"");
		    if ($$.type) {
		      SwigType_push(t,$$.type);
		      Delete($$.type);
		    }
		    $$.type = t;
                  }
                  | direct_declarator LBRACKET expr RBRACKET { 
		    SwigType *t;
		    $$ = $1;
		    t = NewString("");
		    SwigType_add_array(t,$3.val);
		    if ($$.type) {
		      SwigType_push(t,$$.type);
		      Delete($$.type);
		    }
		    $$.type = t;
                  }
                  ;

abstract_declarator : pointer {
		    $$ = $1;
                  }
                  | pointer direct_abstract_declarator { 
                     SwigType_push($1,$2);
		     $$ = $1;
                  }
                  | direct_abstract_declarator {
		    $$ = $1;
                  }
                  ;

direct_abstract_declarator : AND {
		     $$ = NewString("");
		     SwigType_add_reference($$);
		  }
                  | direct_abstract_declarator LBRACKET RBRACKET { 
		    SwigType *t;
		    $$ = $1;
		    t = NewString("");
		    SwigType_add_array(t,(char*)"");
		    if ($$) {
		      SwigType_push(t,$$);
		      Delete($$);
		    }
		    $$ = t;
                  }
                  | direct_abstract_declarator LBRACKET expr RBRACKET { 
		    SwigType *t;
		    $$ = $1;
		    t = NewString("");
		    SwigType_add_array(t,$3.val);
		    if ($$) {
		      SwigType_push(t,$$);
		      Delete($$);
		    }
		    $$ = t;
                  }
                  | LBRACKET RBRACKET { 
		    $$ = NewString("");
		    SwigType_add_array($$,(char*)"");
                  }
                  | LBRACKET expr RBRACKET { 
		    $$ = NewString("");
		    SwigType_add_array($$,$2.val);
                  }
                  ;


pointer    : STAR type_qualifier pointer { 
               $$ = $3;  
               SwigType_add_pointer($$);
	       SwigType_add_qualifier($$,$2);
           }
           | STAR pointer {
	     $$ = $2;
	     SwigType_add_pointer($$);
	     } 
           | STAR type_qualifier { 
	     	$$ = NewString("");	
		SwigType_add_pointer($$);
		SwigType_add_qualifier($$,$2);
           }
           | STAR {
	      $$ = NewString("");
	      SwigType_add_pointer($$);
	      }
           ;

type_qualifier : CONST { $$ = "const"; }
               | CONST type_qualifier { $$ = "const"; }
               ;
 
/* Data type must be a built in type or an identifier for user-defined types
   This type can be preceded by a modifier. */

type           : type_qualifier type_right {
                   $$ = $2;
		   SwigType_add_qualifier($$,$1);
               }
               | type_right { $$ = $1; }
               ;

type_right     : TYPE_INT { $$ = $1; }
               | TYPE_SHORT opt_int { $$ = $1; }
               | TYPE_LONG opt_int { $$ = $1; }
	       | TYPE_LONG TYPE_LONG opt_int { $$ = NewString("long long");  }
               | TYPE_CHAR { $$ = $1; }
               | TYPE_BOOL { $$ = $1; }
               | TYPE_FLOAT { $$ = $1; }
               | TYPE_DOUBLE { $$ = $1; }
               | TYPE_VOID { $$ = $1; }
               | TYPE_SIGNED opt_signed {
		   if ($2) $$ = $2;
		   else $$ = $1;
	       }
               | TYPE_UNSIGNED opt_unsigned {
                   if ($2) $$ = $2;
		   else $$ = $1;
	       }
               | cpptype ID { $$ = NewStringf("%s %s", $1, $2); }
               | TYPE_TYPEDEF template_decl { $$ = NewStringf("%s%s",$1,$2); }
               | ENUM ID { $$ = NewStringf("enum %s", $2); }
               | TYPE_RAW { $$ = $1; }
               | type_right type_qualifier {
		  $$ = $1;
		  SwigType_add_qualifier($$,$2);
     	       }
               | ID template_decl { $$ = NewStringf("%s%s",$1,$2); }
               | ID DCOLON ID     { $$ = NewStringf("%s::%s", $1,$3); }
               | DCOLON ID        { $$ = NewString($2); }
               ;

/* Optional signed types */

opt_signed     : empty                       { $$ = 0; }
               | TYPE_INT                    { $$ = $1; }
               | TYPE_SHORT opt_int          { $$ = $1; }
               | TYPE_LONG opt_int           { $$ = $1; }
	       | TYPE_LONG TYPE_LONG opt_int { $$ = NewString("long long"); }
               | TYPE_CHAR                   { $$ = NewString("signed char"); }
               ;

/* Optional unsigned types */

opt_unsigned   : empty                       { $$ = 0; }
               | TYPE_INT                    { $$ = NewString("unsigned int"); }
               | TYPE_SHORT opt_int          { $$ = NewString("unsigned short"); }
               | TYPE_LONG opt_int           { $$ = NewString("unsigned long"); }
	       | TYPE_LONG TYPE_LONG opt_int { $$ = NewString("unsigned long long"); }
               | TYPE_CHAR                   { $$ = NewString("unsigned char"); }
               ;

opt_int        : TYPE_INT { }
               | empty { }
               ;

definetype     : { scanner_check_typedef(); } expr {
                   $$ = $2;
		   scanner_ignore_typedef();
                }
                | STRING {
                   $$.val = NewString($1);
                   $$.type = T_STRING;
		}
                | CHARCONST {
                   $$.val = NewString($1);
		   $$.type = T_CHAR;
		 }
                ;

/* Some stuff for handling enums */

ename          :  ID { $$ = $1; }
               |  empty { $$ = (char *) 0;}
               ;

/* SWIG enum list. */

enumlist       :  enumlist COMMA edecl {}
               |  edecl {}
               ;


edecl          :  ID {
		   temp_typeptr = NewSwigType(T_INT);
		   create_constant($1, temp_typeptr, $1);
		   Delete(temp_typeptr);
		 }
                 | ID EQUAL { scanner_check_typedef();} etype {
		   temp_typeptr = NewSwigType($4.type);
	           if ($4.type == T_CHAR)
	               create_constant($1,temp_typeptr, Char($4.val));
		   else
		     create_constant($1, temp_typeptr, $1);
		   Delete(temp_typeptr);
  	           scanner_ignore_typedef();
                 }
                 | empty { }
                 ;

etype            : expr {
                   $$ = $1;
		   if (($$.type != T_INT) && ($$.type != T_UINT) &&
		       ($$.type != T_LONG) && ($$.type != T_ULONG) &&
		       ($$.type != T_SHORT) && ($$.type != T_USHORT) &&
		       ($$.type != T_SCHAR) && ($$.type != T_UCHAR)) {
		     Printf(stderr,"%s:%d. Type error. Expecting an int\n",
			     input_file, line_number);
		     FatalError();
		   }

                }
                | CHARCONST {
                   $$.val  = NewString($1);
		   $$.type = T_INT;
		 }
                ;

/* Arithmetic expressions.   Used for constants and other cool stuff.
   Really, we're not doing anything except string concatenation, but
   this does allow us to parse many constant declarations.
 */

expr           :  NUM_INT {
                  $$.val = $1;
                  $$.type = T_INT;
                 }
               |  NUM_FLOAT {
                  $$.val = $1;
                  $$.type = T_DOUBLE;
               }
               |  NUM_UNSIGNED {
                  $$.val = $1;
		  $$.type = T_UINT;
	       }
               |  NUM_LONG {
                  $$.val = $1;
		  $$.type = T_LONG;
	       }
               |  NUM_ULONG {
                  $$.val = $1;
		  $$.type = T_ULONG;
	       }
               |  SIZEOF LPAREN type parameter_declarator RPAREN {
  		  SwigType_push($3,$4.type);
		  $$.val = NewStringf("sizeof(%s)",SwigType_str($3,0));
		  $$.type = T_INT;
	       }
               | ID {
		 $$.val = NewString($1);
		 $$.type = T_INT;
               }
               | ID DCOLON ID {
		 $$.val = NewStringf("%s::%s",$1,$3);
		 $$.type = T_INT;
               }
               | expr PLUS expr {
		 $$.val = NewStringf("%s+%s",$1.val,$3.val);
		 $$.type = promote($1.type,$3.type);
	       }
               | expr MINUS expr {
		 $$.val = NewStringf("%s-%s",$1.val,$3.val);
		 $$.type = promote($1.type,$3.type);
	       }
               | expr STAR expr {
		 $$.val = NewStringf("%s*%s",$1.val,$3.val);
		 $$.type = promote($1.type,$3.type);
	       }
               | expr SLASH expr {
		 $$.val = NewStringf("%s/%s",$1.val,$3.val);
		 $$.type = promote($1.type,$3.type);
	       }
               | expr AND expr {
		 $$.val = NewStringf("%s&%s",$1.val,$3.val);
		 $$.type = promote($1.type,$3.type);
		 if (($1.type == T_DOUBLE) || ($3.type == T_DOUBLE)) {
		   Printf(stderr,"%s:%d. Type error in constant expression (expecting integers).\n", input_file, line_number);
		   FatalError();
		 }
	       }
               | expr OR expr {
		 $$.val = NewStringf("%s|%s",$1.val,$3.val);
		 $$.type = promote($1.type,$3.type);
		 if (($1.type == T_DOUBLE) || ($3.type == T_DOUBLE)) {
		   Printf(stderr,"%s:%d. Type error in constant expression (expecting integers).\n", input_file, line_number);
		   FatalError();
		 }
		 $$.type = T_INT;
	       }
               | expr XOR expr {
		 $$.val = NewStringf("%s^%s",$1.val,$3.val);
		 $$.type = promote($1.type,$3.type);
		 if (($1.type == T_DOUBLE) || ($3.type == T_DOUBLE)) {
		   Printf(stderr,"%s:%d. Type error in constant expression (expecting integers).\n", input_file, line_number);
		   FatalError();
		 }
		 $$.type = T_INT;
	       }
               | expr LSHIFT expr {
		 $$.val = NewStringf("%s<<%s",$1.val,$3.val);
		 $$.type = promote($1.type,$3.type);
		 if (($1.type == T_DOUBLE) || ($3.type == T_DOUBLE)) {
		   Printf(stderr,"%s:%d. Type error in constant expression (expecting integers).\n", input_file, line_number);
		   FatalError();
		 }
		 $$.type = T_INT;
	       }
               | expr RSHIFT expr {
		 $$.val = NewStringf("%s>>%s",$1.val,$3.val);
		 $$.type = promote($1.type,$3.type);
		 if (($1.type == T_DOUBLE) || ($3.type == T_DOUBLE)) {
		   Printf(stderr,"%s:%d. Type error in constant expression (expecting integers).\n", input_file, line_number);
		   FatalError();
		 }
		 $$.type = T_INT;
	       }
               |  MINUS expr %prec UMINUS {
		 $$.val = NewStringf("-%s",$2.val);
		 $$.type = $2.type;
	       }
               |  NOT expr {
		 $$.val = NewStringf("~%s",$2.val);
		 if ($2.type == T_DOUBLE) {
		   Printf(stderr,"%s:%d. Type error in constant expression (expecting integers).\n", input_file, line_number);
		   FatalError();
		 }
		 $$.type = $2.type;
	       }
               |  LPAREN expr RPAREN {
		 $$.val = NewStringf("(%s)",$2.val);
		 $$.type = $2.type;
	       }
               ;

inherit        : COLON base_list {
		   $$ = $2;
                }
                | empty {
                   $$.names = (char **) 0;
		   $$.count = 0;
                }
                ;

base_list      : base_specifier {
                   int i;
                   $$.names = (char **) malloc(NI_NAMES*sizeof(char *));
		   $$.count = 0;
		   for (i = 0; i < NI_NAMES; i++){
		     $$.names[i] = (char *) 0;
		   }
                   if ($1) {
                       $$.names[$$.count] = Swig_copy_string($1);
                       $$.count++;
		   }
               }

               | base_list COMMA base_specifier {
                   $$ = $1;
                   if ($3) {
		     $$.names[$$.count] = Swig_copy_string($3);
		     $$.count++;
		   }
               }
               ;

base_specifier : ID {
                  Printf(stderr,"%s:%d. No access specifier given for base class %s (ignored).\n",
			  input_file,line_number,$1);
		  $$ = (char *) 0;
               }
               | VIRTUAL ID {
                  Printf(stderr,"%s:%d. No access specifier given for base class %s (ignored).\n",
			  input_file,line_number,$2);
		  $$ = (char *) 0;
	       }
	       | VIRTUAL access_specifier ID {
		 if (strcmp($2,"public") == 0) {
		   $$ = $3;
		 } else {
		   Printf(stderr,"%s:%d. %s inheritance not supported (ignored).\n",
			   input_file,line_number,$2);
		   $$ = (char *) 0;
		 }
               }
               | access_specifier ID {
		 if (strcmp($1,"public") == 0) {
		   $$ = $2;
		 } else {
		   Printf(stderr,"%s:%d. %s inheritance not supported (ignored).\n",
			   input_file,line_number,$1);
		   $$ = (char *) 0;
		 }
	       }
               | access_specifier VIRTUAL ID {
                 if (strcmp($1,"public") == 0) {
		   $$ = $3;
		 } else {
		   Printf(stderr,"%s:%d. %s inheritance not supported (ignored).\n",
			   input_file,line_number,$1);
		   $$ = (char *) 0;
		 }
               }
               ;

access_specifier :  PUBLIC { $$ = (char*)"public"; }
               | PRIVATE { $$ = (char*)"private"; }
               | PROTECTED { $$ = (char*)"protected"; }
               ;


cpptype        : CLASS { $$ = (char*)"class"; }
               | STRUCT { $$ = (char*)"struct"; }
               | UNION {$$ = (char*)"union"; }
               ;

cpp_const      : CONST {}
               | THROW LPAREN parms RPAREN { Delete($3);}
               | CONST THROW LPAREN parms RPAREN { Delete($4);}
               | empty {}
               ;

/* Constructor initializer */

ctor_end       : cpp_const ctor_initializer SEMI {
		Clear(CCode);
               }
               | cpp_const ctor_initializer LBRACE { skip_brace(); }
               ;

ctor_initializer : COLON mem_initializer_list {}
               | empty {}
               ;

mem_initializer_list : mem_initializer { }
               | mem_initializer_list COMMA mem_initializer { }
               ;

mem_initializer : ID LPAREN expr_list RPAREN { }
               | ID LPAREN RPAREN { }
                ;

expr_list      : expr { }
               | expr_list COMMA expr { }
               ;

template_decl : LESSTHAN { 
                     skip_template();
	             Replace(CCode,"\n"," ", DOH_REPLACE_ANY);
                     Replace(CCode,"\t"," ", DOH_REPLACE_ANY);
	             Replace(CCode,"  "," ", DOH_REPLACE_ANY);
		     /* Canonicalize whitespace around angle brackets and commas */
		     while (Replace(CCode, "< ", "<", DOH_REPLACE_ANY));
		     while (Replace(CCode, " >", ">", DOH_REPLACE_ANY));
		     while (Replace(CCode, " ,", ",", DOH_REPLACE_ANY));
		     while (Replace(CCode, ", ", ",", DOH_REPLACE_ANY));
		     Replace(CCode,">"," >", DOH_REPLACE_ANY);
                   $$ = Char(CCode);
                 }
               | empty {
                   $$ = (char*)"";
               }
               ;

idstring       : ID { $$ = $1; }
               | STRING { $$ = $1; }
               ;

empty          :   ;

%%

/* Called by the parser (yyparse) when an error is found.*/
void yyerror (const char *) {
}
